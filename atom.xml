<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>红宝石星球</title>
  
  <subtitle>凡心所向，素履以往；生如逆旅，一苇以航。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://suprisemf.github.io/"/>
  <updated>2018-08-03T02:42:29.493Z</updated>
  <id>http://suprisemf.github.io/</id>
  
  <author>
    <name>SupriseMF</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ConcurrentHashMap</title>
    <link href="http://suprisemf.github.io/2018/08/03/ConcurrentHashMap/"/>
    <id>http://suprisemf.github.io/2018/08/03/ConcurrentHashMap/</id>
    <published>2018-08-03T02:40:48.000Z</published>
    <updated>2018-08-03T02:42:29.493Z</updated>
    
    <content type="html"><![CDATA[<h4 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h4><h4 id="jdk-17中的concurrenthashmap"><a class="markdownIt-Anchor" href="#jdk-17中的concurrenthashmap"></a> JDK 1.7中的ConcurrentHashMap</h4><h4 id="jdk-18中的concurrenthashmap"><a class="markdownIt-Anchor" href="#jdk-18中的concurrenthashmap"></a> JDK 1.8中的ConcurrentHashMap</h4><h4 id="源码分析"><a class="markdownIt-Anchor" href="#源码分析"></a> 源码分析</h4><p>妈耶~ 这个部分内容真的很多~ 先挖个坑，这个文章全部写完后再补上~~</p><p><a href="https://javadoop.com/post/hashmap" target="_blank" rel="noopener">强力推荐阅读</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;概述&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#概述&quot;&gt;&lt;/a&gt; 概述&lt;/h4&gt;
&lt;h4 id=&quot;jdk-17中的concurrenthashmap&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#jdk-
      
    
    </summary>
    
      <category term="Java之并发编程" scheme="http://suprisemf.github.io/categories/Java%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java" scheme="http://suprisemf.github.io/tags/Java/"/>
    
      <category term="并发编程" scheme="http://suprisemf.github.io/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>简浅说之Spring与线程安全</title>
    <link href="http://suprisemf.github.io/2018/08/03/%E7%AE%80%E6%B5%85%E8%AF%B4%E4%B9%8BSpring%E4%B8%8E%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/"/>
    <id>http://suprisemf.github.io/2018/08/03/简浅说之Spring与线程安全/</id>
    <published>2018-08-03T02:34:44.000Z</published>
    <updated>2018-08-03T02:35:18.458Z</updated>
    
    <content type="html"><![CDATA[<h4 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h4><p>Spring作为一个IoC容器，管理了Spring中所有的bean，但它并不保证其bean的线程安全，需要开发者自己实现线程安全。</p><a id="more"></a><h4 id="spring"><a class="markdownIt-Anchor" href="#spring"></a> Spring</h4><p>Spring为每个Bean提供了scope属性用来表示该Bean的作用域，指定该Bean的生命周期   ：singleton或prototype。</p><ol><li>当scope为singleton（默认值）时，该Bean第一次被创建时，被注入到IoC容器中，并一直作用到应用结束，即与IoC容器的生命周期一致。</li><li>当scope为prototype时，该Bean每一次被创建时，都会被注入到IoC容器中。</li></ol><p>Spring中的对象都是无状态对象：不会因为多线程间调用而发生状态改变，即线程安全。其非常适合Spring的默认scope：singleton单例。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;概述&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#概述&quot;&gt;&lt;/a&gt; 概述&lt;/h4&gt;
&lt;p&gt;Spring作为一个IoC容器，管理了Spring中所有的bean，但它并不保证其bean的线程安全，需要开发者自己实现线程安全。&lt;/p&gt;
    
    </summary>
    
      <category term="Java之并发编程" scheme="http://suprisemf.github.io/categories/Java%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java" scheme="http://suprisemf.github.io/tags/Java/"/>
    
      <category term="并发编程" scheme="http://suprisemf.github.io/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>多线程并发的最佳实践总结</title>
    <link href="http://suprisemf.github.io/2018/08/03/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93/"/>
    <id>http://suprisemf.github.io/2018/08/03/多线程并发的最佳实践总结/</id>
    <published>2018-08-03T01:53:38.000Z</published>
    <updated>2018-08-03T02:34:12.868Z</updated>
    
    <content type="html"><![CDATA[<h4 id="使用本地变量"><a class="markdownIt-Anchor" href="#使用本地变量"></a> 使用本地变量</h4><ol><li>优先考虑使用本地变量，避免创建一个类或实例的变量；</li><li>这样可以节省内存，并进行复用；</li></ol><h4 id="使用不可变类"><a class="markdownIt-Anchor" href="#使用不可变类"></a> 使用不可变类</h4><p>降低代码中需要的同步变量，充分利用JVM提供的功能。</p><a id="more"></a><h4 id="最小化锁的作用域范围"><a class="markdownIt-Anchor" href="#最小化锁的作用域范围"></a> 最小化锁的作用域范围</h4><p>大名鼎鼎的阿姆达尔定律，表达式为：</p><p>S=1/(1-a+a/n)</p><p>其中：<br>a是并行计算部分所占的比例，<br>n是并行计算所处理的结点个数，<br>S是最终的加速比。</p><blockquote><p>当1-a=0时，(即没有串行，只有并行)最大加速比s=n；当a=0时（即只有串行，没有并行），最小加速比s=1；当n→∞时，极限加速比s→ 1/（1-a），这也就是加速比的上限。例如，若串行代码占整个代码的25%，则并行处理的总体性能不可能超过4。</p></blockquote><h4 id="使用线程池的executor"><a class="markdownIt-Anchor" href="#使用线程池的executor"></a> 使用线程池的Executor</h4><p>避免new Thread创建线程。通过线程池的管理，尅提高线程的复用性（避免新建线程的昂贵的资源消耗），简化线程生命周期的管理。</p><h4 id="避免使用线程的wait和notify"><a class="markdownIt-Anchor" href="#避免使用线程的wait和notify"></a> 避免使用线程的wait()和notify()</h4><p>优先考虑使用线程的辅助工具类，宁可使用同步也不使用线程的wait()和notify()方法。因为线程间的通讯会消耗较多的系统资源。</p><h4 id="使用blockingqueue实现生产者-消费者模式"><a class="markdownIt-Anchor" href="#使用blockingqueue实现生产者-消费者模式"></a> 使用BlockingQueue实现生产者-消费者模式</h4><p>阻塞队列是生产者-消费者模式的最好的实现方式，不仅包括单个生产者单个消费者，还支持多个生产者多个消费者情况。</p><h4 id="优先使用并发集合"><a class="markdownIt-Anchor" href="#优先使用并发集合"></a> 优先使用并发集合</h4><p>JDK提供了ConcurrentHashMap、CopyOnWriteArrayList、CopyOnWriteArraySet、BlockingQueue中的Deque和BlockingDeque五大并发集合，他们有着较好性能；宁使用该并发集合，而避免使用synchronizedXXX的锁同步集合。</p><h4 id="使用semaphore创建有界的访问"><a class="markdownIt-Anchor" href="#使用semaphore创建有界的访问"></a> 使用Semaphore创建有界的访问</h4><p>为了建立可靠稳定的系统，对数据库、文件系统、SOCKET的访问需进行有界的控制。</p><h4 id="尽量减少同步方法使用"><a class="markdownIt-Anchor" href="#尽量减少同步方法使用"></a> 尽量减少同步方法使用</h4><ol><li>宁可使用同步代码块，也要尽量减少同步方法使用。</li><li>其中synchronized关键字标识方法时，所有调用到该方法的域都会被JVM进行锁定监督.</li><li>使用synchronized 同步代码块只会锁定一个对象，而不会将当前整个方法锁定；如果更改共同的变量或类的字段，优先选择原子性变量，其次使用volatile。如果你需要互斥锁，可以考虑使用ReentrantLock。</li></ol><h4 id="避免使用静态变量"><a class="markdownIt-Anchor" href="#避免使用静态变量"></a> 避免使用静态变量</h4><p>静态变量在多线程并发环境中会造成较多的问题。当使用静态变量时，优先将其指定为final变量，若用其来保存集合Collection变量，则考虑使用只读集合。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;使用本地变量&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#使用本地变量&quot;&gt;&lt;/a&gt; 使用本地变量&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;优先考虑使用本地变量，避免创建一个类或实例的变量；&lt;/li&gt;
&lt;li&gt;这样可以节省内存，并进行复用；&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;使用不可变类&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#使用不可变类&quot;&gt;&lt;/a&gt; 使用不可变类&lt;/h4&gt;
&lt;p&gt;降低代码中需要的同步变量，充分利用JVM提供的功能。&lt;/p&gt;
    
    </summary>
    
      <category term="Java之并发编程" scheme="http://suprisemf.github.io/categories/Java%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java" scheme="http://suprisemf.github.io/tags/Java/"/>
    
      <category term="并发编程" scheme="http://suprisemf.github.io/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>死锁</title>
    <link href="http://suprisemf.github.io/2018/08/03/%E6%AD%BB%E9%94%81/"/>
    <id>http://suprisemf.github.io/2018/08/03/死锁/</id>
    <published>2018-08-03T01:31:43.000Z</published>
    <updated>2018-08-03T01:34:05.535Z</updated>
    
    <content type="html"><![CDATA[<h4 id="死锁概述"><a class="markdownIt-Anchor" href="#死锁概述"></a> 死锁概述</h4><p>死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。</p><a id="more"></a><h4 id="死锁发生须具备的条件"><a class="markdownIt-Anchor" href="#死锁发生须具备的条件"></a> 死锁发生须具备的条件</h4><ol><li>互斥条件：进程间的锁具有排他性。</li><li>请求和保持条件：一个进程已经持有一个资源，但仍然提出对另一个资源的请求。</li><li>不剥夺条件：一个进程所持有的资源不能在自己使用完之前被系统剥夺，需自己释放。</li><li>环路等待条件：由于第2条件，多个进程间的请求形成环路。</li></ol><h4 id="演示例子"><a class="markdownIt-Anchor" href="#演示例子"></a> 演示例子</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLock</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//静态对象是类的所有对象共享的</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object o1 = <span class="keyword">new</span> Object(), o2 = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"flag:&#123;&#125;"</span>, flag);</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (o1) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (o2) &#123;</span><br><span class="line">                    log.info(<span class="string">"1"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (o2) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (o1) &#123;</span><br><span class="line">                    log.info(<span class="string">"0"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DeadLock td1 = <span class="keyword">new</span> DeadLock();</span><br><span class="line">        DeadLock td2 = <span class="keyword">new</span> DeadLock();</span><br><span class="line">        td1.flag = <span class="number">1</span>;</span><br><span class="line">        td2.flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">new</span> Thread(td1).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(td2).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="运行结果"><a class="markdownIt-Anchor" href="#运行结果"></a> 运行结果</h5><p><img src="/2018/08/03/死锁/%E6%AD%BB%E9%94%81/%E6%AD%BB%E9%94%81%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png" alt="图示"></p><p>其中出现了死锁，需要手动停止任务的执行，此时任务结束状态为：<code>Process finished with exit code -1</code></p><h5 id="例子说明"><a class="markdownIt-Anchor" href="#例子说明"></a> 例子说明</h5><blockquote><p>一个简单的死锁类：<br>当DeadLock类的对象<code>flag == 1</code>时（td1），先锁定o1,睡眠500毫秒<br>而td1在睡眠的时候另一个<code>flag == 0</code>的对象（td2）线程启动，先锁定o2,睡眠500毫秒<br>td1睡眠结束后需要锁定o2才能继续执行，而此时o2已被td2锁定；<br>td2睡眠结束后需要锁定o1才能继续执行，而此时o1已被td1锁定；<br>td1、td2相互等待，都需要得到对方锁定的资源才能继续执行，从而死锁。</p></blockquote><ol><li>构造了两个死锁实例；该实例实现了Runnable接口。</li><li>分别声明两个线程，分别在两个状态时请求另一个线程中的对象。</li><li>其中锁定线程休眠500毫秒：可以为另一个线程提供充足的时间来对该线程中的对象进行请求。</li><li>当在main函数中创建两个死锁实例td1,td2，并给定flag状态后：td1,td2都处于可执行状态，但JVM线程调度先执行哪个线程是不确定的。（对应于前后例子运行结果中flag-0或1的顺序）</li><li>死锁的实现：使用两层synchronized锁进行对象资源锁定，其中当两个线程分别获得第一层锁，在分别获取两一个线程的第二层锁时出现死锁。</li><li>当将类中的两个休眠时间<strong>都</strong>去掉后，出现正常的执行结束：</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">09<span class="selector-pseudo">:40</span><span class="selector-pseudo">:45.688</span> <span class="selector-attr">[Thread-1]</span> <span class="selector-tag">INFO</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.deadLock</span><span class="selector-class">.DeadLock</span> <span class="selector-tag">-</span> <span class="selector-tag">flag</span><span class="selector-pseudo">:0</span></span><br><span class="line">09<span class="selector-pseudo">:40</span><span class="selector-pseudo">:45.688</span> <span class="selector-attr">[Thread-0]</span> <span class="selector-tag">INFO</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.deadLock</span><span class="selector-class">.DeadLock</span> <span class="selector-tag">-</span> <span class="selector-tag">flag</span><span class="selector-pseudo">:1</span></span><br><span class="line">09<span class="selector-pseudo">:40</span><span class="selector-pseudo">:45.696</span> <span class="selector-attr">[Thread-1]</span> <span class="selector-tag">INFO</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.deadLock</span><span class="selector-class">.DeadLock</span> <span class="selector-tag">-</span> 0</span><br><span class="line">09<span class="selector-pseudo">:40</span><span class="selector-pseudo">:45.696</span> <span class="selector-attr">[Thread-0]</span> <span class="selector-tag">INFO</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.deadLock</span><span class="selector-class">.DeadLock</span> <span class="selector-tag">-</span> 1</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">Process</span> <span class="selector-tag">finished</span> <span class="selector-tag">with</span> <span class="selector-tag">exit</span> <span class="selector-tag">code</span> 0</span><br></pre></td></tr></table></figure><h4 id="死锁的避免策略"><a class="markdownIt-Anchor" href="#死锁的避免策略"></a> 死锁的避免策略</h4><ol><li>调整加锁顺序；避免交叉地对对象加锁，而应按序加锁。</li><li>加锁时限：将synchronized锁换成类似重入锁Reentrant具有锁定时间的锁机制。</li><li>死锁检测：是一种较好的死锁预防机制，但是实现较困难。</li></ol><blockquote><p>当为对象加锁不可避免地会出现交叉，且锁超时也不可行时，使用死锁检测机制。</p></blockquote><ul><li>每当一个线程获得了锁，会在线程和锁相关的数据结构中将其作为标记记下来；每当有其他线程请求该锁时也要记下相应标记；当一个线程请求锁失败时，该线程应根据锁之间的关系判断是否有死锁发生，并响应出对应的处理。</li></ul><h5 id="死锁发生时线程该做哪些事"><a class="markdownIt-Anchor" href="#死锁发生时线程该做哪些事"></a> 死锁发生时，线程该做哪些事？</h5><ol><li>当死锁发生时，释放所有的锁，并回退；并等待一个随机的时间后，进行重试（即回退等待）。但重试中仍有可能会发生死锁。</li><li>上述第一条，在重试中仍发生死锁，还可以提前为线程设定优先级：使回退等待中的一部分（非全部）释放锁并回退，其他的线程继续持有锁。</li><li>为了避免上述第二条中因线程拥有固定不变的优先级可能导致的线程饥饿等情况，应采取一定的策略，设置随机的（或其他更好的方式）线程优先级。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;死锁概述&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#死锁概述&quot;&gt;&lt;/a&gt; 死锁概述&lt;/h4&gt;
&lt;p&gt;死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。&lt;/p&gt;
    
    </summary>
    
      <category term="Java之并发编程" scheme="http://suprisemf.github.io/categories/Java%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java" scheme="http://suprisemf.github.io/tags/Java/"/>
    
      <category term="并发编程" scheme="http://suprisemf.github.io/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>线程池</title>
    <link href="http://suprisemf.github.io/2018/08/03/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>http://suprisemf.github.io/2018/08/03/线程池/</id>
    <published>2018-08-03T01:14:11.000Z</published>
    <updated>2018-08-03T01:29:35.788Z</updated>
    
    <content type="html"><![CDATA[<h3 id="thread类"><a class="markdownIt-Anchor" href="#thread类"></a> Thread类</h3><h4 id="new-thread的弊端"><a class="markdownIt-Anchor" href="#new-thread的弊端"></a> new Thread的弊端</h4><ol><li>每次new Thread新建对象，性能差。</li><li>线程缺乏统一的管理，可能无限制地新建线程，相互竞争，有可能占用更多的系统资源导致宕机或者OOM。</li><li>缺少更多高级功能，如：更多执行、定期执行，线程中断等。</li></ol><a id="more"></a><hr><h3 id="线程池"><a class="markdownIt-Anchor" href="#线程池"></a> 线程池</h3><h4 id="线程池的好处"><a class="markdownIt-Anchor" href="#线程池的好处"></a> 线程池的好处</h4><ol><li>重用存在的线程，减少对象的创建、销毁的开销，性能好。</li><li>可以有效地控制最大并发的线程数量，提高系统资源利用率，同时可以避免过多的资源竞争，避免阻塞。</li><li>提供定期执行、定时执行、单线程、并发控制等功能。</li></ol><h4 id="threadpoolexecutor"><a class="markdownIt-Anchor" href="#threadpoolexecutor"></a> ThreadPoolExecutor</h4><h5 id="初始化的参数"><a class="markdownIt-Anchor" href="#初始化的参数"></a> 初始化的参数</h5><ol><li>corePoolSize：核心线程数量；</li><li>maximumPoolSize：最大线程数量；</li><li>workQueue：阻塞队列，存储等待执行的任务，对线程池的运行过程有重大影响。</li><li>keepAliveTime：线程中无任务空转，但仍保持存活的延期时间。当目前线程池中的线程数量大于等于corePoolSize时才有效。</li><li>unit：是keepAliveTime的时间单位。</li><li>threadFactory：即用来创建线程的工厂。未指定则会使用默认的threadFactory来创建线程：线程优先级相同、非守护线程、默认递增的名字。</li><li>rejectedExecutionHandler：拒绝策略。</li></ol><blockquote><p>四种拒绝策略：</p><ol><li>ThreadPoolExecutor.AbortPolicy：默认策略，直接抛出异常。</li><li>ThreadPoolExecutor.CallerRunsPolicy：调用目前所在的线程来执行任务。</li><li>ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列中最早的一个线程中的任务，并执行当前的任务。</li><li>ThreadPoolExecutor.DiscardPolicy：直接丢弃该任务。</li></ol></blockquote><h5 id="初始化参数间的关系"><a class="markdownIt-Anchor" href="#初始化参数间的关系"></a> 初始化参数间的关系</h5><ol><li>当目前线程池中的线程数量小于corePoolSize时，且有新的线程创建请求时，直接创建新的线程。</li><li>当目前线程池中的线程数量大于等于corePoolSize，但小于maximumPoolSize时，若此时workQueue未满，则该任务会被放在workQueue中等待；若此时workQueue已经满了，则会为该任务直接创建新的线程。</li><li>当目前线程池中的线程数量大于maximumPoolSize时，如果workQueue未满则将线程请求将被放在阻塞队列workQueue中；如果workQueue已满，则会根据指定参数rejectHandler采用相应的拒绝策略，来处理线程请求。</li></ol><blockquote><p>workQueue是一个保存任务的阻塞队列。根据上面的三种情况，该workQueue对应的处理也有三种：</p><ol><li>直接切换：默认使用SynchronousQueue实现。</li><li>使用无界队列LinkedBlockingQueue，此时可以创建的最多线程数即是corePoolSize，maximumPoolSize则不会起作用了。</li><li>使用有界队列，常用ArrayBlockingQueue，可以指定队列的maximumPoolSize，但会使线程调度更加困难。因此推荐使用无界队列。</li></ol></blockquote><h4 id="threadpoolexecutor的状态"><a class="markdownIt-Anchor" href="#threadpoolexecutor的状态"></a> ThreadPoolExecutor的状态</h4><p><img src="/2018/08/03/线程池/%E7%BA%BF%E7%A8%8B%E6%B1%A0/threadpoolexecutor%E7%8A%B6%E6%80%81.png" alt="图示"></p><ol><li>RUNNING:运行中。可以接受新提交的任务，或处理阻塞队列中的任务。</li><li>SHUTDOWN:关闭。不能接受新提交的任务，但可以继续处理阻塞队列中的任务。</li><li>STOP:停止。既不能接受新提交的任务，但可以继续处理阻塞队列中的任务，并中断正在进行中的线程。</li><li>TIDYING:整理中。在SHUTDOWN时，当阻塞队列为空且线程池中工作的线程数量为0时，或在STOP时，线程池中工作的线程数量为0时，转为该状态，并整理线程池中的内容。此时等待线程池被终结。</li><li>TERMINATED:TIDYING时调用terminated()方法，进入TERMINATED。即线程池被销毁。</li></ol><h4 id="threadpoolexecutor的方法成员"><a class="markdownIt-Anchor" href="#threadpoolexecutor的方法成员"></a> ThreadPoolExecutor的方法成员</h4><p><img src="/2018/08/03/线程池/%E7%BA%BF%E7%A8%8B%E6%B1%A0/threadpoolexecutor%E6%96%B9%E6%B3%95.png" alt="图示"></p><ol><li>execute()：执行任务，由线程池运行。</li><li>submit()：提交任务，可以返回执行的结果。即execute()方法，配合Future的结合。</li><li>shutdown()：关闭线程池（不是立刻关闭）。不接受新提交的任务，但可以继续处理阻塞队列中的任务；当任务执行完毕才会关闭线程池。</li><li>shutdownNow()：立即关闭线程池。不接受新提交的任务，中断正在执行中的线程，丢弃阻塞队列中的任务。</li><li>getTaskCount()：返回线程池中已执行和未执行的任务总数。</li><li>getCompletedTaskCount()：返回已经执行完毕的任务数量。</li><li>getPoolSize()：返回目前线程池中的线程数量。（因存在线程间的动态切换，故返回值是近似值）</li><li>getActiveCount()：返回线程池中正在执行任务的线程数量。（因存在线程间的动态切换，故返回值是近似值）</li></ol><h4 id="threadpoolexecutor的类图"><a class="markdownIt-Anchor" href="#threadpoolexecutor的类图"></a> ThreadPoolExecutor的类图</h4><p><img src="/2018/08/03/线程池/%E7%BA%BF%E7%A8%8B%E6%B1%A0/%E7%B1%BB%E5%9B%BE%E5%85%B3%E7%B3%BB.png" alt="图示"></p><p>其中左上角部分：<br>Executor：一个运行线程任务的简单接口。<br>ExecutorService：拓展了Executor：添加了管理执行器生命周期、任务生命周期的方法。<br>ScheduledExecutorService：拓展了ExecutorService：支持Future和定期执行任务。</p><h4 id="executors类"><a class="markdownIt-Anchor" href="#executors类"></a> Executors类</h4><blockquote><p>该类是针对Executor接口提供的工厂方法和工具方法。</p></blockquote><p>Executors类内部方法：</p><p><img src="/2018/08/03/线程池/%E7%BA%BF%E7%A8%8B%E6%B1%A0/executors%E5%86%85%E9%83%A8%E6%96%B9%E6%B3%95.png" alt="图示"></p><ol><li>Executors的newCachedThreadPool()方法：创建一个容量大小可变的线程池：根据需要回收线程或新建线程。</li><li>Executors的newFixedThreadPool(int nThreads)方法，创建一个固定大小的线程池。若线程池已满则阻塞在workQueue中。</li><li>Executors的newScheduledThreadPool(int corePoolSize)方法，也是固定大小的线程池，但支持定时执行或周期执行任务。</li><li>Executors的newSingleThreadScheduledExecutor()方法：单线程的线程池，可以指定优先级或FIFO/LIFO。</li></ol><h4 id="看看源码"><a class="markdownIt-Anchor" href="#看看源码"></a> 看看源码</h4><p>newCachedThreadPool()：（有重载的指定threadfactory的方法）</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="keyword">new</span><span class="type">CachedThreadPool</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60</span>L, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="type">SynchronousQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>newFixedThreadPool(int nThreads)：（有重载的指定threadfactory的方法）</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="keyword">new</span><span class="type">FixedThreadPool</span>(int nThreads) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0</span>L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="type">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他的几个线程池的方法类似，都是调用ThreadPoolExecutor的构造函数。线程池返回的值都是ExecutorService实例。</p><h4 id="演示例子"><a class="markdownIt-Anchor" href="#演示例子"></a> 演示例子</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExample4</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ScheduledExecutorService executorService = Executors.newScheduledThreadPool(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        executorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                log.warn(<span class="string">"schedule run"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">1</span>, <span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">        Timer timer = <span class="keyword">new</span> Timer();</span><br><span class="line">        timer.schedule(<span class="keyword">new</span> TimerTask() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                log.warn(<span class="string">"timer run"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="keyword">new</span> Date(), <span class="number">5</span> * <span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="运行结果"><a class="markdownIt-Anchor" href="#运行结果"></a> 运行结果：</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">00<span class="selector-pseudo">:53</span><span class="selector-pseudo">:53.070</span> <span class="selector-attr">[Timer-0]</span> <span class="selector-tag">WARN</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.threadPool</span><span class="selector-class">.ThreadPoolExample4</span> <span class="selector-tag">-</span> <span class="selector-tag">timer</span> <span class="selector-tag">run</span></span><br><span class="line">00<span class="selector-pseudo">:53</span><span class="selector-pseudo">:54.066</span> <span class="selector-attr">[pool-1-thread-1]</span> <span class="selector-tag">WARN</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.threadPool</span><span class="selector-class">.ThreadPoolExample4</span> <span class="selector-tag">-</span> <span class="selector-tag">schedule</span> <span class="selector-tag">run</span></span><br><span class="line">00<span class="selector-pseudo">:53</span><span class="selector-pseudo">:57.068</span> <span class="selector-attr">[pool-1-thread-1]</span> <span class="selector-tag">WARN</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.threadPool</span><span class="selector-class">.ThreadPoolExample4</span> <span class="selector-tag">-</span> <span class="selector-tag">schedule</span> <span class="selector-tag">run</span></span><br><span class="line">00<span class="selector-pseudo">:53</span><span class="selector-pseudo">:58.067</span> <span class="selector-attr">[Timer-0]</span> <span class="selector-tag">WARN</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.threadPool</span><span class="selector-class">.ThreadPoolExample4</span> <span class="selector-tag">-</span> <span class="selector-tag">timer</span> <span class="selector-tag">run</span></span><br><span class="line">00<span class="selector-pseudo">:54</span><span class="selector-pseudo">:00.067</span> <span class="selector-attr">[pool-1-thread-1]</span> <span class="selector-tag">WARN</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.threadPool</span><span class="selector-class">.ThreadPoolExample4</span> <span class="selector-tag">-</span> <span class="selector-tag">schedule</span> <span class="selector-tag">run</span></span><br><span class="line">00<span class="selector-pseudo">:54</span><span class="selector-pseudo">:03.067</span> <span class="selector-attr">[pool-1-thread-1]</span> <span class="selector-tag">WARN</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.threadPool</span><span class="selector-class">.ThreadPoolExample4</span> <span class="selector-tag">-</span> <span class="selector-tag">schedule</span> <span class="selector-tag">run</span></span><br><span class="line">00<span class="selector-pseudo">:54</span><span class="selector-pseudo">:03.067</span> <span class="selector-attr">[Timer-0]</span> <span class="selector-tag">WARN</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.threadPool</span><span class="selector-class">.ThreadPoolExample4</span> <span class="selector-tag">-</span> <span class="selector-tag">timer</span> <span class="selector-tag">run</span></span><br><span class="line">00<span class="selector-pseudo">:54</span><span class="selector-pseudo">:06.068</span> <span class="selector-attr">[pool-1-thread-1]</span> <span class="selector-tag">WARN</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.threadPool</span><span class="selector-class">.ThreadPoolExample4</span> <span class="selector-tag">-</span> <span class="selector-tag">schedule</span> <span class="selector-tag">run</span></span><br></pre></td></tr></table></figure><h5 id="例子分析"><a class="markdownIt-Anchor" href="#例子分析"></a> 例子分析</h5><p>ExecutorService通过调用scheduleAtFixedRate方法，使该线程池配合定时器，以一个固定的频率调度执行。<br>例中定义了一个定时器Timer，在其调度方法schedule中新建TimerTask实例，并给出循环执行的时间间隔period，单位为毫秒。</p><h4 id="合理配置"><a class="markdownIt-Anchor" href="#合理配置"></a> 合理配置</h4><ol><li>当执行CPU密集型任务时，应尽量压榨使用CPU资源，参考设定线程数量为nCPU+1。</li><li>当执行IO密集型任务时，因其为输入输出两通路，线程数量参考设置为2*nCPU。</li><li>实际中，根据业务需要进行相应调整。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;thread类&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#thread类&quot;&gt;&lt;/a&gt; Thread类&lt;/h3&gt;
&lt;h4 id=&quot;new-thread的弊端&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#new-thread的弊端&quot;&gt;&lt;/a&gt; new Thread的弊端&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;每次new Thread新建对象，性能差。&lt;/li&gt;
&lt;li&gt;线程缺乏统一的管理，可能无限制地新建线程，相互竞争，有可能占用更多的系统资源导致宕机或者OOM。&lt;/li&gt;
&lt;li&gt;缺少更多高级功能，如：更多执行、定期执行，线程中断等。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Java之并发编程" scheme="http://suprisemf.github.io/categories/Java%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java" scheme="http://suprisemf.github.io/tags/Java/"/>
    
      <category term="并发编程" scheme="http://suprisemf.github.io/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>J.U.C之BlockingQueue</title>
    <link href="http://suprisemf.github.io/2018/08/03/J-U-C%E4%B9%8BBlockingQueue/"/>
    <id>http://suprisemf.github.io/2018/08/03/J-U-C之BlockingQueue/</id>
    <published>2018-08-03T01:05:49.000Z</published>
    <updated>2018-08-03T01:07:32.954Z</updated>
    
    <content type="html"><![CDATA[<h4 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h4><p>BlockingQueue见名知意，即阻塞队列。它是一个线程安全的队列。<br>大致有两种情况：</p><ol><li>队列满了，但此时还有入队操作；</li><li>队列空了，但此时还有出队操作。</li></ol><a id="more"></a><h4 id="场景分析"><a class="markdownIt-Anchor" href="#场景分析"></a> 场景分析</h4><p>主要应用在生产者-消费者场景。</p><ol><li>生产者生产对象，并放入阻塞队列，直至队列已满，被阻塞。</li><li>消费者消费对象，从阻塞队列中取，直至队列已空，被阻塞。</li></ol><h4 id="队列操作方法"><a class="markdownIt-Anchor" href="#队列操作方法"></a> 队列操作方法</h4><p>一共有四套方法。</p><p><img src="/2018/08/03/J-U-C之BlockingQueue/J-U-C%E4%B9%8BBlockingQueue/blockingqueue.png" alt="图示"></p><h5 id="第一套方法throws-exception"><a class="markdownIt-Anchor" href="#第一套方法throws-exception"></a> 第一套方法：Throws Exception</h5><p>如果操作不能马上执行就会抛出异常。</p><table><thead><tr><th>type</th><th>method</th></tr></thead><tbody><tr><td>Insert</td><td>add(o)</td></tr><tr><td>Remove</td><td>remove(o)</td></tr><tr><td>Examine</td><td>element()</td></tr></tbody></table><h5 id="第二套方法special-value"><a class="markdownIt-Anchor" href="#第二套方法special-value"></a> 第二套方法：Special Value</h5><p>如果操作不能马上执行就会返回一个特殊值。一般是true/false</p><table><thead><tr><th>type</th><th>method</th></tr></thead><tbody><tr><td>Insert</td><td>offer(o)</td></tr><tr><td>Remove</td><td>poll()</td></tr><tr><td>Examine</td><td>peek()</td></tr></tbody></table><h5 id="第三套方法blocks"><a class="markdownIt-Anchor" href="#第三套方法blocks"></a> 第三套方法：Blocks</h5><p>如果操作不能马上执行就会进行阻塞操作。</p><table><thead><tr><th>type</th><th>method</th></tr></thead><tbody><tr><td>Insert</td><td>put()</td></tr><tr><td>Remove</td><td>take()</td></tr><tr><td>Examine</td><td>无</td></tr></tbody></table><h5 id="第四套方法times-out"><a class="markdownIt-Anchor" href="#第四套方法times-out"></a> 第四套方法：Times Out</h5><p>如果操作不能马上执行就会给定一个超时时间。如果超时时间已经过期还未执行就会返回一个特殊值。一般是true/false</p><table><thead><tr><th>type</th><th>method</th></tr></thead><tbody><tr><td>Insert</td><td>offer(o，timeout，timeunit)</td></tr><tr><td>Remove</td><td>poll(timeout，timeunit)</td></tr><tr><td>Examine</td><td>无</td></tr></tbody></table><h4 id="事件类"><a class="markdownIt-Anchor" href="#事件类"></a> 事件类</h4><h5 id="arrayblockingqueue"><a class="markdownIt-Anchor" href="#arrayblockingqueue"></a> ArrayBlockingQueue</h5><ol><li>是一个有界的（容量有限,初始化时指定容量，之后不得更改）阻塞队列。</li><li>其内部实现为数组。</li><li>是以FIFO的方式存放数据。</li></ol><h5 id="delayqueue"><a class="markdownIt-Anchor" href="#delayqueue"></a> DelayQueue</h5><ol><li>阻塞的对象是队列的内部元素。</li><li>其内部元素必须实现J.U.C中Delayed接口。Delayed接口继承了Comparable接口。说明DelayQueue中的元素需要排序。一般按照元素过期时间的优先级排序。</li><li>底层实现是：PriorityQueue和Lock。</li><li>使用场景广泛：连接的定时关闭、缓存对象、超时处理等。</li></ol><h5 id="linkedblockingqueue"><a class="markdownIt-Anchor" href="#linkedblockingqueue"></a> LinkedBlockingQueue</h5><ol><li>是BlockingQueue的一种链接版本。</li><li>见名知意，因为使用链接，故而若初始化时指定容量则是有界队列，否则默认队列的长度可变。</li><li>使用链接，故底层实现是链表。</li><li>是以FIFO的方式存放数据。</li></ol><h5 id="priorityblockingqueue"><a class="markdownIt-Anchor" href="#priorityblockingqueue"></a> PriorityBlockingQueue</h5><ol><li>见名知意，它是BlockingQueue的附加优先级的队列。</li><li>是一个无边界的队列，但有排序规则。</li><li>队列允许插入的元素为空（null）。</li><li>其内部元素必须实现Comparable接口。</li><li>队列中优先级的排序规则：通过自定义地对Comparable接口的实现来指定规则。</li><li>可以从PriorityBlockingQueue中获得一个迭代器（iterator），但并不保证按照队列中元素的优先级进行迭代。</li></ol><h5 id="synchronousqueue"><a class="markdownIt-Anchor" href="#synchronousqueue"></a> SynchronousQueue</h5><ol><li>见名知意，即为“同步队列”。</li><li>队列内部仅允许容纳一个元素，即放入一个元素后只等待其被取走。</li><li>是一个无界非缓存队列。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;概述&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#概述&quot;&gt;&lt;/a&gt; 概述&lt;/h4&gt;
&lt;p&gt;BlockingQueue见名知意，即阻塞队列。它是一个线程安全的队列。&lt;br&gt;
大致有两种情况：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;队列满了，但此时还有入队操作；&lt;/li&gt;
&lt;li&gt;队列空了，但此时还有出队操作。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Java之并发编程" scheme="http://suprisemf.github.io/categories/Java%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java" scheme="http://suprisemf.github.io/tags/Java/"/>
    
      <category term="并发编程" scheme="http://suprisemf.github.io/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>J.U.C之ForkJoin</title>
    <link href="http://suprisemf.github.io/2018/08/03/J-U-C%E4%B9%8BForkJoin/"/>
    <id>http://suprisemf.github.io/2018/08/03/J-U-C之ForkJoin/</id>
    <published>2018-08-03T01:02:20.000Z</published>
    <updated>2018-08-03T01:03:25.311Z</updated>
    
    <content type="html"><![CDATA[<h4 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h4><p>ForkJoin框架是JDK 1.7提供的一种用于并行任务执行的框架。有些像Hadoop中的MapReduce机制。即将一个大任务分为（fork）多个小任务分别执行，最后将多个小任务的执行结果进行汇总（join）。</p><a id="more"></a><blockquote><p>该框架采用的工作窃取算法，即<strong>当一个线程执行完它的任务后，可以从其他线程的任务队列尾部开始自行窃取任务进行执行，最后与该队列的另一个线程接头</strong>，以充分发挥该框架的优势（消除线程等待），提高效率，促进性能提升。<br>其中，每个线程的任务队列采用双端队列进行实现。<br>缺点：1. 当一个线程的双端队列中只有一个任务时，也会发生线程竞争。2. 由于使用双端队列，系统会分配更多的资源。</p></blockquote><h4 id="执行任务的局限性"><a class="markdownIt-Anchor" href="#执行任务的局限性"></a> 执行任务的局限性</h4><ol><li>任务只能使用Fork或Join作为同步机制；</li><li>线程队列中的任务不可以有IO操作；</li><li>任务不能抛出检查异常。（若有则需要必要的代码进行处理）</li></ol><h4 id="forkjoinpool"><a class="markdownIt-Anchor" href="#forkjoinpool"></a> ForkJoinPool</h4><p>看一下注释：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * An &#123;@link ExecutorService&#125; <span class="keyword">for</span> <span class="built_in">running</span> &#123;@link ForkJoinTask&#125;s.</span><br><span class="line"> * A &#123;@code ForkJoinPool&#125; provides <span class="keyword">the</span> entry point <span class="keyword">for</span> submissions</span><br><span class="line"> * <span class="keyword">from</span> non-&#123;@code ForkJoinTask&#125; clients, <span class="keyword">as</span> well <span class="keyword">as</span> management <span class="keyword">and</span></span><br><span class="line"> * monitoring operations.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;A &#123;@code ForkJoinPool&#125; differs <span class="keyword">from</span> other kinds <span class="keyword">of</span> &#123;@link</span><br><span class="line"> * ExecutorService&#125; mainly <span class="keyword">by</span> virtue <span class="keyword">of</span> employing</span><br><span class="line"> * &lt;em&gt;work-stealing&lt;/em&gt;: all threads <span class="keyword">in</span> <span class="keyword">the</span> pool attempt <span class="keyword">to</span> find <span class="keyword">and</span></span><br><span class="line"> * execute tasks submitted <span class="keyword">to</span> <span class="keyword">the</span> pool <span class="keyword">and</span>/<span class="keyword">or</span> created <span class="keyword">by</span> other active</span><br><span class="line"> * tasks (eventually blocking waiting <span class="keyword">for</span> work <span class="keyword">if</span> none exist). This</span><br><span class="line"> * enables efficient processing when most tasks spawn other subtasks</span><br><span class="line"> * (<span class="keyword">as</span> do most &#123;@code ForkJoinTask&#125;s), <span class="keyword">as</span> well <span class="keyword">as</span> when many small</span><br><span class="line"> * tasks are submitted <span class="keyword">to</span> <span class="keyword">the</span> pool <span class="keyword">from</span> external clients.  Especially</span><br><span class="line"> * when setting &lt;em&gt;asyncMode&lt;/em&gt; <span class="keyword">to</span> <span class="literal">true</span> <span class="keyword">in</span> constructors, &#123;@code</span><br><span class="line"> * ForkJoinPool&#125;s may also be appropriate <span class="keyword">for</span> use <span class="keyword">with</span> event-style</span><br><span class="line"> * tasks <span class="keyword">that</span> are never joined.</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><p>实质上，ForkJoinPool是一个从非ForkJoinTask的请求中，为运行中的ForkJoinTask的子任务提供切入点的ExecutorService。它不同于其他的ExecutorService，主要是它虚拟部署了任务窃取。尤其当在构造器中设置asyncMode为true时，ForkJoinPool也可能适当地使用事件模式的任务（从未被汇总过？？）。<br><strong>ForkJoinPool主要做实现：包括工作窃取算法、工作线程的管理、任务的状态管理、任务的执行信息等。</strong></p><h4 id="forkjointask"><a class="markdownIt-Anchor" href="#forkjointask"></a> ForkJoinTask</h4><p>看下注释：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Abstract base <span class="built_in">class</span> <span class="keyword">for</span> tasks <span class="keyword">that</span> <span class="built_in">run</span> within a &#123;@link ForkJoinPool&#125;.</span><br><span class="line"> * A &#123;@code ForkJoinTask&#125; <span class="keyword">is</span> a thread-like entity <span class="keyword">that</span> <span class="keyword">is</span> much</span><br><span class="line"> * lighter weight than a normal thread.  Huge numbers <span class="keyword">of</span> tasks <span class="keyword">and</span></span><br><span class="line"> * subtasks may be hosted <span class="keyword">by</span> a small <span class="built_in">number</span> <span class="keyword">of</span> actual threads <span class="keyword">in</span> a</span><br><span class="line"> * ForkJoinPool, <span class="keyword">at</span> <span class="keyword">the</span> price <span class="keyword">of</span> <span class="keyword">some</span> usage limitations.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;A <span class="string">"main"</span> &#123;@code ForkJoinTask&#125; begins execution when <span class="keyword">it</span> <span class="keyword">is</span></span><br><span class="line"> * explicitly submitted <span class="keyword">to</span> a &#123;@link ForkJoinPool&#125;, <span class="keyword">or</span>, <span class="keyword">if</span> <span class="keyword">not</span> already</span><br><span class="line"> * engaged <span class="keyword">in</span> a ForkJoin computation, commenced <span class="keyword">in</span> <span class="keyword">the</span> &#123;@link</span><br><span class="line"> * ForkJoinPool<span class="comment">#commonPool()&#125; via &#123;@link #fork&#125;, &#123;@link #invoke&#125;, or</span></span><br><span class="line"> * related methods.  Once started, <span class="keyword">it</span> will usually <span class="keyword">in</span> turn start other</span><br><span class="line"> * subtasks.  As indicated <span class="keyword">by</span> <span class="keyword">the</span> <span class="built_in">name</span> <span class="keyword">of</span> this <span class="built_in">class</span>, many programs</span><br><span class="line"> * using &#123;@code ForkJoinTask&#125; employ only methods &#123;@link <span class="comment">#fork&#125; and</span></span><br><span class="line"> * &#123;@link <span class="comment">#join&#125;, or derivatives such as &#123;@link</span></span><br><span class="line"> * <span class="comment">#invokeAll(ForkJoinTask...) invokeAll&#125;.  However, this class also</span></span><br><span class="line"> * provides a <span class="built_in">number</span> <span class="keyword">of</span> other methods <span class="keyword">that</span> can come <span class="keyword">into</span> play <span class="keyword">in</span></span><br><span class="line"> * advanced usages, <span class="keyword">as</span> well <span class="keyword">as</span> extension mechanics <span class="keyword">that</span> allow support</span><br><span class="line"> * <span class="keyword">of</span> new forms <span class="keyword">of</span> fork/join processing.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;A &#123;@code ForkJoinTask&#125; <span class="keyword">is</span> a lightweight form <span class="keyword">of</span> &#123;@link Future&#125;.</span><br><span class="line"> * The efficiency <span class="keyword">of</span> &#123;@code ForkJoinTask&#125;s stems <span class="keyword">from</span> a <span class="keyword">set</span> <span class="keyword">of</span></span><br><span class="line"> * restrictions (<span class="keyword">that</span> are only partially statically enforceable)</span><br><span class="line"> * reflecting their main use <span class="keyword">as</span> computational tasks calculating pure</span><br><span class="line"> * functions <span class="keyword">or</span> operating <span class="keyword">on</span> purely isolated objects.  The primary</span><br><span class="line"> * coordination mechanisms are &#123;@link <span class="comment">#fork&#125;, that arranges</span></span><br><span class="line"> * asynchronous execution, <span class="keyword">and</span> &#123;@link <span class="comment">#join&#125;, that doesn't proceed</span></span><br><span class="line"> * <span class="keyword">until</span> <span class="keyword">the</span> task's <span class="literal">result</span> has been computed.  Computations should</span><br><span class="line"> * ideally avoid &#123;@code synchronized&#125; methods <span class="keyword">or</span> blocks, <span class="keyword">and</span> should</span><br><span class="line"> * minimize other blocking synchronization <span class="keyword">apart from</span> joining other</span><br><span class="line"> * tasks <span class="keyword">or</span> using synchronizers such <span class="keyword">as</span> Phasers <span class="keyword">that</span> are advertised <span class="keyword">to</span></span><br><span class="line"> * cooperate <span class="keyword">with</span> fork/join scheduling.</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><p><strong>ForkJoinTask：主要提供任务中fork/join的机制。</strong></p><blockquote><p>我：大家自己意会一下，但可千万不要言传哦~ 真的很容易看懂的~<br>读者：emmmmm，是挺容易的，因为它容易就容易在它容易它奶奶的腿……</p></blockquote><h4 id="演示例子"><a class="markdownIt-Anchor" href="#演示例子"></a> 演示例子</h4><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line"><span class="keyword">public</span> class ForkJoinTaskExample extends RecursiveTask&lt;Integer&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> final <span class="keyword">int</span> threshold = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> start;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> <span class="built_in">end</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ForkJoinTaskExample(<span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.start = start;</span><br><span class="line">        <span class="keyword">this</span>.<span class="built_in">end</span> = <span class="built_in">end</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="keyword">protected</span> Integer compute() &#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果任务足够小就计算任务</span></span><br><span class="line">        <span class="keyword">boolean</span> canCompute = (<span class="built_in">end</span> - start) &lt;= threshold;</span><br><span class="line">        <span class="built_in">if</span> (canCompute) &#123;</span><br><span class="line">            <span class="built_in">for</span> (<span class="keyword">int</span> i = start; i &lt;= <span class="built_in">end</span>; i++) &#123;</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="built_in">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果任务大于阈值，就分裂成两个子任务计算</span></span><br><span class="line">            <span class="keyword">int</span> middle = (start + <span class="built_in">end</span>) / <span class="number">2</span>;</span><br><span class="line">            ForkJoinTaskExample leftTask = <span class="keyword">new</span> ForkJoinTaskExample(start, middle);</span><br><span class="line">            ForkJoinTaskExample rightTask = <span class="keyword">new</span> ForkJoinTaskExample(middle + <span class="number">1</span>, <span class="built_in">end</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 执行子任务</span></span><br><span class="line">            leftTask.fork();</span><br><span class="line">            rightTask.fork();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 等待任务执行结束合并其结果</span></span><br><span class="line">            <span class="keyword">int</span> leftResult = leftTask.join();</span><br><span class="line">            <span class="keyword">int</span> rightResult = rightTask.join();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 合并子任务</span></span><br><span class="line">            sum = leftResult + rightResult;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line">        ForkJoinPool forkjoinPool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//生成一个计算任务，计算1+2+3+4</span></span><br><span class="line">        ForkJoinTaskExample task = <span class="keyword">new</span> ForkJoinTaskExample(<span class="number">1</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//执行一个任务</span></span><br><span class="line">        Future&lt;Integer&gt; result = forkjoinPool.submit(task);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">try</span> &#123;</span><br><span class="line">            log.info(<span class="string">"result:&#123;&#125;"</span>, result.<span class="built_in">get</span>());</span><br><span class="line">        &#125; <span class="built_in">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">"exception"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="运行结果"><a class="markdownIt-Anchor" href="#运行结果"></a> 运行结果：</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">14<span class="selector-pseudo">:58</span><span class="selector-pseudo">:35.442</span> <span class="selector-attr">[main]</span> <span class="selector-tag">INFO</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.aqs</span><span class="selector-class">.ForkJoinTaskExample</span> <span class="selector-tag">-</span> <span class="selector-tag">result</span><span class="selector-pseudo">:5050</span></span><br></pre></td></tr></table></figure><h5 id="例子分析"><a class="markdownIt-Anchor" href="#例子分析"></a> 例子分析</h5><ol><li>该测试类需要继承<code>RecursiveTask</code>类，即在任务<code>fork</code>中需要递归地拆分任务;</li><li><code>ForkJoinTaskExample task = new ForkJoinTaskExample(1, 100);</code>指定<code>start</code>和<code>end</code>，其构造函数完成其任务的<code>fork</code>的具体实现，之后再将其子结果<code>join</code>并返回。</li><li>最后通过ForkJoinPool调用submit()执行该任务。</li><li>其中：在任务拆分（fork）中，声明了一个threshold（阈值），即指定任务不可拆分的界限。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;概述&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#概述&quot;&gt;&lt;/a&gt; 概述&lt;/h4&gt;
&lt;p&gt;ForkJoin框架是JDK 1.7提供的一种用于并行任务执行的框架。有些像Hadoop中的MapReduce机制。即将一个大任务分为（fork）多个小任务分别执行，最后将多个小任务的执行结果进行汇总（join）。&lt;/p&gt;
    
    </summary>
    
      <category term="Java之并发编程" scheme="http://suprisemf.github.io/categories/Java%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java" scheme="http://suprisemf.github.io/tags/Java/"/>
    
      <category term="并发编程" scheme="http://suprisemf.github.io/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>J.U.C之FutureTask</title>
    <link href="http://suprisemf.github.io/2018/08/03/J-U-C%E4%B9%8BFutureTask/"/>
    <id>http://suprisemf.github.io/2018/08/03/J-U-C之FutureTask/</id>
    <published>2018-08-03T00:55:46.000Z</published>
    <updated>2018-08-03T00:56:46.976Z</updated>
    
    <content type="html"><![CDATA[<h4 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h4><blockquote><p>由于线程是实现了Runnable接口或继承了Thread类，其执行后无法回调其线程的执行结果，因此JDK 1.5提供了一些新机制：接口Callable和Future。通过他们可以得到线程的执行结果。</p></blockquote><a id="more"></a><p>FutureTask间接实现了Future接口，并提供了一个基础的实现：开始/取消一个计算的方法，计算结果的查询。FutureTask可以被用来去包装一个Callable或Runnable对象，并可以被提交给Executor执行器去执行。除了被用作一个独立的服务类，它还提供了protected的功能，在定制任务类时会十分有用。（好吧，被你发现了，这是我翻译的源码中的类注释，哭唧唧~）</p><h4 id="runnable与callable对比"><a class="markdownIt-Anchor" href="#runnable与callable对比"></a> Runnable与Callable对比</h4><ol><li>Runnable接口只有一个run()方法；</li><li>Callable是一个泛型接口，其中也只有V call()函数，其返回类型即传入的参数泛型。</li><li>两个接口功能相似，但后者因可以返回执行信息且支持泛型而更强大一些。</li></ol><h4 id="future接口"><a class="markdownIt-Anchor" href="#future接口"></a> Future接口</h4><p>通过实现该类可以得到一个<strong>异步计算</strong>的返回结果。并提供方法接口：检查是否计算完成、等待计算的完成、取回计算的结果、判断计算是否在完成前被正常地取消。</p><h4 id="futuretask类"><a class="markdownIt-Anchor" href="#futuretask类"></a> FutureTask类</h4><p>它实现了RunnableFuture接口，而RunnableFuture接口同时继承了Runnable接口和Future接口。即FutureTask类最终也是执行的Callable的方法。组合Runnable和Future的好处：可以另起线程去专门检查并调取最终计算的结果，而其他的线程可以继续其他任务（只需监听该跑腿线程即可）。</p><h4 id="演示例子-callable和future结合"><a class="markdownIt-Anchor" href="#演示例子-callable和future结合"></a> 演示例子-Callable和Future结合</h4><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCallable</span> <span class="keyword"><span class="keyword">implements</span> <span class="type">Callable</span></span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">String</span> call() throws Exception &#123;</span><br><span class="line">            log.info(<span class="string">"do something in callable"</span>);</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Done"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="keyword">String</span>[] args) throws Exception &#123;</span><br><span class="line">        ExecutorService executorService = Executors.<span class="keyword">new</span><span class="type">CachedThreadPool</span>();</span><br><span class="line">        Future&lt;<span class="keyword">String</span>&gt; future = executorService.submit(<span class="keyword">new</span> <span class="type">MyCallable</span>());</span><br><span class="line">        log.info(<span class="string">"do something in main"</span>);</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">String</span> result = future.<span class="keyword">get</span>();</span><br><span class="line">        log.info(<span class="string">"result：&#123;&#125;"</span>, result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="运行结果"><a class="markdownIt-Anchor" href="#运行结果"></a> 运行结果</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">11<span class="selector-pseudo">:29</span><span class="selector-pseudo">:00.230</span> <span class="selector-attr">[main]</span> <span class="selector-tag">INFO</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.aqs</span><span class="selector-class">.FutureExample</span> <span class="selector-tag">-</span> <span class="selector-tag">do</span> <span class="selector-tag">something</span> <span class="selector-tag">in</span> <span class="selector-tag">main</span></span><br><span class="line">11<span class="selector-pseudo">:29</span><span class="selector-pseudo">:00.230</span> <span class="selector-attr">[pool-1-thread-1]</span> <span class="selector-tag">INFO</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.aqs</span><span class="selector-class">.FutureExample</span> <span class="selector-tag">-</span> <span class="selector-tag">do</span> <span class="selector-tag">something</span> <span class="selector-tag">in</span> <span class="selector-tag">callable</span></span><br><span class="line">11<span class="selector-pseudo">:29</span><span class="selector-pseudo">:05.234</span> <span class="selector-attr">[main]</span> <span class="selector-tag">INFO</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.aqs</span><span class="selector-class">.FutureExample</span> <span class="selector-tag">-</span> <span class="selector-tag">result</span>：<span class="selector-tag">Done</span></span><br></pre></td></tr></table></figure><h5 id="例子分析"><a class="markdownIt-Anchor" href="#例子分析"></a> 例子分析</h5><ol><li>结合Callable和Future两者。</li><li>实现的Callable类可以被Executors的submit(xxx)提交给线程池运行。（之前提到过）</li><li>通过Future的get()查询并取回执行结果；若未执行结束则阻塞查询。（前面有说到）</li></ol><h4 id="演示例子-futuretask"><a class="markdownIt-Anchor" href="#演示例子-futuretask"></a> 演示例子-FutureTask</h4><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line"><span class="keyword">public</span> class FutureTaskExample &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        FutureTask&lt;<span class="keyword">String</span>&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;<span class="keyword">String</span>&gt;(<span class="keyword">new</span> Callable&lt;<span class="keyword">String</span>&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">String</span> call() <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                <span class="built_in">log</span>.info(<span class="string">"do something in callable"</span>);</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"Done"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(futureTask).start();</span><br><span class="line">        <span class="built_in">log</span>.info(<span class="string">"do something in main"</span>);</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">String</span> result = futureTask.<span class="built_in">get</span>();</span><br><span class="line">        <span class="built_in">log</span>.info(<span class="string">"result：&#123;&#125;"</span>, result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="运行结果-2"><a class="markdownIt-Anchor" href="#运行结果-2"></a> 运行结果</h5><p>与上个例子结果一模一样，运行速度快了25%左右：Callable和Future结合使用耗时2s 450ms，FutureTask耗时1s 890ms。</p><h4 id="看下源码"><a class="markdownIt-Anchor" href="#看下源码"></a> 看下源码</h4><p>get()方法的内核：返回执行完成的结果或抛出异常。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns result or throws exception for completed task.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> s completed state value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="keyword">private</span> <span class="function">V <span class="title">report</span><span class="params">(<span class="keyword">int</span> s)</span> <span class="keyword">throws</span> ExecutionException </span>&#123;</span><br><span class="line">    Object x = outcome;</span><br><span class="line">    <span class="keyword">if</span> (s == NORMAL)</span><br><span class="line">        <span class="keyword">return</span> (V)x;</span><br><span class="line">    <span class="keyword">if</span> (s &gt;= CANCELLED)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> CancellationException();</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ExecutionException((Throwable)x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一个可以指定返回执行结果的构造函数：（内部都是调用Executors的callable方法）</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> FutureTask(Runnable runnable, V result) &#123;</span><br><span class="line">    <span class="keyword">this</span>.callable = Executors.callable(runnable, result);</span><br><span class="line">    <span class="keyword">this</span>.state = <span class="keyword">NEW</span>;       <span class="comment">// ensure visibility of callable</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Callable&lt;T&gt; callable(Runnable <span class="keyword">task</span>, T result) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">task</span> == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RunnableAdapter&lt;T&gt;(<span class="keyword">task</span>, result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> RunnableAdapter&lt;T&gt; <span class="keyword">implements</span> Callable&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">final</span> Runnable <span class="keyword">task</span>;</span><br><span class="line">    <span class="keyword">final</span> T result;</span><br><span class="line">    RunnableAdapter(Runnable <span class="keyword">task</span>, T result) &#123;</span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">task</span> = <span class="keyword">task</span>;</span><br><span class="line">        <span class="keyword">this</span>.result = result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="keyword">call</span>() &#123;</span><br><span class="line">        <span class="keyword">task</span>.run();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一个指定超时时间的get():</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V get(<span class="keyword">long</span> timeout, TimeUnit unit)</span><br><span class="line">    <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException &#123;</span><br><span class="line">    <span class="keyword">if</span> (unit == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> s = state;</span><br><span class="line">    <span class="keyword">if</span> (s &lt;= COMPLETING &amp;&amp;</span><br><span class="line">        (s = awaitDone(<span class="keyword">true</span>, unit.toNanos(timeout))) &lt;= COMPLETING)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();</span><br><span class="line">    <span class="function"><span class="keyword">return</span> <span class="title">report</span><span class="params">(s)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当计算失败时（不包括计算被取消）被内部的run()调用:报告其中的异常</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">protected void <span class="built_in">set</span>Exception(Throwable t) &#123;</span><br><span class="line">    if (UNSAFE.compareAndSwapInt(this, <span class="keyword">state</span>Offset, NEW, COMPLETING)) &#123;</span><br><span class="line">        outcome = t;</span><br><span class="line">        UNSAFE.putOrderedInt(this, <span class="keyword">state</span>Offset, EXCEPTIONAL); // final <span class="keyword">state</span></span><br><span class="line">        finishCompletion();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一旦计算完成，该计算就不能被重启或取消了，除非调用runAndReset()方法：（之前概述提到）</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">protected boolean runAndReset() &#123;</span><br><span class="line">    if (<span class="keyword">state</span> != NEW ||</span><br><span class="line">        !UNSAFE.compareAndSwapObject(this, runnerOffset,</span><br><span class="line">                                     null, Thread.currentThread()))</span><br><span class="line">        return false;</span><br><span class="line">    boolean ran = false;</span><br><span class="line">    int s = <span class="keyword">state</span>;</span><br><span class="line">    try &#123;</span><br><span class="line">        Callable<span class="variable">&lt;V&gt;</span> c = callable;</span><br><span class="line">        if (c != null &amp;&amp; s == NEW) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                c.call(); // don't <span class="built_in">set</span> result</span><br><span class="line">                ran = true;</span><br><span class="line">            &#125; catch (Throwable ex) &#123;</span><br><span class="line">                <span class="built_in">set</span>Exception(ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        // runner must be non-null until <span class="keyword">state</span> is settled <span class="keyword">to</span></span><br><span class="line">        // prevent concurrent calls <span class="keyword">to</span> run()</span><br><span class="line">        runner = null;</span><br><span class="line">        // <span class="keyword">state</span> must be re-read after nulling runner <span class="keyword">to</span> prevent</span><br><span class="line">        // leaked interrupts</span><br><span class="line">        s = <span class="keyword">state</span>;</span><br><span class="line">        if (s &gt;= INTERRUPTING)</span><br><span class="line">            handlePossibleCancellationInterrupt(s);</span><br><span class="line">    &#125;</span><br><span class="line">    return ran &amp;&amp; s == NEW;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;概述&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#概述&quot;&gt;&lt;/a&gt; 概述&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;由于线程是实现了Runnable接口或继承了Thread类，其执行后无法回调其线程的执行结果，因此JDK 1.5提供了一些新机制：接口Callable和Future。通过他们可以得到线程的执行结果。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Java之并发编程" scheme="http://suprisemf.github.io/categories/Java%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java" scheme="http://suprisemf.github.io/tags/Java/"/>
    
      <category term="并发编程" scheme="http://suprisemf.github.io/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>J.U.C之AQS—RentrantLock-Part-2</title>
    <link href="http://suprisemf.github.io/2018/08/03/JJ-U-C%E4%B9%8BAQS%E2%80%94RentrantLock-part-2/"/>
    <id>http://suprisemf.github.io/2018/08/03/JJ-U-C之AQS—RentrantLock-part-2/</id>
    <published>2018-08-03T00:50:26.000Z</published>
    <updated>2018-08-03T00:52:39.989Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这部分还是接着上部分的源码学习。</p></blockquote><a id="more"></a><h4 id="源码学习"><a class="markdownIt-Anchor" href="#源码学习"></a> 源码学习</h4><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Sync object for non-fair locks</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">7316153563782823691</span>L;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Performs lock.  Try immediate barge, backing up to normal</span></span><br><span class="line"><span class="comment">     * acquire on failure.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="function"><span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">return</span> <span class="title">nonfairTryAcquire</span><span class="params">(acquires)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Atomically sets synchronization state to the given updated</span></span><br><span class="line"><span class="comment"> * value if the current state value equals the expected value.</span></span><br><span class="line"><span class="comment"> * This operation has memory semantics of a &#123;<span class="doctag">@code</span> volatile&#125; read</span></span><br><span class="line"><span class="comment"> * and write.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> expect the expected value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> update the new value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if successful. False return indicates that the actual</span></span><br><span class="line"><span class="comment"> *         value was not equal to the expected value.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="function"><span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// See below for intrinsics setup to support this</span></span><br><span class="line">    <span class="function"><span class="keyword">return</span> unsafe.<span class="title">compareAndSwapInt</span><span class="params">(<span class="keyword">this</span>, stateOffset, expect, update)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Sets the thread that currently owns exclusive access.</span></span><br><span class="line"><span class="comment"> * A &#123;<span class="doctag">@code</span> null&#125; argument indicates that no thread owns access.</span></span><br><span class="line"><span class="comment"> * This method does not otherwise impose any synchronization or</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> volatile&#125; field accesses.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> thread the owner thread</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="function"><span class="keyword">void</span> <span class="title">setExclusiveOwnerThread</span><span class="params">(Thread thread)</span> </span>&#123;</span><br><span class="line">    exclusiveOwnerThread = thread;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Acquires in exclusive mode, ignoring interrupts.  Implemented</span></span><br><span class="line"><span class="comment"> * by invoking at least once &#123;<span class="doctag">@link</span> #tryAcquire&#125;,</span></span><br><span class="line"><span class="comment"> * returning on success.  Otherwise the thread is queued, possibly</span></span><br><span class="line"><span class="comment"> * repeatedly blocking and unblocking, invoking &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment"> * #tryAcquire&#125; until success.  This method can be used</span></span><br><span class="line"><span class="comment"> * to implement method &#123;<span class="doctag">@link</span> Lock#lock&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arg the acquire argument.  This value is conveyed to</span></span><br><span class="line"><span class="comment"> *        &#123;<span class="doctag">@link</span> #tryAcquire&#125; but is otherwise uninterpreted and</span></span><br><span class="line"><span class="comment"> *        can represent anything you like.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="function"><span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="function"><span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Convenience method to interrupt current thread.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">selfInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread.currentThread().interrupt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">interrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> != Thread.currentThread())</span><br><span class="line">        checkAccess();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (blockerLock) &#123;</span><br><span class="line">        Interruptible b = blocker;</span><br><span class="line">        <span class="keyword">if</span> (b != <span class="keyword">null</span>) &#123;</span><br><span class="line">            interrupt0();           <span class="comment">// Just to set the interrupt flag</span></span><br><span class="line">            b.interrupt(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    interrupt0();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="function"><span class="keyword">void</span> <span class="title">interrupt0</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h4 id="配合的condition"><a class="markdownIt-Anchor" href="#配合的condition"></a> 配合的Condition</h4><p>在下篇手记-介绍Condition中有详细分析~</p><h4 id="小总结"><a class="markdownIt-Anchor" href="#小总结"></a> 小总结：</h4><ol><li>synchronized关键字：它是由JVM实现，并有很多内存监控工具提供帮助，并通过这些工具配合synchronized的内存标识，进行内存层面的“debug”或观察；当运行时出现异常，JVM会自动解锁并进行处理。</li><li>ReentrantLock、ReentrantReadWriteLock、StampedLock是对象层面的锁，需要手动指定加锁与解锁操作（放在finally中）。</li><li>StampedLock：因为加入乐观锁，故对吞吐量有较大的优化，尤其是读多写少时。但使用起来较复杂，API内容较多。</li><li>当线程较少推荐使用synchronized关键字，简单效率高；当线程较多，且线程并发的增长有一定趋势时（可预估），推荐使用ReentrantLock。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这部分还是接着上部分的源码学习。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Java之并发编程" scheme="http://suprisemf.github.io/categories/Java%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java" scheme="http://suprisemf.github.io/tags/Java/"/>
    
      <category term="并发编程" scheme="http://suprisemf.github.io/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>J.U.C之AQS—RentrantLock-Part-1</title>
    <link href="http://suprisemf.github.io/2018/08/03/JJ-U-C%E4%B9%8BAQS%E2%80%94RentrantLock-part-1/"/>
    <id>http://suprisemf.github.io/2018/08/03/JJ-U-C之AQS—RentrantLock-part-1/</id>
    <published>2018-08-03T00:37:29.000Z</published>
    <updated>2018-08-03T00:44:12.465Z</updated>
    
    <content type="html"><![CDATA[<h4 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h4><p>RentrantLock即重入锁，是JDK中J.U.C提供的最重要的锁。<br>通过自旋锁实现RentrantLock：循环调用CAS操作实现枷锁，即<strong>阻止线程进入内核态被阻塞</strong>，故而效率较高。</p><a id="more"></a><h4 id="与synchronized对比"><a class="markdownIt-Anchor" href="#与synchronized对比"></a> 与Synchronized对比</h4><ol><li>可重入性：两者都具有可重入性。</li><li>锁的实现：RentrantLock是JDK中源码实现；Synchronized的锁机制是由JVM的JMM机制管理实现。</li><li>性能区别：Synchronized关键字优化前，其性能很差；但优化后（借鉴了RentrantLock中的CAS机制：在用户态加锁解锁），引入了偏向锁、自旋锁后，两者性能几无差异。（更推荐synchronized）。</li><li>功能区别：(1).synchronized关键字使用更加简洁简单，由编译器保证实现；RentrantLock需声明锁，并加锁，在finally中解锁。(2).RentrantLock锁粒度更细，灵活度高。</li></ol><blockquote><p>公平锁即按照线程的请求的先后顺序给与锁；非公平锁即按照对锁的争夺成功的线程加锁。</p></blockquote><h4 id="特有功能"><a class="markdownIt-Anchor" href="#特有功能"></a> 特有功能：</h4><ol><li>RentrantLock可以指定该lock是公平锁或非公平锁（而synchronized只能是非公平锁）；</li><li>通过方法提供Condition类，可以分组唤醒需要唤醒的线程。</li><li>提供能够中断等待锁的线程的机制 --&gt; lock.lockInterruptibly()</li></ol><h4 id="适用场景"><a class="markdownIt-Anchor" href="#适用场景"></a> 适用场景</h4><p>当需要用到上面RentrantLock的特有功能时，必须使用RentrantLock。</p><h4 id="演示例子"><a class="markdownIt-Anchor" href="#演示例子"></a> 演示例子</h4><h5 id="rentrantlock"><a class="markdownIt-Anchor" href="#rentrantlock"></a> RentrantLock</h5><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockExample2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> clientTotal = <span class="number">5000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> threadTotal = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(threadTotal);</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(clientTotal);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clientTotal ; i++) &#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    add();</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.<span class="keyword">error</span>(<span class="string">"exception"</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">        log.info(<span class="string">"count:&#123;&#125;"</span>, count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="例子分析"><a class="markdownIt-Anchor" href="#例子分析"></a> 例子分析：</h5><p>简简单单，只是在核心方法执行前加锁，在之后的finally中解锁。</p><h5 id="rentrantreadwritelock"><a class="markdownIt-Anchor" href="#rentrantreadwritelock"></a> RentrantReadWriteLock</h5><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class LockExample3 &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;<span class="keyword">String</span>, Data&gt; <span class="built_in">map</span> = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock lock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock readLock = lock.readLock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock writeLock = lock.writeLock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Data <span class="built_in">get</span>(<span class="keyword">String</span> <span class="built_in">key</span>) &#123;</span><br><span class="line">        readLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">map</span>.<span class="built_in">get</span>(<span class="built_in">key</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            readLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Set&lt;<span class="keyword">String</span>&gt; getAllKeys() &#123;</span><br><span class="line">        readLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">map</span>.keySet();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            readLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Data put(<span class="keyword">String</span> <span class="built_in">key</span>, Data value) &#123;</span><br><span class="line">        writeLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">map</span>.put(<span class="built_in">key</span>, value);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            readLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="例子说明"><a class="markdownIt-Anchor" href="#例子说明"></a> 例子说明</h5><ol><li>其中使用了RentrantReadWriteLock，该锁是读写分离锁，即读操作和写操作分别持有一把锁。</li><li>而且由于该RentrantReadWriteLock的读锁是一种悲观锁，即只有当其他操作都执行完后才会进行写操作。那么，但实际应用中读操作是远远多于写操作的（一般情况下），那么可能会导致写操作产生线程饥饿。</li></ol><blockquote><p><strong>悲观锁</strong>：对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度；因为悲观，认为自己的数据很容易在并发中产生错误，所以在整个数据处理过程中，将数据处于锁定状态.<br><strong>乐观锁</strong>：大多是基于数据版本记录机制实现；读取出数据时，将此版本号（version字段）一同读出，之后更新时，对此版本号加一；若提交的数据版本大于数据库表当前版本号，则予以更新，否则认为是过期数据。<br><strong>线程饥饿</strong>：通常是因为线程优先级过低，导致该线程等待被执行的时间过久，甚至执行操作已经无意义。</p></blockquote><ol start="3"><li>因此，该类实际中用到的不多。</li></ol><h5 id="stampedlock"><a class="markdownIt-Anchor" href="#stampedlock"></a> StampedLock</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StampedLockExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">double</span> x, y;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> StampedLock sl = <span class="keyword">new</span> StampedLock();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">double</span> deltaX, <span class="keyword">double</span> deltaY)</span> </span>&#123; <span class="comment">// an exclusively locked method</span></span><br><span class="line">            <span class="keyword">long</span> stamp = sl.writeLock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                x += deltaX;</span><br><span class="line">                y += deltaY;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                sl.unlockWrite(stamp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//下面是乐观读锁案例</span></span><br><span class="line">        <span class="function"><span class="keyword">double</span> <span class="title">distanceFromOrigin</span><span class="params">()</span> </span>&#123; <span class="comment">// A read-only method</span></span><br><span class="line">            <span class="keyword">long</span> stamp = sl.tryOptimisticRead(); <span class="comment">//获得一个乐观读锁</span></span><br><span class="line">            <span class="keyword">double</span> currentX = x, currentY = y;  <span class="comment">//将两个字段读入本地局部变量</span></span><br><span class="line">            <span class="keyword">if</span> (!sl.validate(stamp)) &#123; <span class="comment">//检查发出乐观读锁后同时是否有其他写锁发生？</span></span><br><span class="line">                stamp = sl.readLock();  <span class="comment">//如果没有，我们再次获得一个读悲观锁</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    currentX = x; <span class="comment">// 将两个字段读入本地局部变量</span></span><br><span class="line">                    currentY = y; <span class="comment">// 将两个字段读入本地局部变量</span></span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    sl.unlockRead(stamp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> Math.sqrt(currentX * currentX + currentY * currentY);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//下面是悲观读锁案例</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">moveIfAtOrigin</span><span class="params">(<span class="keyword">double</span> newX, <span class="keyword">double</span> newY)</span> </span>&#123; <span class="comment">// upgrade</span></span><br><span class="line">            <span class="comment">// Could instead start with optimistic, not read mode</span></span><br><span class="line">            <span class="keyword">long</span> stamp = sl.readLock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (x == <span class="number">0.0</span> &amp;&amp; y == <span class="number">0.0</span>) &#123; <span class="comment">//循环，检查当前状态是否符合</span></span><br><span class="line">                    <span class="keyword">long</span> ws = sl.tryConvertToWriteLock(stamp); <span class="comment">//将读锁转为写锁</span></span><br><span class="line">                    <span class="keyword">if</span> (ws != <span class="number">0L</span>) &#123; <span class="comment">//这是确认转为写锁是否成功</span></span><br><span class="line">                        stamp = ws; <span class="comment">//如果成功 替换票据</span></span><br><span class="line">                        x = newX; <span class="comment">//进行状态改变</span></span><br><span class="line">                        y = newY;  <span class="comment">//进行状态改变</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123; <span class="comment">//如果不能成功转换为写锁</span></span><br><span class="line">                        sl.unlockRead(stamp);  <span class="comment">//我们显式释放读锁</span></span><br><span class="line">                        stamp = sl.writeLock();  <span class="comment">//显式直接进行写锁 然后再通过循环再试</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                sl.unlock(stamp); <span class="comment">//释放读锁或写锁</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="例子分析-2"><a class="markdownIt-Anchor" href="#例子分析-2"></a> 例子分析</h5><p>这个例子是JDK源码中提供的参考例子。相对于RentrantReadWriteLock，StampedLock的有三种控制锁的模式：写锁，读锁，乐观读锁(!!)。由于提供了乐观锁的实现机制，那么即使是在读操作占比很高的情况中，系统仍然可以保持较好性能和高IO吞吐量。</p><h6 id="stampedlock源码分析"><a class="markdownIt-Anchor" href="#stampedlock源码分析"></a> StampedLock源码分析</h6><p>先看顶部注释：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * A capability-based lock <span class="keyword">with</span> three modes <span class="keyword">for</span> controlling read/write</span><br><span class="line"> * <span class="keyword">access</span>.  The state <span class="keyword">of</span> a StampedLock consists <span class="keyword">of</span> a version <span class="keyword">and</span> mode.</span><br><span class="line"> * Lock acquisition methods <span class="keyword">return</span> a stamp that represents <span class="keyword">and</span></span><br><span class="line"> * controls <span class="keyword">access</span> <span class="keyword">with</span> respect to a lock state; <span class="string">"try"</span> versions <span class="keyword">of</span></span><br><span class="line"> * these methods may instead <span class="keyword">return</span> the special value zero to</span><br><span class="line"> * represent failure to acquire <span class="keyword">access</span>. Lock release <span class="keyword">and</span> conversion</span><br><span class="line"> * methods require stamps as arguments, <span class="keyword">and</span> fail <span class="keyword">if</span> they <span class="keyword">do</span> <span class="keyword">not</span> match</span><br><span class="line"> * the state <span class="keyword">of</span> the lock. ……</span><br><span class="line"> *</span><br><span class="line"> *  &lt;li&gt;&lt;b&gt;Optimistic Reading.&lt;/b&gt; Method &#123;@link #tryOptimisticRead&#125;</span><br><span class="line"> *   returns a non-zero stamp only <span class="keyword">if</span> the lock <span class="keyword">is</span> <span class="keyword">not</span> currently held</span><br><span class="line"> *   <span class="keyword">in</span> write mode. Method &#123;@link #validate&#125; returns <span class="literal">true</span> <span class="keyword">if</span> the lock</span><br><span class="line"> *   has <span class="keyword">not</span> been acquired <span class="keyword">in</span> write mode since obtaining a given</span><br><span class="line"> *   stamp.  This mode can be thought <span class="keyword">of</span> as an extremely weak version</span><br><span class="line"> *   <span class="keyword">of</span> a read-lock, that can be broken by a writer <span class="keyword">at</span> any time.  The</span><br><span class="line"> *   <span class="keyword">use</span> <span class="keyword">of</span> optimistic mode <span class="keyword">for</span> short read-only code segments often</span><br><span class="line"> *   reduces contention <span class="keyword">and</span> improves throughput.  However, its <span class="keyword">use</span> <span class="keyword">is</span></span><br><span class="line"> *   inherently fragile.  Optimistic read sections should only read</span><br><span class="line"> *   fields <span class="keyword">and</span> hold them <span class="keyword">in</span> local variables <span class="keyword">for</span> later <span class="keyword">use</span> after</span><br><span class="line"> *   validation. Fields read <span class="keyword">while</span> <span class="keyword">in</span> optimistic mode may be wildly</span><br><span class="line"> *   inconsistent, so usage applies only <span class="keyword">when</span> you are familiar enough</span><br><span class="line"> *   <span class="keyword">with</span> data representations to check consistency <span class="keyword">and</span>/<span class="keyword">or</span> repeatedly</span><br><span class="line"> *   invoke method &#123;@code validate()&#125;.  <span class="keyword">For</span> example, such steps are</span><br><span class="line"> *   typically required <span class="keyword">when</span> first reading an object <span class="keyword">or</span> <span class="keyword">array</span></span><br><span class="line"> *   reference, <span class="keyword">and</span> <span class="keyword">then</span> accessing one <span class="keyword">of</span> its fields, elements <span class="keyword">or</span></span><br><span class="line"> *   methods. &lt;/li&gt;</span><br><span class="line"> *</span><br><span class="line">     * Algorithmic notes:</span><br><span class="line">     *</span><br><span class="line">     * The design employs elements <span class="keyword">of</span> Sequence locks</span><br><span class="line">     * (as used <span class="keyword">in</span> linux kernels; see Lameter<span class="symbol">'s</span></span><br><span class="line">     * http://www.lameter.com/gelato2005.pdf</span><br><span class="line">     * <span class="keyword">and</span> elsewhere; see</span><br><span class="line">     * Boehm<span class="symbol">'s</span> http://www.hpl.hp.com/techreports/<span class="number">2012</span>/HPL-<span class="number">2012</span>-<span class="number">68</span>.html)</span><br><span class="line">     * <span class="keyword">and</span> Ordered RW locks (see Shirako et al</span><br><span class="line">     * http://dl.acm.org/citation.cfm?id=<span class="number">2312015</span>)</span><br><span class="line">     *</span><br><span class="line">     * Conceptually, the primary state <span class="keyword">of</span> the lock includes a sequence</span><br><span class="line">     * number that <span class="keyword">is</span> odd <span class="keyword">when</span> write-locked <span class="keyword">and</span> even otherwise.</span><br><span class="line">     * However, this <span class="keyword">is</span> offset by a reader count that <span class="keyword">is</span> non-zero <span class="keyword">when</span></span><br><span class="line">     * read-locked.  The read count <span class="keyword">is</span> ignored <span class="keyword">when</span> validating</span><br><span class="line">     * <span class="string">"optimistic"</span> seqlock-reader-style stamps.  Because we must <span class="keyword">use</span></span><br><span class="line">     * a small finite number <span class="keyword">of</span> bits (currently <span class="number">7</span>) <span class="keyword">for</span> readers, a</span><br><span class="line">     * supplementary reader overflow word <span class="keyword">is</span> used <span class="keyword">when</span> the number <span class="keyword">of</span></span><br><span class="line">     * readers exceeds the count field. We <span class="keyword">do</span> this by treating the max</span><br><span class="line">     * reader count value (RBITS) as a spinlock protecting overflow</span><br><span class="line">     * updates.</span><br><span class="line">     *</span><br><span class="line">     * Waiters <span class="keyword">use</span> a modified form <span class="keyword">of</span> CLH lock used <span class="keyword">in</span></span><br><span class="line">     * AbstractQueuedSynchronizer (see its internal documentation <span class="keyword">for</span></span><br><span class="line">     * a fuller account), where each node <span class="keyword">is</span> <span class="keyword">tagged</span> (field mode) as</span><br><span class="line">     * either a reader <span class="keyword">or</span> writer. Sets <span class="keyword">of</span> waiting readers are grouped</span><br><span class="line">     * (linked) under a common node (field cowait) so act as a single</span><br><span class="line">     * node <span class="keyword">with</span> respect to most CLH mechanics.  By virtue <span class="keyword">of</span> the</span><br><span class="line">     * queue structure, wait nodes need <span class="keyword">not</span> actually carry sequence</span><br><span class="line">     * numbers; we know each <span class="keyword">is</span> greater than its predecessor.  This</span><br><span class="line">     * simplifies the scheduling policy to a mainly-FIFO scheme that</span><br><span class="line">     * incorporates elements <span class="keyword">of</span> Phase-Fair locks (see Brandenburg &amp;</span><br><span class="line">     * Anderson, especially http://www.cs.unc.edu/~bbb/diss/).  <span class="keyword">In</span></span><br><span class="line">     * particular, we <span class="keyword">use</span> the phase-fair anti-barging rule: <span class="keyword">If</span> an</span><br><span class="line">     * incoming reader arrives <span class="keyword">while</span> read lock <span class="keyword">is</span> held but there <span class="keyword">is</span> a</span><br><span class="line">     * queued writer, this incoming reader <span class="keyword">is</span> queued.  (This rule <span class="keyword">is</span></span><br><span class="line">     * responsible <span class="keyword">for</span> <span class="keyword">some</span> <span class="keyword">of</span> the complexity <span class="keyword">of</span> method acquireRead,</span><br><span class="line">     * but without it, the lock becomes highly unfair.) Method release</span><br><span class="line">     * does <span class="keyword">not</span> (<span class="keyword">and</span> sometimes cannot) itself wake up cowaiters. This</span><br><span class="line">     * <span class="keyword">is</span> done by the primary thread, but helped by any other threads</span><br><span class="line">     * <span class="keyword">with</span> nothing better to <span class="keyword">do</span> <span class="keyword">in</span> methods acquireRead <span class="keyword">and</span></span><br><span class="line">     * acquireWrite.</span><br><span class="line">     *</span><br><span class="line">     * These rules apply to threads actually queued. <span class="keyword">All</span> tryLock forms</span><br><span class="line">     * opportunistically try to acquire locks regardless <span class="keyword">of</span> preference</span><br><span class="line">     * rules, <span class="keyword">and</span> so may <span class="string">"barge"</span> their way <span class="keyword">in</span>.  Randomized spinning <span class="keyword">is</span></span><br><span class="line">     * used <span class="keyword">in</span> the acquire methods to reduce (increasingly expensive)</span><br><span class="line">     * context switching <span class="keyword">while</span> also avoiding sustained memory</span><br><span class="line">     * thrashing among many threads.  We limit spins to the head <span class="keyword">of</span></span><br><span class="line">     * queue. A thread spin-waits up to SPINS times (where each</span><br><span class="line">     * iteration decreases spin count <span class="keyword">with</span> <span class="number">50</span>% probability) before</span><br><span class="line">     * blocking. <span class="keyword">If</span>, upon wakening it fails to obtain lock, <span class="keyword">and</span> <span class="keyword">is</span></span><br><span class="line">     * still (<span class="keyword">or</span> becomes) the first waiting thread (which indicates</span><br><span class="line">     * that <span class="keyword">some</span> other thread barged <span class="keyword">and</span> obtained lock), it escalates</span><br><span class="line">     * spins (up to MAX_HEAD_SPINS) to reduce the likelihood <span class="keyword">of</span></span><br><span class="line">     * continually losing to barging threads.</span><br><span class="line">     *</span><br><span class="line">     * Nearly <span class="keyword">all</span> <span class="keyword">of</span> these mechanics are carried <span class="keyword">out</span> <span class="keyword">in</span> methods</span><br><span class="line">     * acquireWrite <span class="keyword">and</span> acquireRead, that, as typical <span class="keyword">of</span> such code,</span><br><span class="line">     * sprawl <span class="keyword">out</span> because actions <span class="keyword">and</span> retries rely on consistent sets</span><br><span class="line">     * <span class="keyword">of</span> locally cached reads.</span><br><span class="line">     *</span><br><span class="line">     * As noted <span class="keyword">in</span> Boehm<span class="symbol">'s</span> paper (above), sequence validation (mainly</span><br><span class="line">     * method validate()) requires stricter ordering rules than apply</span><br><span class="line">     * to normal volatile reads (<span class="keyword">of</span> <span class="string">"state"</span>).  To force orderings <span class="keyword">of</span></span><br><span class="line">     * reads before a validation <span class="keyword">and</span> the validation itself <span class="keyword">in</span> those</span><br><span class="line">     * cases where this <span class="keyword">is</span> <span class="keyword">not</span> already forced, we <span class="keyword">use</span></span><br><span class="line">     * Unsafe.loadFence.</span><br><span class="line">     *</span><br><span class="line">     * The memory layout keeps lock state <span class="keyword">and</span> queue pointers together</span><br><span class="line">     * (normally on the same cache line). This usually works well <span class="keyword">for</span></span><br><span class="line">     * read-mostly loads. <span class="keyword">In</span> most other cases, the natural tendency <span class="keyword">of</span></span><br><span class="line">     * adaptive-spin CLH locks to reduce memory contention lessens</span><br><span class="line">     * motivation to further spread <span class="keyword">out</span> contended locations, but might</span><br><span class="line">     * be subject to future improvements.</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><p>看来这个类还是有、东西的。不过内容太多了，也不知从何看起。目前先了解一下大致情况，以后继续慢慢了解~</p><blockquote><p>答应我，不要吐~ 还是翻回去从头好好看一下，其中有用到AQS的CLH队列哦~</p></blockquote><p>（后接part-2）</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;概述&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#概述&quot;&gt;&lt;/a&gt; 概述&lt;/h4&gt;
&lt;p&gt;RentrantLock即重入锁，是JDK中J.U.C提供的最重要的锁。&lt;br&gt;
通过自旋锁实现RentrantLock：循环调用CAS操作实现枷锁，即&lt;strong&gt;阻止线程进入内核态被阻塞&lt;/strong&gt;，故而效率较高。&lt;/p&gt;
    
    </summary>
    
      <category term="Java之并发编程" scheme="http://suprisemf.github.io/categories/Java%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java" scheme="http://suprisemf.github.io/tags/Java/"/>
    
      <category term="并发编程" scheme="http://suprisemf.github.io/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>J.U.C之AQS—Condition</title>
    <link href="http://suprisemf.github.io/2018/08/03/J-U-C%E4%B9%8BAQS%E2%80%94Condition/"/>
    <id>http://suprisemf.github.io/2018/08/03/J-U-C之AQS—Condition/</id>
    <published>2018-08-03T00:30:23.000Z</published>
    <updated>2018-08-03T00:32:56.856Z</updated>
    
    <content type="html"><![CDATA[<h4 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h4><p>他是一个接口类。</p><h4 id="演示例子"><a class="markdownIt-Anchor" href="#演示例子"></a> 演示例子</h4><a id="more"></a><h5 id="结合重入锁reentrantlock"><a class="markdownIt-Anchor" href="#结合重入锁reentrantlock"></a> 结合重入锁ReentrantLock：</h5><figure class="highlight pony"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">@<span class="type">Slf4j</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">LockExample6</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    public static void main(<span class="type">String</span>[] args) &#123;</span><br><span class="line">        <span class="type">ReentrantLock</span> reentrantLock = <span class="function"><span class="keyword">new</span> <span class="title">ReentrantLock</span>();</span></span><br><span class="line"><span class="function">        <span class="title">Condition</span> <span class="title">condition</span> = <span class="title">reentrantLock</span>.<span class="title">newCondition</span>();</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">        <span class="comment">//执行顺序用数字标出</span></span></span><br><span class="line"><span class="function">        <span class="title">new</span> <span class="title">Thread</span>(() -&gt; &#123;<span class="comment">//线程1</span></span></span><br><span class="line"><span class="function">            <span class="title">try</span> &#123;</span></span><br><span class="line"><span class="function">                <span class="title">reentrantLock</span>.<span class="title">lock</span>();</span></span><br><span class="line"><span class="function">                <span class="title">log</span>.<span class="title">info</span>("wait signal"); <span class="comment">// 1</span></span></span><br><span class="line"><span class="function">                <span class="title">condition</span>.<span class="title">await</span>();</span></span><br><span class="line"><span class="function">            &#125; <span class="title">catch</span> (<span class="type">InterruptedException</span> e) &#123;</span></span><br><span class="line"><span class="function">                <span class="title">e</span>.<span class="title">printStackTrace</span>();</span></span><br><span class="line"><span class="function">            &#125;</span></span><br><span class="line"><span class="function">            <span class="title">log</span>.<span class="title">info</span>("get signal"); <span class="comment">// 4</span></span></span><br><span class="line"><span class="function">            <span class="title">reentrantLock</span>.<span class="title">unlock</span>();</span></span><br><span class="line"><span class="function">        &#125;).<span class="title">start</span>();</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">        <span class="title">new</span> <span class="title">Thread</span>(() -&gt; &#123;<span class="comment">//线程2</span></span></span><br><span class="line"><span class="function">            <span class="title">reentrantLock</span>.<span class="title">lock</span>();</span></span><br><span class="line"><span class="function">            <span class="title">log</span>.<span class="title">info</span>("get lock"); <span class="comment">// 2</span></span></span><br><span class="line"><span class="function">            <span class="title">try</span> &#123;</span></span><br><span class="line"><span class="function">                <span class="title">Thread</span>.<span class="title">sleep</span>(<span class="number">3000</span>);</span></span><br><span class="line"><span class="function">            &#125; <span class="title">catch</span> (<span class="type">InterruptedException</span> e) &#123;</span></span><br><span class="line"><span class="function">                <span class="title">e</span>.<span class="title">printStackTrace</span>();</span></span><br><span class="line"><span class="function">            &#125;</span></span><br><span class="line"><span class="function">            <span class="title">condition</span>.<span class="title">signalAll</span>();</span></span><br><span class="line"><span class="function">            <span class="title">log</span>.<span class="title">info</span>("send signal ~ "); <span class="comment">// 3</span></span></span><br><span class="line"><span class="function">            <span class="title">reentrantLock</span>.<span class="title">unlock</span>();</span></span><br><span class="line"><span class="function">        &#125;).<span class="title">start</span>();</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><h5 id="运行结果"><a class="markdownIt-Anchor" href="#运行结果"></a> 运行结果</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">09<span class="selector-pseudo">:39</span><span class="selector-pseudo">:54.468</span> <span class="selector-attr">[Thread-0]</span> <span class="selector-tag">INFO</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.lock</span><span class="selector-class">.LockExample6</span> <span class="selector-tag">-</span> <span class="selector-tag">wait</span> <span class="selector-tag">signal</span></span><br><span class="line">09<span class="selector-pseudo">:39</span><span class="selector-pseudo">:54.476</span> <span class="selector-attr">[Thread-1]</span> <span class="selector-tag">INFO</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.lock</span><span class="selector-class">.LockExample6</span> <span class="selector-tag">-</span> <span class="selector-tag">get</span> <span class="selector-tag">lock</span></span><br><span class="line">09<span class="selector-pseudo">:39</span><span class="selector-pseudo">:57.476</span> <span class="selector-attr">[Thread-1]</span> <span class="selector-tag">INFO</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.lock</span><span class="selector-class">.LockExample6</span> <span class="selector-tag">-</span> <span class="selector-tag">send</span> <span class="selector-tag">signal</span> ~</span><br><span class="line">09<span class="selector-pseudo">:39</span><span class="selector-pseudo">:57.476</span> <span class="selector-attr">[Thread-0]</span> <span class="selector-tag">INFO</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.lock</span><span class="selector-class">.LockExample6</span> <span class="selector-tag">-</span> <span class="selector-tag">get</span> <span class="selector-tag">signal</span></span><br></pre></td></tr></table></figure><h5 id="例子分析"><a class="markdownIt-Anchor" href="#例子分析"></a> 例子分析</h5><ol><li>可以看出输出的日志是与我们提到的执行顺序是对应的。</li><li>首先声明定义一个reentrantlock实例，并调用它的newCondition()创建一个condition实例并取出；</li><li>然后当线程1中调用reentrantLock.lock()后，就进入AQS的等待队列中，即之前介绍过的双向列表；</li><li>当调用condition.await()后，线程释放锁并从AQS等待队列中被移除，紧接着就被加入到Condition的等待队列中，该线程再次被唤醒则需要一个signal信号；</li><li>当线程1释放锁，线程2就被唤醒并尝试获取锁。获取后，也加入到AQS的等待队列中。通过调用condition.signalAll()给所有处于condition等待队列的线程发送信号，此时线程1又从Condition等待队列被移除，并加入到AQS等待队列中（还未唤醒）。最后线程2释放锁。</li><li>在线程2释放锁后，线程1拿到锁。此时线程1又处于AQS等待队列的head节点，则又被唤醒，接着上次执行到的地方继续执行后续操作。</li></ol><h4 id="源码分析"><a class="markdownIt-Anchor" href="#源码分析"></a> 源码分析</h4><h5 id="类内成员"><a class="markdownIt-Anchor" href="#类内成员"></a> 类内成员</h5><p><img src="/2018/08/03/J-U-C之AQS—Condition/J-U-C%E4%B9%8BAQS%E2%80%94Condition/Condition%E5%86%85%E9%83%A8%E6%88%90%E5%91%98.png" alt="图示"></p><hr><h5 id="源码大注释"><a class="markdownIt-Anchor" href="#源码大注释"></a> 源码大注释：</h5><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * &#123;@code Condition&#125; factors out the &#123;@code Object&#125; monitor</span><br><span class="line"> * methods (&#123;@link Object<span class="comment">#wait() wait&#125;, &#123;@link Object#notify notify&#125;</span></span><br><span class="line"> *<span class="built_in"> and </span>&#123;@link Object<span class="comment">#notifyAll notifyAll&#125;) into distinct objects to</span></span><br><span class="line"> * give the effect of having multiple wait-sets per object, by</span><br><span class="line"> * combining them with the use of arbitrary &#123;@link Lock&#125; implementations.</span><br><span class="line"> * Where a &#123;@code Lock&#125; replaces the use of &#123;@code synchronized&#125; methods</span><br><span class="line"> *<span class="built_in"> and </span>statements, a &#123;@code Condition&#125; replaces the use of the Object</span><br><span class="line"> *<span class="built_in"> monitor </span>methods.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;Conditions (also known as &lt;em&gt;condition queues&lt;/em&gt; or</span><br><span class="line"> * &lt;em&gt;condition variables&lt;/em&gt;) provide a means for one thread to</span><br><span class="line"> * suspend execution (to &amp;quot;wait&amp;quot;) until notified by another</span><br><span class="line"> * thread that some state condition may now be true.  Because access</span><br><span class="line"> * to this shared state information occurs in different threads, it</span><br><span class="line"> * must be<span class="keyword"> protected</span>, so a lock of some form is associated with the</span><br><span class="line"> * condition. The key property that waiting for a condition provides</span><br><span class="line"> * is that it &lt;em&gt;atomically&lt;/em&gt; releases the associated lock and</span><br><span class="line"> * suspends the current thread, just like &#123;@code Object.wait&#125;.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;A &#123;@code Condition&#125;<span class="built_in"> instance </span>is intrinsically bound to a lock.</span><br><span class="line"> * To obtain a &#123;@code Condition&#125;<span class="built_in"> instance </span>for a particular &#123;@link Lock&#125;</span><br><span class="line"> *<span class="built_in"> instance </span>use its &#123;@link Lock<span class="comment">#newCondition newCondition()&#125; method.</span></span><br><span class="line"> */</span><br></pre></td></tr></table></figure><p><strong>注释重点：</strong></p><ol><li>Condition使得每个对象，因都通过结合他们自己和随意锁的实现，且具有多个等待集合（wait-sets）而被区分开来，从而使监视器（monitor）方法失效。</li><li>Conditions（被当做Condition队列）为场景提供一种新处理方式：一个线程可以暂停自己的执行，直到被另一个具有一些可能正确的状态信息的线程通知。由于共享的状态信息的访问发生在不同的线程间，因此它必须被某种形式的锁保护起来。</li><li>该类提供的关键属性是原子性地释放锁，并暂停当前线程。</li><li>Condition的实例实际上是一个锁。如果为了一个锁机制而要获取一个Condition实例，需要使用它的newCondition()方法。</li></ol><hr><h5 id="类内接口"><a class="markdownIt-Anchor" href="#类内接口"></a> 类内接口</h5><h6 id="1-await"><a class="markdownIt-Anchor" href="#1-await"></a> 1. await()</h6><p>调用该方法会使线程等待直至线程被给予信号量或被中断。</p><h6 id="2-awaitlong-time-timeunit-unit"><a class="markdownIt-Anchor" href="#2-awaitlong-time-timeunit-unit"></a> 2. await(long time, TimeUnit unit)</h6><p>指定超时时间参数，或超时时间过期时线程也会被重新调用</p><h6 id="3-awaitnanoslong-nanostimeout"><a class="markdownIt-Anchor" href="#3-awaitnanoslong-nanostimeout"></a> 3. awaitNanos(long nanosTimeout)</h6><p>这个方法通过被指定毫微的超时时间，会返回一个线程剩余要等待的毫微时间数。如果超时了的话，该返回值是小于等于0的。</p><h6 id="4-awaituninterruptibly"><a class="markdownIt-Anchor" href="#4-awaituninterruptibly"></a> 4. awaitUninterruptibly()</h6><p>该方法是不会产生线程中断情况下的await()方法。</p><h6 id="5-awaituntildate-deadline"><a class="markdownIt-Anchor" href="#5-awaituntildate-deadline"></a> 5. awaitUntil(Date deadline)</h6><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Causes <span class="keyword">the</span> current thread <span class="keyword">to</span> wait <span class="keyword">until</span> <span class="keyword">it</span> <span class="keyword">is</span> signalled <span class="keyword">or</span> interrupted,</span><br><span class="line"> * <span class="keyword">or</span> <span class="keyword">the</span> specified deadline elapses.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;The lock associated <span class="keyword">with</span> this condition <span class="keyword">is</span> atomically</span><br><span class="line"> * released <span class="keyword">and</span> <span class="keyword">the</span> current thread becomes disabled <span class="keyword">for</span> thread scheduling</span><br><span class="line"> * purposes <span class="keyword">and</span> lies dormant <span class="keyword">until</span> &lt;em&gt;one&lt;/em&gt; <span class="keyword">of</span> five things happens:</span><br><span class="line"> * &lt;ul&gt;</span><br><span class="line"> * &lt;li&gt;Some other thread invokes <span class="keyword">the</span> &#123;@link <span class="comment">#signal&#125; method for this</span></span><br><span class="line"> * &#123;@code Condition&#125; <span class="keyword">and</span> <span class="keyword">the</span> current thread happens <span class="keyword">to</span> be chosen <span class="keyword">as</span> <span class="keyword">the</span></span><br><span class="line"> * thread <span class="keyword">to</span> be awakened; <span class="keyword">or</span></span><br><span class="line"> * &lt;li&gt;Some other thread invokes <span class="keyword">the</span> &#123;@link <span class="comment">#signalAll&#125; method for this</span></span><br><span class="line"> * &#123;@code Condition&#125;; <span class="keyword">or</span></span><br><span class="line"> * &lt;li&gt;Some other thread &#123;@linkplain Thread<span class="comment">#interrupt interrupts&#125; the</span></span><br><span class="line"> * current thread, <span class="keyword">and</span> interruption <span class="keyword">of</span> thread suspension <span class="keyword">is</span> supported; <span class="keyword">or</span></span><br><span class="line"> * &lt;li&gt;The specified deadline elapses; <span class="keyword">or</span></span><br><span class="line"> * &lt;li&gt;A &amp;quot;&lt;em&gt;spurious wakeup&lt;/em&gt;&amp;quot; occurs.</span><br><span class="line"> * &lt;/ul&gt;</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;In all cases, <span class="keyword">before</span> this method can <span class="literal">return</span> <span class="keyword">the</span> current thread must</span><br><span class="line"> * re-acquire <span class="keyword">the</span> lock associated <span class="keyword">with</span> this condition. When <span class="keyword">the</span></span><br><span class="line"> * thread returns <span class="keyword">it</span> <span class="keyword">is</span> &lt;em&gt;guaranteed&lt;/em&gt; <span class="keyword">to</span> hold this lock.</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><h6 id="6-signal"><a class="markdownIt-Anchor" href="#6-signal"></a> 6. signal()</h6><p>唤醒一个等待中的线程。<br>该线程在从await()返回前，必须重新请求获取锁。</p><h6 id="7-signalall"><a class="markdownIt-Anchor" href="#7-signalall"></a> 7. signalAll()</h6><p>唤醒所有的线程。其中每个线程在从await()返回前，都必须重新请求获取锁。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;概述&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#概述&quot;&gt;&lt;/a&gt; 概述&lt;/h4&gt;
&lt;p&gt;他是一个接口类。&lt;/p&gt;
&lt;h4 id=&quot;演示例子&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#演示例子&quot;&gt;&lt;/a&gt; 演示例子&lt;/h4&gt;
    
    </summary>
    
      <category term="Java之并发编程" scheme="http://suprisemf.github.io/categories/Java%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java" scheme="http://suprisemf.github.io/tags/Java/"/>
    
      <category term="并发编程" scheme="http://suprisemf.github.io/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>J.U.C之AQS—CyclicBarrier</title>
    <link href="http://suprisemf.github.io/2018/08/02/J-U-C%E4%B9%8BAQS%E2%80%94CyclicBarrier/"/>
    <id>http://suprisemf.github.io/2018/08/02/J-U-C之AQS—CyclicBarrier/</id>
    <published>2018-08-02T15:55:32.000Z</published>
    <updated>2018-08-02T15:58:54.209Z</updated>
    
    <content type="html"><![CDATA[<h4 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h4><p>CyclicBarrier也是JDK提供的辅助类。它允许一组线程相互等待，直到到达一个公共的屏障点（CommonBarrierPoint）。通过它可以使多个线程间相互等待，只有当每个线程都准备就绪后才能各自继续执行后面的操作。</p><a id="more"></a><p><img src="/2018/08/02/J-U-C之AQS—CyclicBarrier/J-U-C%E4%B9%8BAQS%E2%80%94CyclicBarrier/cyclicbarrier%E5%8E%9F%E7%90%86%E5%9B%BE.png" alt="原理图"></p><h4 id="与countdownlatch的比较"><a class="markdownIt-Anchor" href="#与countdownlatch的比较"></a> 与CountDownLatch的比较：</h4><ol><li>CountDownLatch是实现<strong>一个或多个线程需要等待其他线程完成某项操作</strong>之后才会才会继续执行。而CyclicBarrier是实现<strong>多个线程间相互等待，直到所有线程都满足条件</strong>后继续执行后续操作。</li><li>同时通过计数器实现，该类不过是加一操作；</li><li>当线程调用await()时，进入等待状态；</li><li>当达到指定值时都会执行一定的操作：CountDownLatch是计数到达0或超时时间过期会执行下一步操作；CyclicBarrier是加一操作计数达到设定初始值或超时时间过期时，等待的线程会继续执行后续的操作。</li><li>当CountDownLatch计数到0后，就不可再使用了；但CyclicBarrier计数到设定值后，可以复用，可以reset重新计数使用。（呼应名字：循环屏障）</li><li>使用场景相似：CyclicBarrier和CountDownLatch都可用于多线程计算数据，最后汇总计算。但CyclicBarrier可以处理对付更加复杂的场景，例如：若一次并发执行后出现错误，接着可reset计数器，重新执行一次。</li></ol><h4 id="演示例子-1"><a class="markdownIt-Anchor" href="#演示例子-1"></a> 演示例子-1</h4><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierExample1</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    private static CyclicBarrier barrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    public static <span class="literal">void</span> main(String[] args) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        ExecutorService executor = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">            final int threadNum = i;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            executor.execute<span class="function"><span class="params">(() -&gt; &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">try</span> &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">                    race(threadNum);</span></span></span><br><span class="line"><span class="function"><span class="params">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">                    log.error(<span class="string">"exception"</span>, e);</span></span></span><br><span class="line"><span class="function"><span class="params">                &#125;</span></span></span><br><span class="line"><span class="function"><span class="params">            &#125;)</span>;</span></span><br><span class="line"><span class="function">        &#125;</span></span><br><span class="line"><span class="function">        <span class="title">executor</span>.<span class="title">shutdown</span><span class="params">()</span>;</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="title">private</span> <span class="title">static</span> <span class="title">void</span> <span class="title">race</span><span class="params">(int threadNum)</span> <span class="title">throws</span> <span class="title">Exception</span> &#123;</span></span><br><span class="line"><span class="function">        <span class="title">Thread</span>.<span class="title">sleep</span><span class="params">(<span class="number">1000</span>)</span>;</span></span><br><span class="line"><span class="function">        <span class="title">log</span>.<span class="title">info</span><span class="params">(<span class="string">"&#123;&#125; is ready"</span>, threadNum)</span>;</span></span><br><span class="line"><span class="function">        <span class="title">barrier</span>.<span class="title">await</span><span class="params">()</span>;</span></span><br><span class="line"><span class="function">        <span class="title">log</span>.<span class="title">info</span><span class="params">(<span class="string">"&#123;&#125; continue"</span>, threadNum)</span>;</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><h5 id="运行结果"><a class="markdownIt-Anchor" href="#运行结果"></a> 运行结果：</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">19<span class="selector-pseudo">:12</span><span class="selector-pseudo">:14.192</span> <span class="selector-attr">[pool-1-thread-1]</span> <span class="selector-tag">INFO</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.aqs</span><span class="selector-class">.CyclicBarrierExample1</span> <span class="selector-tag">-</span> 0 <span class="selector-tag">is</span> <span class="selector-tag">ready</span></span><br><span class="line">19<span class="selector-pseudo">:12</span><span class="selector-pseudo">:15.190</span> <span class="selector-attr">[pool-1-thread-2]</span> <span class="selector-tag">INFO</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.aqs</span><span class="selector-class">.CyclicBarrierExample1</span> <span class="selector-tag">-</span> 1 <span class="selector-tag">is</span> <span class="selector-tag">ready</span></span><br><span class="line">19<span class="selector-pseudo">:12</span><span class="selector-pseudo">:15.190</span> <span class="selector-attr">[pool-1-thread-2]</span> <span class="selector-tag">INFO</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.aqs</span><span class="selector-class">.CyclicBarrierExample1</span> <span class="selector-tag">-</span> 1 <span class="selector-tag">continue</span></span><br><span class="line">19<span class="selector-pseudo">:12</span><span class="selector-pseudo">:15.190</span> <span class="selector-attr">[pool-1-thread-1]</span> <span class="selector-tag">INFO</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.aqs</span><span class="selector-class">.CyclicBarrierExample1</span> <span class="selector-tag">-</span> 0 <span class="selector-tag">continue</span></span><br><span class="line">19<span class="selector-pseudo">:12</span><span class="selector-pseudo">:16.190</span> <span class="selector-attr">[pool-1-thread-3]</span> <span class="selector-tag">INFO</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.aqs</span><span class="selector-class">.CyclicBarrierExample1</span> <span class="selector-tag">-</span> 2 <span class="selector-tag">is</span> <span class="selector-tag">ready</span></span><br><span class="line">19<span class="selector-pseudo">:12</span><span class="selector-pseudo">:17.191</span> <span class="selector-attr">[pool-1-thread-1]</span> <span class="selector-tag">INFO</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.aqs</span><span class="selector-class">.CyclicBarrierExample1</span> <span class="selector-tag">-</span> 3 <span class="selector-tag">is</span> <span class="selector-tag">ready</span></span><br><span class="line">19<span class="selector-pseudo">:12</span><span class="selector-pseudo">:17.191</span> <span class="selector-attr">[pool-1-thread-1]</span> <span class="selector-tag">INFO</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.aqs</span><span class="selector-class">.CyclicBarrierExample1</span> <span class="selector-tag">-</span> 3 <span class="selector-tag">continue</span></span><br><span class="line">19<span class="selector-pseudo">:12</span><span class="selector-pseudo">:17.191</span> <span class="selector-attr">[pool-1-thread-3]</span> <span class="selector-tag">INFO</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.aqs</span><span class="selector-class">.CyclicBarrierExample1</span> <span class="selector-tag">-</span> 2 <span class="selector-tag">continue</span></span><br><span class="line">19<span class="selector-pseudo">:12</span><span class="selector-pseudo">:18.191</span> <span class="selector-attr">[pool-1-thread-2]</span> <span class="selector-tag">INFO</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.aqs</span><span class="selector-class">.CyclicBarrierExample1</span> <span class="selector-tag">-</span> 4 <span class="selector-tag">is</span> <span class="selector-tag">ready</span></span><br><span class="line">19<span class="selector-pseudo">:12</span><span class="selector-pseudo">:19.192</span> <span class="selector-attr">[pool-1-thread-3]</span> <span class="selector-tag">INFO</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.aqs</span><span class="selector-class">.CyclicBarrierExample1</span> <span class="selector-tag">-</span> 5 <span class="selector-tag">is</span> <span class="selector-tag">ready</span></span><br><span class="line">19<span class="selector-pseudo">:12</span><span class="selector-pseudo">:19.192</span> <span class="selector-attr">[pool-1-thread-3]</span> <span class="selector-tag">INFO</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.aqs</span><span class="selector-class">.CyclicBarrierExample1</span> <span class="selector-tag">-</span> 5 <span class="selector-tag">continue</span></span><br><span class="line">19<span class="selector-pseudo">:12</span><span class="selector-pseudo">:19.192</span> <span class="selector-attr">[pool-1-thread-2]</span> <span class="selector-tag">INFO</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.aqs</span><span class="selector-class">.CyclicBarrierExample1</span> <span class="selector-tag">-</span> 4 <span class="selector-tag">continue</span></span><br></pre></td></tr></table></figure><h5 id="结果分析"><a class="markdownIt-Anchor" href="#结果分析"></a> 结果分析：</h5><ol><li>当线程0和1都已经到达ready后，才会continue。</li><li>当上一层执行结束后，紧接着开始下一层的执行。</li></ol><h4 id="源码分析"><a class="markdownIt-Anchor" href="#源码分析"></a> 源码分析</h4><p>看一下该类的内部成员：</p><p><img src="/2018/08/02/J-U-C之AQS—CyclicBarrier/J-U-C%E4%B9%8BAQS%E2%80%94CyclicBarrier/cyclicbarrier%E5%86%85%E9%83%A8%E6%88%90%E5%91%98.png" alt="图示"></p><p>带有阻塞是操作指令参数的构造函数：</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Creates a<span class="built_in"> new </span>&#123;@code CyclicBarrier&#125; that will trip when the</span><br><span class="line"> * given number of parties (threads) are waiting upon it,<span class="built_in"> and </span>which</span><br><span class="line"> * will<span class="built_in"> execute </span>the given barrier action when the barrier is tripped,</span><br><span class="line"> * performed by the last thread entering the barrier.</span><br><span class="line"> *</span><br><span class="line"> * @param parties the number of threads that must<span class="built_in"> invoke </span>&#123;@link <span class="comment">#await&#125;</span></span><br><span class="line"> *        before the barrier is tripped</span><br><span class="line"> * @param barrierAction the command to<span class="built_in"> execute </span>when the barrier is</span><br><span class="line"> *        tripped,<span class="built_in"> or </span>&#123;@code null&#125;<span class="built_in"> if </span>there is no action</span><br><span class="line"> * @throws IllegalArgumentException<span class="built_in"> if </span>&#123;@code parties&#125; is less than 1</span><br><span class="line"> */</span><br><span class="line">public CyclicBarrier(int parties, Runnable barrierAction) &#123;</span><br><span class="line">   <span class="built_in"> if </span>(parties &lt;= 0)<span class="built_in"> throw </span>new IllegalArgumentException();</span><br><span class="line">    this.parties = parties;</span><br><span class="line">    this.count = parties;</span><br><span class="line">    this.barrierCommand = barrierAction;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>带有超时时间参数的await()：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> await(<span class="keyword">long</span> timeout, TimeUnit unit)</span><br><span class="line">    <span class="keyword">throws</span> InterruptedException,</span><br><span class="line">           BrokenBarrierException,</span><br><span class="line">           TimeoutException &#123;</span><br><span class="line">    <span class="keyword">return</span> dowait(<span class="keyword">true</span>, unit.toNanos(timeout));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置当前屏障无效，并唤醒每个线程。(持锁时有效)</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private void <span class="keyword">breakBarrier() </span>&#123;</span><br><span class="line">    generation.<span class="keyword">broken </span>= true<span class="comment">;</span></span><br><span class="line">    <span class="built_in">count</span> = parties<span class="comment">;</span></span><br><span class="line">    trip.signalAll()<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重置当前屏障计数：先加锁，再设置当前屏障代无效并创建新一代。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reset</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    final ReentrantLock <span class="keyword">lock</span> = <span class="keyword">this</span>.<span class="keyword">lock</span>;</span><br><span class="line">    <span class="keyword">lock</span>.<span class="keyword">lock</span>();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        breakBarrier();   <span class="comment">// break the current generation</span></span><br><span class="line">        nextGeneration(); <span class="comment">// start a new generation</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">lock</span>.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建新一代屏障：更新屏障闸的state字段并唤醒每个线程（持锁时有效）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">nextGeneration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// signal completion of last generation</span></span><br><span class="line">    trip.signalAll();</span><br><span class="line">    <span class="comment">// set up next generation</span></span><br><span class="line">    count = parties;</span><br><span class="line">    generation = <span class="keyword">new</span> Generation();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>await()中真正的实现方法==&gt;dowait():</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> dowait(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span><br><span class="line">    throws InterruptedException, BrokenBarrierException,</span><br><span class="line">           TimeoutException &#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;<span class="comment">//使用重入锁。</span></span><br><span class="line">    lock.lock();<span class="comment">//锁内操作保安全</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> Generation g = generation;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (g.broken)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">            breakBarrier();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//count为parties即聚集个数（互相等待的个数）</span></span><br><span class="line">        <span class="comment">//当index减为0，即所有线程都执行了该dowait()方法，都已执行完毕。</span></span><br><span class="line">        <span class="keyword">int</span> <span class="keyword">index</span> = --<span class="keyword">count</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">index</span> == <span class="number">0</span>) &#123;  <span class="comment">// tripped</span></span><br><span class="line">            <span class="keyword">boolean</span> ranAction = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;<span class="comment">//如果有执行命令则运行，并返回方法。</span></span><br><span class="line">                <span class="keyword">final</span> Runnable command = barrierCommand;</span><br><span class="line">                <span class="keyword">if</span> (command != <span class="keyword">null</span>)</span><br><span class="line">                    command.run();</span><br><span class="line">                ranAction = <span class="keyword">true</span>;</span><br><span class="line">                nextGeneration();</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!ranAction)<span class="comment">//执行命令为null，则破除屏障</span></span><br><span class="line">                    breakBarrier();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// loop until tripped, broken, interrupted, or timed out</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!timed)</span><br><span class="line">                    trip.await();</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; <span class="number">0</span>L)</span><br><span class="line">                    nanos = trip.awaitNanos(nanos);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                <span class="keyword">if</span> (g == generation &amp;&amp; ! g.broken) &#123;</span><br><span class="line">                    breakBarrier();</span><br><span class="line">                    <span class="keyword">throw</span> ie;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// We're about to finish waiting even if we had not</span></span><br><span class="line">                    <span class="comment">// been interrupted, so this interrupt is deemed to</span></span><br><span class="line">                    <span class="comment">// "belong" to subsequent execution.</span></span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (g.broken)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (g != generation)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">index</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0</span>L) &#123;</span><br><span class="line">                breakBarrier();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();<span class="comment">//操作结束释放锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Conditin：放闸前所处的等待状态</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> final Condition trip = lock.<span class="keyword">new</span><span class="type">Condition</span>();</span><br></pre></td></tr></table></figure><h4 id="演示例子-2"><a class="markdownIt-Anchor" href="#演示例子-2"></a> 演示例子-2</h4><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierExample2</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    private static CyclicBarrier barrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    public static <span class="literal">void</span> main(String[] args) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        ExecutorService executor = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            final int threadNum = i;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            executor.execute<span class="function"><span class="params">(() -&gt; &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">try</span> &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">                    race(threadNum);</span></span></span><br><span class="line"><span class="function"><span class="params">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">                    log.error(<span class="string">"exception"</span>, e);</span></span></span><br><span class="line"><span class="function"><span class="params">                &#125;</span></span></span><br><span class="line"><span class="function"><span class="params">            &#125;)</span>;</span></span><br><span class="line"><span class="function">        &#125;</span></span><br><span class="line"><span class="function">        <span class="title">executor</span>.<span class="title">shutdown</span><span class="params">()</span>;</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="title">private</span> <span class="title">static</span> <span class="title">void</span> <span class="title">race</span><span class="params">(int threadNum)</span> <span class="title">throws</span> <span class="title">Exception</span> &#123;</span></span><br><span class="line"><span class="function">        <span class="title">Thread</span>.<span class="title">sleep</span><span class="params">(<span class="number">1000</span>)</span>;</span></span><br><span class="line"><span class="function">        <span class="title">log</span>.<span class="title">info</span><span class="params">(<span class="string">"&#123;&#125; is ready"</span>, threadNum)</span>;</span></span><br><span class="line"><span class="function">        <span class="title">try</span> &#123;</span></span><br><span class="line"><span class="function">            //只等待2000<span class="title">ms</span>，之后的线程就会被抛弃了。</span></span><br><span class="line"><span class="function">            // 因线程的<span class="title">condition</span>改变为<span class="title">broken</span>（因超时而强行打破屏障继续执行）而产生了<span class="title">BrokenBarrierException</span>，</span></span><br><span class="line"><span class="function">            // 或因线程被中断而产生线程中断异常而产生的需要<span class="title">try-catch</span></span></span><br><span class="line"><span class="function">            <span class="title">barrier</span>.<span class="title">await</span><span class="params">(<span class="number">2000</span>, TimeUnit.MILLISECONDS)</span>;</span></span><br><span class="line"><span class="function">        &#125; <span class="title">catch</span> <span class="params">(Exception e)</span> &#123;</span></span><br><span class="line"><span class="function">            <span class="title">log</span>.<span class="title">warn</span><span class="params">(<span class="string">"BarrierException"</span>, e)</span>;</span></span><br><span class="line"><span class="function">        &#125;</span></span><br><span class="line"><span class="function">        <span class="title">log</span>.<span class="title">info</span><span class="params">(<span class="string">"&#123;&#125; continue"</span>, threadNum)</span>;</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><h5 id="运行结果部分截取"><a class="markdownIt-Anchor" href="#运行结果部分截取"></a> 运行结果：（部分截取）</h5><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">20</span>:<span class="number">45</span>:<span class="number">32.745</span> [pool-<span class="number">1</span>-thread-<span class="number">1</span>] INFO com<span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.aqs</span><span class="selector-class">.CyclicBarrierExample2</span> - <span class="number">0</span> is ready</span><br><span class="line"><span class="number">20</span>:<span class="number">45</span>:<span class="number">33.742</span> [pool-<span class="number">1</span>-thread-<span class="number">2</span>] INFO com<span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.aqs</span><span class="selector-class">.CyclicBarrierExample2</span> - <span class="number">1</span> is ready</span><br><span class="line"><span class="number">20</span>:<span class="number">45</span>:<span class="number">34.742</span> [pool-<span class="number">1</span>-thread-<span class="number">3</span>] INFO com<span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.aqs</span><span class="selector-class">.CyclicBarrierExample2</span> - <span class="number">2</span> is ready</span><br><span class="line"><span class="number">20</span>:<span class="number">45</span>:<span class="number">34.755</span> [pool-<span class="number">1</span>-thread-<span class="number">2</span>] WARN com<span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.aqs</span><span class="selector-class">.CyclicBarrierExample2</span> - BarrierException</span><br><span class="line">java<span class="selector-class">.util</span><span class="selector-class">.concurrent</span><span class="selector-class">.BrokenBarrierException</span>: null</span><br><span class="line">trueat java<span class="selector-class">.util</span><span class="selector-class">.concurrent</span><span class="selector-class">.CyclicBarrier</span><span class="selector-class">.dowait</span>(CyclicBarrier<span class="selector-class">.java</span>:<span class="number">250</span>)</span><br><span class="line">trueat java<span class="selector-class">.util</span><span class="selector-class">.concurrent</span><span class="selector-class">.CyclicBarrier</span><span class="selector-class">.await</span>(CyclicBarrier<span class="selector-class">.java</span>:<span class="number">435</span>)</span><br><span class="line">trueat com<span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.aqs</span><span class="selector-class">.CyclicBarrierExample2</span><span class="selector-class">.race</span>(CyclicBarrierExample2<span class="selector-class">.java</span>:<span class="number">40</span>)</span><br><span class="line">trueat com<span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.aqs</span><span class="selector-class">.CyclicBarrierExample2</span><span class="selector-class">.lambda</span><span class="variable">$main</span>$<span class="number">0</span>(CyclicBarrierExample2<span class="selector-class">.java</span>:<span class="number">24</span>)</span><br><span class="line">trueat java<span class="selector-class">.util</span><span class="selector-class">.concurrent</span><span class="selector-class">.ThreadPoolExecutor</span><span class="selector-class">.runWorker</span>(ThreadPoolExecutor<span class="selector-class">.java</span>:<span class="number">1149</span>)</span><br><span class="line">trueat java<span class="selector-class">.util</span><span class="selector-class">.concurrent</span><span class="selector-class">.ThreadPoolExecutor</span><span class="variable">$Worker</span>.run(ThreadPoolExecutor<span class="selector-class">.java</span>:<span class="number">624</span>)</span><br><span class="line">trueat java<span class="selector-class">.lang</span><span class="selector-class">.Thread</span><span class="selector-class">.run</span>(Thread<span class="selector-class">.java</span>:<span class="number">748</span>)</span><br><span class="line"><span class="number">20</span>:<span class="number">45</span>:<span class="number">34.755</span> [pool-<span class="number">1</span>-thread-<span class="number">3</span>] WARN com<span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.aqs</span><span class="selector-class">.CyclicBarrierExample2</span> - BarrierException</span><br><span class="line">java<span class="selector-class">.util</span><span class="selector-class">.concurrent</span><span class="selector-class">.BrokenBarrierException</span>: null</span><br><span class="line">trueat java<span class="selector-class">.util</span><span class="selector-class">.concurrent</span><span class="selector-class">.CyclicBarrier</span><span class="selector-class">.dowait</span>(CyclicBarrier<span class="selector-class">.java</span>:<span class="number">250</span>)</span><br><span class="line">trueat java<span class="selector-class">.util</span><span class="selector-class">.concurrent</span><span class="selector-class">.CyclicBarrier</span><span class="selector-class">.await</span>(CyclicBarrier<span class="selector-class">.java</span>:<span class="number">435</span>)</span><br><span class="line">trueat com<span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.aqs</span><span class="selector-class">.CyclicBarrierExample2</span><span class="selector-class">.race</span>(CyclicBarrierExample2<span class="selector-class">.java</span>:<span class="number">40</span>)</span><br><span class="line">trueat com<span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.aqs</span><span class="selector-class">.CyclicBarrierExample2</span><span class="selector-class">.lambda</span><span class="variable">$main</span>$<span class="number">0</span>(CyclicBarrierExample2<span class="selector-class">.java</span>:<span class="number">24</span>)</span><br><span class="line">trueat java<span class="selector-class">.util</span><span class="selector-class">.concurrent</span><span class="selector-class">.ThreadPoolExecutor</span><span class="selector-class">.runWorker</span>(ThreadPoolExecutor<span class="selector-class">.java</span>:<span class="number">1149</span>)</span><br><span class="line">trueat java<span class="selector-class">.util</span><span class="selector-class">.concurrent</span><span class="selector-class">.ThreadPoolExecutor</span><span class="variable">$Worker</span>.run(ThreadPoolExecutor<span class="selector-class">.java</span>:<span class="number">624</span>)</span><br><span class="line">trueat java<span class="selector-class">.lang</span><span class="selector-class">.Thread</span><span class="selector-class">.run</span>(Thread<span class="selector-class">.java</span>:<span class="number">748</span>)</span><br></pre></td></tr></table></figure><h4 id="演示例子-3"><a class="markdownIt-Anchor" href="#演示例子-3"></a> 演示例子-3</h4><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierExample3</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="regexp">//有参的构造函数，在dowait()方法执行时若存在则优先执行该Runnable指令再返</span></span><br><span class="line"><span class="regexp">    //</span> 回（该时执行不到打破屏障代码段），之后再打破屏障并继续执行后续操作。</span><br><span class="line">    private static CyclicBarrier barrier = <span class="keyword">new</span> CyclicBarrier<span class="function"><span class="params">(<span class="number">5</span>, () -&gt; &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">        log.info(<span class="string">"callback is running"</span>);</span></span></span><br><span class="line"><span class="function"><span class="params">    &#125;)</span>;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="title">public</span> <span class="title">static</span> <span class="title">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="title">throws</span> <span class="title">Exception</span> &#123;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">        <span class="title">ExecutorService</span> <span class="title">executor</span> = <span class="title">Executors</span>.<span class="title">newCachedThreadPool</span><span class="params">()</span>;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">        <span class="title">for</span> <span class="params">(int i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span> &#123;</span></span><br><span class="line"><span class="function">            <span class="title">final</span> <span class="title">int</span> <span class="title">threadNum</span> = <span class="title">i</span>;</span></span><br><span class="line"><span class="function">            <span class="title">Thread</span>.<span class="title">sleep</span><span class="params">(<span class="number">1000</span>)</span>;</span></span><br><span class="line"><span class="function">            <span class="title">executor</span>.<span class="title">execute</span><span class="params">(() -&gt; &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">try</span> &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">                    race(threadNum);</span></span></span><br><span class="line"><span class="function"><span class="params">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">                    log.error(<span class="string">"exception"</span>, e);</span></span></span><br><span class="line"><span class="function"><span class="params">                &#125;</span></span></span><br><span class="line"><span class="function"><span class="params">            &#125;)</span>;</span></span><br><span class="line"><span class="function">        &#125;</span></span><br><span class="line"><span class="function">        <span class="title">executor</span>.<span class="title">shutdown</span><span class="params">()</span>;</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="title">private</span> <span class="title">static</span> <span class="title">void</span> <span class="title">race</span><span class="params">(int threadNum)</span> <span class="title">throws</span> <span class="title">Exception</span> &#123;</span></span><br><span class="line"><span class="function">        <span class="title">Thread</span>.<span class="title">sleep</span><span class="params">(<span class="number">1000</span>)</span>;</span></span><br><span class="line"><span class="function">        <span class="title">log</span>.<span class="title">info</span><span class="params">(<span class="string">"&#123;&#125; is ready"</span>, threadNum)</span>;</span></span><br><span class="line"><span class="function">        <span class="title">barrier</span>.<span class="title">await</span><span class="params">()</span>;</span></span><br><span class="line"><span class="function">        <span class="title">log</span>.<span class="title">info</span><span class="params">(<span class="string">"&#123;&#125; continue"</span>, threadNum)</span>;</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><h5 id="运行结果截取部分"><a class="markdownIt-Anchor" href="#运行结果截取部分"></a> 运行结果：（截取部分）</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">20<span class="selector-pseudo">:48</span><span class="selector-pseudo">:26.018</span> <span class="selector-attr">[pool-1-thread-1]</span> <span class="selector-tag">INFO</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.aqs</span><span class="selector-class">.CyclicBarrierExample3</span> <span class="selector-tag">-</span> 0 <span class="selector-tag">is</span> <span class="selector-tag">ready</span></span><br><span class="line">20<span class="selector-pseudo">:48</span><span class="selector-pseudo">:27.015</span> <span class="selector-attr">[pool-1-thread-2]</span> <span class="selector-tag">INFO</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.aqs</span><span class="selector-class">.CyclicBarrierExample3</span> <span class="selector-tag">-</span> 1 <span class="selector-tag">is</span> <span class="selector-tag">ready</span></span><br><span class="line">20<span class="selector-pseudo">:48</span><span class="selector-pseudo">:28.015</span> <span class="selector-attr">[pool-1-thread-3]</span> <span class="selector-tag">INFO</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.aqs</span><span class="selector-class">.CyclicBarrierExample3</span> <span class="selector-tag">-</span> 2 <span class="selector-tag">is</span> <span class="selector-tag">ready</span></span><br><span class="line">20<span class="selector-pseudo">:48</span><span class="selector-pseudo">:29.015</span> <span class="selector-attr">[pool-1-thread-4]</span> <span class="selector-tag">INFO</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.aqs</span><span class="selector-class">.CyclicBarrierExample3</span> <span class="selector-tag">-</span> 3 <span class="selector-tag">is</span> <span class="selector-tag">ready</span></span><br><span class="line">20<span class="selector-pseudo">:48</span><span class="selector-pseudo">:30.016</span> <span class="selector-attr">[pool-1-thread-5]</span> <span class="selector-tag">INFO</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.aqs</span><span class="selector-class">.CyclicBarrierExample3</span> <span class="selector-tag">-</span> 4 <span class="selector-tag">is</span> <span class="selector-tag">ready</span></span><br><span class="line">20<span class="selector-pseudo">:48</span><span class="selector-pseudo">:30.016</span> <span class="selector-attr">[pool-1-thread-5]</span> <span class="selector-tag">INFO</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.aqs</span><span class="selector-class">.CyclicBarrierExample3</span> <span class="selector-tag">-</span> <span class="selector-tag">callback</span> <span class="selector-tag">is</span> <span class="selector-tag">running</span></span><br><span class="line">20<span class="selector-pseudo">:48</span><span class="selector-pseudo">:30.016</span> <span class="selector-attr">[pool-1-thread-5]</span> <span class="selector-tag">INFO</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.aqs</span><span class="selector-class">.CyclicBarrierExample3</span> <span class="selector-tag">-</span> 4 <span class="selector-tag">continue</span></span><br><span class="line">20<span class="selector-pseudo">:48</span><span class="selector-pseudo">:30.016</span> <span class="selector-attr">[pool-1-thread-1]</span> <span class="selector-tag">INFO</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.aqs</span><span class="selector-class">.CyclicBarrierExample3</span> <span class="selector-tag">-</span> 0 <span class="selector-tag">continue</span></span><br><span class="line">20<span class="selector-pseudo">:48</span><span class="selector-pseudo">:30.016</span> <span class="selector-attr">[pool-1-thread-2]</span> <span class="selector-tag">INFO</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.aqs</span><span class="selector-class">.CyclicBarrierExample3</span> <span class="selector-tag">-</span> 1 <span class="selector-tag">continue</span></span><br><span class="line">20<span class="selector-pseudo">:48</span><span class="selector-pseudo">:30.016</span> <span class="selector-attr">[pool-1-thread-4]</span> <span class="selector-tag">INFO</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.aqs</span><span class="selector-class">.CyclicBarrierExample3</span> <span class="selector-tag">-</span> 3 <span class="selector-tag">continue</span></span><br><span class="line">20<span class="selector-pseudo">:48</span><span class="selector-pseudo">:30.016</span> <span class="selector-attr">[pool-1-thread-3]</span> <span class="selector-tag">INFO</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.aqs</span><span class="selector-class">.CyclicBarrierExample3</span> <span class="selector-tag">-</span> 2 <span class="selector-tag">continue</span></span><br><span class="line">20<span class="selector-pseudo">:48</span><span class="selector-pseudo">:31.016</span> <span class="selector-attr">[pool-1-thread-6]</span> <span class="selector-tag">INFO</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.aqs</span><span class="selector-class">.CyclicBarrierExample3</span> <span class="selector-tag">-</span> 5 <span class="selector-tag">is</span> <span class="selector-tag">ready</span></span><br><span class="line">20<span class="selector-pseudo">:48</span><span class="selector-pseudo">:32.017</span> <span class="selector-attr">[pool-1-thread-3]</span> <span class="selector-tag">INFO</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.aqs</span><span class="selector-class">.CyclicBarrierExample3</span> <span class="selector-tag">-</span> 6 <span class="selector-tag">is</span> <span class="selector-tag">ready</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;概述&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#概述&quot;&gt;&lt;/a&gt; 概述&lt;/h4&gt;
&lt;p&gt;CyclicBarrier也是JDK提供的辅助类。它允许一组线程相互等待，直到到达一个公共的屏障点（CommonBarrierPoint）。通过它可以使多个线程间相互等待，只有当每个线程都准备就绪后才能各自继续执行后面的操作。&lt;/p&gt;
    
    </summary>
    
      <category term="Java之并发编程" scheme="http://suprisemf.github.io/categories/Java%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java" scheme="http://suprisemf.github.io/tags/Java/"/>
    
      <category term="并发编程" scheme="http://suprisemf.github.io/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>J.U.C之AQS—Semaphore</title>
    <link href="http://suprisemf.github.io/2018/08/02/J-U-C%E4%B9%8BAQS%E2%80%94Semaphore/"/>
    <id>http://suprisemf.github.io/2018/08/02/J-U-C之AQS—Semaphore/</id>
    <published>2018-08-02T15:49:58.000Z</published>
    <updated>2018-08-02T15:51:08.771Z</updated>
    
    <content type="html"><![CDATA[<h4 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h4><p>Semaphore字面意思就是信号量。它通过提供同步机制，控制资源可同时被并发访问的线程的个数。当信号量限定为1时，它就和单线程很相似了。Semaphore和CountDownLatch的使用有些相似，其中也有两个核心实现方法：acquire()和release()。</p><blockquote><p>通过semaphore可以实现有限结点个数的链表，虽然可重入锁reentrant也可以实现，但是semaphore的实现更为简单。</p></blockquote><a id="more"></a><hr><h4 id="使用场景"><a class="markdownIt-Anchor" href="#使用场景"></a> 使用场景</h4><p>常适用于仅能提供有限资源访问的场景。<br>如：数据库链接数远远小于上层应用业务并发的数量，如果不对数据库的访问进行控制，很容易出现因有些线程因无法获取到数据库链接而导致的异常。</p><h4 id="例子演示"><a class="markdownIt-Anchor" href="#例子演示"></a> 例子演示</h4><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreExample1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> threadCount = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">2</span>);<span class="comment">//信号量声明</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> threadNum = i;</span><br><span class="line">            exec.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();<span class="comment">//信号量获取</span></span><br><span class="line">                    test(threadNum);</span><br><span class="line">                    semaphore.release();<span class="comment">//信号量释放</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.<span class="keyword">error</span>(<span class="string">"exception"</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> threadNum)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        log.info(<span class="string">"&#123;&#125;"</span>, threadNum);</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">14<span class="selector-pseudo">:00</span><span class="selector-pseudo">:22.444</span> <span class="selector-attr">[pool-1-thread-2]</span> <span class="selector-tag">INFO</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.aqs</span><span class="selector-class">.SemaphoreExample1</span> <span class="selector-tag">-</span> 1</span><br><span class="line">14<span class="selector-pseudo">:00</span><span class="selector-pseudo">:22.444</span> <span class="selector-attr">[pool-1-thread-1]</span> <span class="selector-tag">INFO</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.aqs</span><span class="selector-class">.SemaphoreExample1</span> <span class="selector-tag">-</span> 0</span><br><span class="line">14<span class="selector-pseudo">:00</span><span class="selector-pseudo">:23.451</span> <span class="selector-attr">[pool-1-thread-3]</span> <span class="selector-tag">INFO</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.aqs</span><span class="selector-class">.SemaphoreExample1</span> <span class="selector-tag">-</span> 2</span><br><span class="line">14<span class="selector-pseudo">:00</span><span class="selector-pseudo">:23.451</span> <span class="selector-attr">[pool-1-thread-4]</span> <span class="selector-tag">INFO</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.aqs</span><span class="selector-class">.SemaphoreExample1</span> <span class="selector-tag">-</span> 3</span><br><span class="line">14<span class="selector-pseudo">:00</span><span class="selector-pseudo">:24.452</span> <span class="selector-attr">[pool-1-thread-5]</span> <span class="selector-tag">INFO</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.aqs</span><span class="selector-class">.SemaphoreExample1</span> <span class="selector-tag">-</span> 4</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">Process</span> <span class="selector-tag">finished</span> <span class="selector-tag">with</span> <span class="selector-tag">exit</span> <span class="selector-tag">code</span> 0</span><br></pre></td></tr></table></figure><p><strong>例子说明：</strong><br>仔细的童鞋应该已经根据运行结果发现了：相同的信号量的输出是在同一时刻的！这也就对应了semaphore的含义。semaphore的使用也十分简单，方法执行前声明并制定允许的并发访问的数量，并用semaphore.acquire()和semaphore.release()分别前后包裹着test()方法即可。</p><p><strong>看一下semaphore的源码：</strong></p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">acquire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> permits)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (permits &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    sync.acquireSharedInterruptibly(permits);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (permits &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    sync.releaseShared(permits);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实semaphore.acquire()和semaphore.release()都是可以制定获取/释放信号量的数量的。而且都是使用的sync的方法获取或释放。那再看一下sync是什么鬼？</p><blockquote><p>读者：等等！！你不是说只是看一看源码吗？看看就得了，怎么还一直分析起来了？<br>我：大爷，来都来了，不进去逛逛？</p></blockquote><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** All mechanics via AbstractQueuedSynchronizer subclass */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Sync</span> sync;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Synchronization implementation for semaphore.  Uses AQS state</span></span><br><span class="line"><span class="comment"> * to represent permits. Subclassed into fair and nonfair</span></span><br><span class="line"><span class="comment"> * versions.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">abstract</span> static <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">  xx省略一万字xx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sync是其中的内部类，semaphore果然是使用了AQS框架！！使用了AQS的state字段来实现信号量的允许值（state字段之前提到过）。还分为公平和非公平两个版本！！</p><p><strong>那sync的方法是怎么实现的呢？</strong> 再看看源码：</p><blockquote><p>读者：公子！停停停！STOP!别看了，我有点恶心了~<br>我：emmm？我裤子都脱了，你让我停？</p></blockquote><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> acquireSharedInterruptibly(<span class="keyword">int</span> arg)</span><br><span class="line">        <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> doAcquireSharedInterruptibly(<span class="keyword">int</span> arg)</span><br><span class="line">    <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="function"><span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Ensure that a release propagates, even if there are other</span></span><br><span class="line"><span class="comment">     * in-progress acquires/releases.  This proceeds in the usual</span></span><br><span class="line"><span class="comment">     * way of trying to unparkSuccessor of head if it needs</span></span><br><span class="line"><span class="comment">     * signal. But if it does not, status is set to PROPAGATE to</span></span><br><span class="line"><span class="comment">     * ensure that upon release, propagation continues.</span></span><br><span class="line"><span class="comment">     * Additionally, we must loop in case a new node is added</span></span><br><span class="line"><span class="comment">     * while we are doing this. Also, unlike other uses of</span></span><br><span class="line"><span class="comment">     * unparkSuccessor, we need to know if CAS to reset status</span></span><br><span class="line"><span class="comment">     * fails, if so rechecking.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * CAS waitStatus field of a node.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> compareAndSetWaitStatus(Node node,</span><br><span class="line">                                                     <span class="keyword">int</span> expect,</span><br><span class="line">                                                     <span class="keyword">int</span> update) &#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(node, waitStatusOffset,</span><br><span class="line">                                    expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>hasQueuedPredecessors()</strong></p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public final boolean hasQueuedPredecessors() &#123;</span><br><span class="line">    // The correctness of this depends on head being initialized</span><br><span class="line">    // before tail <span class="keyword">and</span> on head.next being accurate if the current</span><br><span class="line">    // thread is first <span class="keyword">in</span> queue.</span><br><span class="line">    <span class="keyword">Node</span> <span class="title">t</span> = tail; // <span class="keyword">Read</span> fields <span class="keyword">in</span> reverse initialization order</span><br><span class="line">    <span class="keyword">Node</span> <span class="title">h</span> = head;</span><br><span class="line">    <span class="keyword">Node</span> <span class="title">s</span>;</span><br><span class="line">    return h != t &amp;&amp;</span><br><span class="line">        ((s = h.next) == null || s.thread != Thread.currentThread());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>读者：公子！咱们走吧，咱不看了吧~<br>我：呕~ 呕呕呕~~扶我起来，我还能…（话音未落，倒地身亡~）</p></blockquote><p>在<code>acquire()</code>中，调用<code>sync</code>的<code>acquireSharedInterruptibly()</code>其中指定参数（默认为1）：在共享模式中获取，首先检查线程状态，再至少调用一次<code>tryAcquireShared()</code>查询判断当前对象的<code>state</code>允许在共享模式中被获取，不允许则执行<code>doAcquireSharedInterruptibly(args)</code>，其中调用<code>addWaiter(Node.SHARED)</code>（参数指明为在共享模式下）进行声明：添加等待获取的结点，并循环遍历当前等待结点的前一结点，如果是<code>head</code>结点且此时再次查询当前对象的<code>state</code>允许在共享模式中被获取，那么设置队列的<code>head</code>并检查是否成功的对象正处于队列中，若是则传递消息以尝试给下一个队列结点传信号。如果不是<code>head</code>结点则调用<code>cancelAcquire(node)</code>，取消获取信号量。</p><p>在<code>release()</code>中，当参数存在时，调用<code>sync.releaseShared(permits)</code>，再调用<code>tryReleaseShared(args)</code>查询是否允许释放，若是则调用<code>doReleaseShared()</code>：即使有其他进行中的请求/释放信号量的进程，也要确保释放的消息传递，循环遍历以防止在这个过程中有新的结点加入；一般释放信号量的过程是当<code>head</code>需要信号量时，尝试释放head的继承结点。由于结合了CAS，需循环是否CAS重置状态失败了，若是则重新检查。</p><h4 id="如果并发数太多了但是资源还有限这时候怎么搞"><a class="markdownIt-Anchor" href="#如果并发数太多了但是资源还有限这时候怎么搞"></a> 如果并发数太多了，但是资源还有限，这时候怎么搞？</h4><p>semaphore还有一个叫做tryAcquire的方法。<br>看下例子：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreExample3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> threadCount = <span class="number">2000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> threadNum = i;</span><br><span class="line">            exec.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (semaphore.tryAcquire()) &#123; <span class="comment">// 尝试获取一个许可</span></span><br><span class="line">                        test(threadNum);</span><br><span class="line">                        semaphore.release(); <span class="comment">// 释放一个许可</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.<span class="keyword">error</span>(<span class="string">"exception"</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> threadNum)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        log.info(<span class="string">"&#123;&#125;"</span>, threadNum);</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">16<span class="selector-pseudo">:00</span><span class="selector-pseudo">:49.454</span> <span class="selector-attr">[pool-1-thread-2]</span> <span class="selector-tag">INFO</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.aqs</span><span class="selector-class">.SemaphoreExample3</span> <span class="selector-tag">-</span> 1</span><br><span class="line">16<span class="selector-pseudo">:00</span><span class="selector-pseudo">:49.455</span> <span class="selector-attr">[pool-1-thread-3]</span> <span class="selector-tag">INFO</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.aqs</span><span class="selector-class">.SemaphoreExample3</span> <span class="selector-tag">-</span> 2</span><br><span class="line">16<span class="selector-pseudo">:00</span><span class="selector-pseudo">:49.453</span> <span class="selector-attr">[pool-1-thread-1]</span> <span class="selector-tag">INFO</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.aqs</span><span class="selector-class">.SemaphoreExample3</span> <span class="selector-tag">-</span> 0</span><br></pre></td></tr></table></figure><p>为什么只有三个线程执行了测试方法？是不是测试方法中的线程休眠时间太长了？现在改成500ms。</p><p>再次运行：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">16<span class="selector-pseudo">:03</span><span class="selector-pseudo">:13.925</span> <span class="selector-attr">[pool-1-thread-1]</span> <span class="selector-tag">INFO</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.aqs</span><span class="selector-class">.SemaphoreExample3</span> <span class="selector-tag">-</span> 0</span><br><span class="line">16<span class="selector-pseudo">:03</span><span class="selector-pseudo">:13.944</span> <span class="selector-attr">[pool-1-thread-2]</span> <span class="selector-tag">INFO</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.aqs</span><span class="selector-class">.SemaphoreExample3</span> <span class="selector-tag">-</span> 1</span><br><span class="line">16<span class="selector-pseudo">:03</span><span class="selector-pseudo">:13.945</span> <span class="selector-attr">[pool-1-thread-3]</span> <span class="selector-tag">INFO</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.aqs</span><span class="selector-class">.SemaphoreExample3</span> <span class="selector-tag">-</span> 2</span><br></pre></td></tr></table></figure><p>再改小一些：==&gt;Thread.sleep(10)</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">16<span class="selector-pseudo">:04</span><span class="selector-pseudo">:12.730</span> <span class="selector-attr">[pool-1-thread-4]</span> <span class="selector-tag">INFO</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.aqs</span><span class="selector-class">.SemaphoreExample3</span> <span class="selector-tag">-</span> 1279</span><br><span class="line">16<span class="selector-pseudo">:04</span><span class="selector-pseudo">:12.730</span> <span class="selector-attr">[pool-1-thread-5]</span> <span class="selector-tag">INFO</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.aqs</span><span class="selector-class">.SemaphoreExample3</span> <span class="selector-tag">-</span> 1278</span><br><span class="line">16<span class="selector-pseudo">:04</span><span class="selector-pseudo">:12.742</span> <span class="selector-attr">[pool-1-thread-10]</span> <span class="selector-tag">INFO</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.aqs</span><span class="selector-class">.SemaphoreExample3</span> <span class="selector-tag">-</span> 9</span><br><span class="line">16<span class="selector-pseudo">:04</span><span class="selector-pseudo">:12.744</span> <span class="selector-attr">[pool-1-thread-11]</span> <span class="selector-tag">INFO</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.aqs</span><span class="selector-class">.SemaphoreExample3</span> <span class="selector-tag">-</span> 10</span><br><span class="line">16<span class="selector-pseudo">:04</span><span class="selector-pseudo">:12.744</span> <span class="selector-attr">[pool-1-thread-12]</span> <span class="selector-tag">INFO</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.aqs</span><span class="selector-class">.SemaphoreExample3</span> <span class="selector-tag">-</span> 11</span><br><span class="line">16<span class="selector-pseudo">:04</span><span class="selector-pseudo">:12.753</span> <span class="selector-attr">[pool-1-thread-49]</span> <span class="selector-tag">INFO</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.aqs</span><span class="selector-class">.SemaphoreExample3</span> <span class="selector-tag">-</span> 75</span><br><span class="line">16<span class="selector-pseudo">:04</span><span class="selector-pseudo">:12.755</span> <span class="selector-attr">[pool-1-thread-60]</span> <span class="selector-tag">INFO</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.aqs</span><span class="selector-class">.SemaphoreExample3</span> <span class="selector-tag">-</span> 102</span><br><span class="line">16<span class="selector-pseudo">:04</span><span class="selector-pseudo">:12.755</span> <span class="selector-attr">[pool-1-thread-62]</span> <span class="selector-tag">INFO</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.aqs</span><span class="selector-class">.SemaphoreExample3</span> <span class="selector-tag">-</span> 106</span><br></pre></td></tr></table></figure><p>其中只截取了一部分，总共应该有45个左右线程执行了。</p><p>我再改一下，去掉线程休眠，看看能不能全部2000个线程都执行测试方法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">16<span class="selector-pseudo">:07</span><span class="selector-pseudo">:21.873</span> <span class="selector-attr">[pool-1-thread-1]</span> <span class="selector-tag">INFO</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.aqs</span><span class="selector-class">.SemaphoreExample3</span> <span class="selector-tag">-</span> 1860</span><br><span class="line">16<span class="selector-pseudo">:07</span><span class="selector-pseudo">:21.873</span> <span class="selector-attr">[pool-1-thread-66]</span> <span class="selector-tag">INFO</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.aqs</span><span class="selector-class">.SemaphoreExample3</span> <span class="selector-tag">-</span> 1856</span><br><span class="line">16<span class="selector-pseudo">:07</span><span class="selector-pseudo">:21.873</span> <span class="selector-attr">[pool-1-thread-2]</span> <span class="selector-tag">INFO</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.aqs</span><span class="selector-class">.SemaphoreExample3</span> <span class="selector-tag">-</span> 1889</span><br><span class="line">16<span class="selector-pseudo">:07</span><span class="selector-pseudo">:21.873</span> <span class="selector-attr">[pool-1-thread-9]</span> <span class="selector-tag">INFO</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.aqs</span><span class="selector-class">.SemaphoreExample3</span> <span class="selector-tag">-</span> 1886</span><br><span class="line">16<span class="selector-pseudo">:07</span><span class="selector-pseudo">:21.873</span> <span class="selector-attr">[pool-1-thread-10]</span> <span class="selector-tag">INFO</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.aqs</span><span class="selector-class">.SemaphoreExample3</span> <span class="selector-tag">-</span> 1888</span><br></pre></td></tr></table></figure><p>在结果中截取了部分，并且只找到了最大的线程数为1889，即当线程不休眠时，有1900个线程执行了测试方法，即90%的线程可以得到运行。</p><p>既然测试了该方法，那就看看它的源码吧：</p><blockquote><p>读者君：(～﹃～)~zZ 啊？啊啊？？现在几点了？<br>我：坐正，抬头挺胸！小手放背后！（敲黑板）</p></blockquote><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Acquires a permit <span class="keyword">from</span> this semaphore, only <span class="keyword">if</span> one <span class="keyword">is</span> available <span class="keyword">at</span> <span class="keyword">the</span></span><br><span class="line"> * <span class="built_in">time</span> <span class="keyword">of</span> invocation.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;Acquires a permit, <span class="keyword">if</span> one <span class="keyword">is</span> available <span class="keyword">and</span> returns immediately,</span><br><span class="line"> * <span class="keyword">with</span> <span class="keyword">the</span> value &#123;@code <span class="literal">true</span>&#125;,</span><br><span class="line"> * reducing <span class="keyword">the</span> <span class="built_in">number</span> <span class="keyword">of</span> available permits <span class="keyword">by</span> one.</span><br><span class="line"> */</span><br><span class="line">public <span class="built_in">boolean</span> tryAcquire() &#123;</span><br><span class="line"><span class="built_in">    return</span> sync.nonfairTryAcquireShared(<span class="number">1</span>) &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final int nonfairTryAcquireShared(int acquires) &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        int available = getState();</span><br><span class="line">        int remaining = available - acquires;</span><br><span class="line">        <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">            compareAndSetState(available, remaining))</span><br><span class="line"><span class="built_in">            return</span> remaining;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实tryAcquire()还可以指定超时时间：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">boolean</span> tryAcquire(<span class="keyword">long</span> timeout, TimeUnit unit)</span><br><span class="line">    <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">return</span> sync.tryAcquireSharedNanos(<span class="number">1</span>, unit.toNanos(timeout));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> tryAcquireSharedNanos(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span><br><span class="line">        <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">return</span> tryAcquireShared(arg) &gt;= <span class="number">0</span> ||</span><br><span class="line">        doAcquireSharedNanos(arg, nanosTimeout);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> doAcquireSharedNanos(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span><br><span class="line">        <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0</span>L)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> deadline = System.nanoTime() + nanosTimeout;</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            nanosTimeout = deadline - System.nanoTime();</span><br><span class="line">            <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0</span>L)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                nanosTimeout &gt; spinForTimeoutThreshold)</span><br><span class="line">                LockSupport.parkNanos(<span class="keyword">this</span>, nanosTimeout);</span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>例子就不演示了，通过指定时间，准确指定可以并发请求的数量，大大减轻了控制的操作。再配合在核心方法中修改线程休眠时间来控制线程并发访问数量，最少的数量是semaphore和并发请求中的最小值（但一般情况下还是semaphore小，即最小是semaphore声明值）</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;概述&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#概述&quot;&gt;&lt;/a&gt; 概述&lt;/h4&gt;
&lt;p&gt;Semaphore字面意思就是信号量。它通过提供同步机制，控制资源可同时被并发访问的线程的个数。当信号量限定为1时，它就和单线程很相似了。Semaphore和CountDownLatch的使用有些相似，其中也有两个核心实现方法：acquire()和release()。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;通过semaphore可以实现有限结点个数的链表，虽然可重入锁reentrant也可以实现，但是semaphore的实现更为简单。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Java之并发编程" scheme="http://suprisemf.github.io/categories/Java%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java" scheme="http://suprisemf.github.io/tags/Java/"/>
    
      <category term="并发编程" scheme="http://suprisemf.github.io/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>J.U.C之AQS—CountDownLatch</title>
    <link href="http://suprisemf.github.io/2018/08/02/J-U-C%E4%B9%8BAQS%E2%80%94CountDownLatch/"/>
    <id>http://suprisemf.github.io/2018/08/02/J-U-C之AQS—CountDownLatch/</id>
    <published>2018-08-02T11:48:25.000Z</published>
    <updated>2018-08-02T12:02:27.463Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h3><p>它是一个同步辅助类，通过它可以在一个线程（线程间会轮换）执行countdown() -&gt; count值减至0的期间，保证其他线程会调用await()一直阻塞等待，最后等待的线程执行resume()，所有线程再一起执行另一个实务操作。其中有一个原子性的且不会被重置的计数器以保证上述的实现。</p><a id="more"></a><p>原理图如下：<br><img src="/2018/08/02/J-U-C之AQS—CountDownLatch/J-U-C%E4%B9%8BAQS%E2%80%94CountDownLatch/CountDownLatch%E7%B1%BB.png" alt="图示"></p><h3 id="使用场景"><a class="markdownIt-Anchor" href="#使用场景"></a> 使用场景</h3><p>当一个程序需在另一个条件完成后才可以继续执行后续操作。<br>如：并行计算中最后的汇总操作场</p><h3 id="例子演示"><a class="markdownIt-Anchor" href="#例子演示"></a> 例子演示</h3><h4 id="情景一指定计数次数"><a class="markdownIt-Anchor" href="#情景一指定计数次数"></a> 情景一：指定计数次数</h4><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchExample1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> threadCount = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(threadCount);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> threadNum = i;</span><br><span class="line">            exec.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    test(threadNum);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.<span class="keyword">error</span>(<span class="string">"exception"</span>, e);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">//保证了方法被调用即计数执行减一</span></span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        log.info(<span class="string">"finish"</span>);</span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> threadNum)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        log.info(<span class="string">"&#123;&#125;"</span>, threadNum);</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果：</strong>（截取部分）</p><p><img src="/2018/08/02/J-U-C之AQS—CountDownLatch/J-U-C%E4%B9%8BAQS%E2%80%94CountDownLatch/countdownlatch%E6%B5%8B%E8%AF%95.png" alt="图示"></p><p>根据结果，多线程并发期间，核心方法以乱序执行，但总数仍一定，且最后执行到测试语句“finish”。其中，countDownLatch.await()语句循环检查计数是否已经减为0，即保证了此时全部线程执行结束。</p><h4 id="情景二指定计数时间"><a class="markdownIt-Anchor" href="#情景二指定计数时间"></a> 情景二：指定计数时间</h4><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchExample2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> threadCount = <span class="number">2000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(threadCount);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> threadNum = i;</span><br><span class="line">            exec.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    test(threadNum);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.<span class="keyword">error</span>(<span class="string">"exception"</span>, e);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await(<span class="number">3</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">        log.info(<span class="string">"finish"</span>);</span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> threadNum)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        log.info(<span class="string">"&#123;&#125;"</span>, threadNum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试结果：</strong></p><p><img src="/2018/08/02/J-U-C之AQS—CountDownLatch/J-U-C%E4%B9%8BAQS%E2%80%94CountDownLatch/countdownlatch%E6%B5%8B%E8%AF%952.png" alt="图示"></p><p>先来看一下await()的源码：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public void await() throws InterruptedException &#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Causes <span class="keyword">the</span> current thread <span class="keyword">to</span> wait <span class="keyword">until</span> <span class="keyword">the</span> latch has counted down <span class="keyword">to</span></span><br><span class="line"> * zero, unless <span class="keyword">the</span> thread <span class="keyword">is</span> &#123;@linkplain Thread<span class="comment">#interrupt interrupted&#125;,</span></span><br><span class="line"> * <span class="keyword">or</span> <span class="keyword">the</span> specified waiting <span class="built_in">time</span> elapses.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;If <span class="keyword">the</span> current <span class="built_in">count</span> <span class="keyword">is</span> zero <span class="keyword">then</span> this method returns immediately</span><br><span class="line"> * <span class="keyword">with</span> <span class="keyword">the</span> value &#123;@code <span class="literal">true</span>&#125;.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;If <span class="keyword">the</span> current <span class="built_in">count</span> <span class="keyword">is</span> <span class="keyword">greater than</span> zero <span class="keyword">then</span> <span class="keyword">the</span> current</span><br><span class="line"> * thread becomes disabled <span class="keyword">for</span> thread scheduling purposes <span class="keyword">and</span> lies</span><br><span class="line"> * dormant <span class="keyword">until</span> one <span class="keyword">of</span> three things happen:</span><br><span class="line"> * &lt;ul&gt;</span><br><span class="line"> * &lt;li&gt;The <span class="built_in">count</span> reaches zero due <span class="keyword">to</span> invocations <span class="keyword">of</span> <span class="keyword">the</span></span><br><span class="line"> * &#123;@link <span class="comment">#countDown&#125; method; or</span></span><br><span class="line"> * &lt;li&gt;Some other thread &#123;@linkplain Thread<span class="comment">#interrupt interrupts&#125;</span></span><br><span class="line"> * <span class="keyword">the</span> current thread; <span class="keyword">or</span></span><br><span class="line"> * &lt;li&gt;The specified waiting <span class="built_in">time</span> elapses.</span><br><span class="line"> * &lt;/ul&gt;</span><br><span class="line"> */</span><br><span class="line">public <span class="built_in">boolean</span> await(long <span class="keyword">timeout</span>, TimeUnit unit)</span><br><span class="line">    throws InterruptedException &#123;</span><br><span class="line"><span class="built_in">    return</span> sync.tryAcquireSharedNanos(<span class="number">1</span>, unit.toNanos(<span class="keyword">timeout</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>countDownLatch.await(3, TimeUnit.MILLISECONDS)</code>方法，指定<code>timeout</code>参数实现。其中，该参数指的是在<code>test</code>方法执行时开始计数，延时<code>timeout</code>的时间后<strong>或</strong>计数已经减为0后，继续执行后续方法，此例为<code>log.info(&quot;finish&quot;)</code>，即输出<code>finish</code>。<br>而无参的await()方法只有计数到0时才会继续执行后续方法。</p><p><strong>结果分析：</strong><br>例子中为了测试timeout，将timeout设置为1ms，而线程执行核心方法时设定休眠100ms，那么与结果是正好对应的，即finish总是第一个被输出的日志。</p><p><strong>但是，finish输出后就直接执行了exec.shutdown()即关闭线程池的操作了啊，怎么还会有线程日志输出？</strong></p><p>其实，exec.shutdown()操作：不会再接受新的线程任务，只会等待当前已经分配的线程执行完操作后再关闭，而不是在第一时间销毁所有的线程并强制关闭线程池。<strong>但是线程池还有一个立即关闭的线程池的方法 -&gt; 在第一时间销毁所有的线程并强制关闭线程池，即shutdownNow()。</strong></p><p>现在修改shutdown()为shutdownNow()，再进行测试，运行结果为：（部分截图）</p><p><img src="/2018/08/02/J-U-C之AQS—CountDownLatch/J-U-C%E4%B9%8BAQS%E2%80%94CountDownLatch/shutdownNow%E6%B5%8B%E8%AF%95.png" alt="图示"></p><p><strong>结果分析：</strong><br>finish日志字段输出和其后200个<code>exception java.lang.InterruptedException: sleep interrupted</code>异常说明了测试的正确性。也是对应了上面await()源代码中的说明：<code>unless the thread is {@linkplain Thread#interrupt interrupted}</code>。</p><h3 id="小总结"><a class="markdownIt-Anchor" href="#小总结"></a> 小总结</h3><p>使用CountDownLatch中，最好是计数指定配合指定超时时间使用，避免计数因为意外的情况难以到达使得系统资源空耗或业务逻辑无法继续执行情况，以提高程序的高效性，实用性。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概述&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#概述&quot;&gt;&lt;/a&gt; 概述&lt;/h3&gt;
&lt;p&gt;它是一个同步辅助类，通过它可以在一个线程（线程间会轮换）执行countdown() -&amp;gt; count值减至0的期间，保证其他线程会调用await()一直阻塞等待，最后等待的线程执行resume()，所有线程再一起执行另一个实务操作。其中有一个原子性的且不会被重置的计数器以保证上述的实现。&lt;/p&gt;
    
    </summary>
    
      <category term="Java之并发编程" scheme="http://suprisemf.github.io/categories/Java%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java" scheme="http://suprisemf.github.io/tags/Java/"/>
    
      <category term="并发编程" scheme="http://suprisemf.github.io/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>AQS介绍</title>
    <link href="http://suprisemf.github.io/2018/08/02/AQS%E4%BB%8B%E7%BB%8D/"/>
    <id>http://suprisemf.github.io/2018/08/02/AQS介绍/</id>
    <published>2018-08-02T11:37:15.000Z</published>
    <updated>2018-08-02T11:45:03.172Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h3><p>AQS是J.U.C中的一个非常重要的类。<br>J.U.C是java.util.concurrent的首字母简称。而AQS是J.U.C下locks包的一个抽象类。</p><a id="more"></a><hr><p><strong>废话不多说，看一下类顶注释：</strong>（其中只截取了概述部分，并直接翻译一下,纯手翻，有些机械翻译，但能看懂）</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">/ *<span class="strong">*</span></span><br><span class="line"><span class="strong"> *</span>提供实现阻塞锁和相关的框架</span><br><span class="line"> <span class="strong">*依赖的同步器（信号量，事件等）</span></span><br><span class="line"><span class="strong"> *</span>先进先出（FIFO）等待队列。该类旨在为</span><br><span class="line"> <span class="strong">*大多数依赖于单独具有原子性值去展现状态的</span></span><br><span class="line"><span class="strong"> *</span>同步器提供有用基础内容。子类</span><br><span class="line"> <span class="strong">*必须定义更改此状态的受保护方法，以及哪些方法</span></span><br><span class="line"><span class="strong"> *</span>根据被获取的对象定义该状态的含义</span><br><span class="line"> <span class="strong">*或发布。鉴于这些，该类中的其他方法都会</span></span><br><span class="line"><span class="strong"> *</span>执行所有排队和阻塞方法。子类可以维护</span><br><span class="line"> <span class="strong">*其他声明字段，但只有原子性的更新&#123;@code int&#125;值</span></span><br><span class="line"><span class="strong"> *</span>被操纵使用方法&#123;@link #getState&#125;，&#123;@ link</span><br><span class="line"> * #setState&#125;和&#123;@link #compareAndSetState&#125;因为同步机制而被跟踪。</span><br><span class="line"> <span class="strong">*</span></span><br><span class="line"><span class="strong"> *</span></span><br><span class="line"> * &lt;p&gt;子类应被定义为非公共内部帮助类</span><br><span class="line"> <span class="strong">*以用于实现他们封闭类的同步属性。</span></span><br><span class="line"><span class="strong"> *</span> 类&#123;@code AbstractQueuedSynchronizer&#125;没有实现任何</span><br><span class="line"> <span class="strong">*同步接口。相反，它定义了许多方法，例如</span></span><br><span class="line"><span class="strong"> *</span> &#123;@link #acquireInterruptibly&#125;它可以被相关锁或同步器适当地调用</span><br><span class="line"> <span class="strong">*去实现他们的public方法。</span></span><br><span class="line"><span class="strong"> *</span></span><br><span class="line"> * &lt;p&gt;此类支持其中之一或同时两者模式，包括默认的独占模式和一个共享模式。</span><br><span class="line"> <span class="strong">*当在独占模式中被获取时，</span></span><br><span class="line"><span class="strong"> *</span>通过其他线程的尝试获取是不会成功的。在共享模式中</span><br><span class="line"> <span class="strong">*多线程获取可能（但不一定）成功。这个类</span></span><br><span class="line"><span class="strong"> *</span>不会“理解”这些差异，除非在</span><br><span class="line"> <span class="strong">*方法层面，即当共享模式请求成功时，下一个</span></span><br><span class="line"><span class="strong"> *</span>等待线程（如果存在）也必须确定它是否可以</span><br><span class="line"> <span class="strong">*请求获取。在不同模式下等待的线程共享</span></span><br><span class="line"><span class="strong"> *</span>相同的FIFO队列。通常，实现子类仅支持</span><br><span class="line"> <span class="strong">*这些模式中的一种，但两者都可以在例如&#123;@link ReadWriteLock&#125;中发挥作用。</span></span><br><span class="line"><span class="strong"> *</span> 仅被独占模式或分享模式支持的子类</span><br><span class="line"> <span class="strong">*不需要定义支持未使用模式中的方法。</span></span><br><span class="line"><span class="strong"> *</span>/</span><br></pre></td></tr></table></figure><p><strong>看一下它都有哪些方法：</strong>（大多数见名知意）</p><p><img src="/2018/08/02/AQS介绍/AQS%E4%BB%8B%E7%BB%8D/AQS%E6%96%B9%E6%B3%95%E5%88%97%E8%A1%A8.png" alt="图示"></p><p><strong>再看一下它的底层实现：</strong></p><p><img src="/2018/08/02/AQS介绍/AQS%E4%BB%8B%E7%BB%8D/AQS%E4%B8%AD%E4%B8%A4%E4%B8%AA%E9%98%9F%E5%88%97.jpg" alt="图示"></p><p><strong>分析：</strong></p><ol><li>显然是使用双向列表，也是队列的一种。</li><li>上面的Sync queue是同步队列，实际是双向列表，其中的head节点主要用于后续的调度；</li><li>下面的Condition queue不是必须的，是一个单项列表；当使用到condition时才会用到此队列（可能会有多个）。</li></ol><hr><h4 id="aqs的设计注释中已提及此处做总结"><a class="markdownIt-Anchor" href="#aqs的设计注释中已提及此处做总结"></a> AQS的设计（注释中已提及，此处做总结。）</h4><ol><li>使用Node实现FIFO队列，可以用于构建锁或其他同步装置的基础框架。</li><li>使用int基础数据类型表示状态（state），在AQS的reentrant锁中state表示获取锁的线程数量。</li><li>通过继承并根据需要复写其中方法来使用该提供的框架。</li><li>子类通过继承并通过实现它的acquire和release等方法管理其状态。</li><li>可以同时实现独占锁和共享锁模式。它的子类不会同时使用两套API。即使是ReentrantReadWriteLock也是通过两个内部类读锁、写锁分别实现两套API来实现。</li></ol><hr><h4 id="关键内容"><a class="markdownIt-Anchor" href="#关键内容"></a> 关键内容</h4><p>AQS内部有一个等待队列，它是&quot;CLH&quot;锁队列的一个变种实现；CLH指的是Craig, Landin, and Hagersten这三个人的名字首字母拼装。（我猜是他们三个共同研究出的一种队列实现方式。）好吧真是个磨人的小妖精~再看一下源码中的说明。（只翻译了一部分，剩下的大家可以选择性地看看。）</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment"><span class="markdown">/**CLH锁通常用于</span></span></span><br><span class="line"><span class="comment"><span class="markdown">      *自旋锁。 我们现不将它们用作阻塞同步器，而是</span></span></span><br><span class="line"><span class="comment"><span class="markdown">      *使用该相同的策略：通过持有一些它上个线程中的结点的控制信息。</span></span></span><br><span class="line"><span class="comment"><span class="markdown">      *每个节点中的“status”字段跟踪是否有线程</span></span></span><br><span class="line"><span class="comment"><span class="markdown">      *应该阻塞。 结点在其上个线程释放时会发出信号</span></span></span><br><span class="line"><span class="comment"><span class="markdown">      *否则队列的每个节点通过持有一个等待的线程，成为一个</span></span></span><br><span class="line"><span class="comment"><span class="markdown">      *特定通知式监视器。</span></span></span><br><span class="line"><span class="comment"><span class="markdown">      *status字段虽然不控制线程是否被</span></span></span><br><span class="line"><span class="comment"><span class="markdown">      *授予锁等。 一个线程可能会尝试去获取锁，如果他是在队列中的第一个时。</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> *但当是第一个时，并不能保证成功;</span></span></span><br><span class="line"><span class="comment"><span class="markdown">      *它只给予线程去争取锁的权利。 所以现在被释放了锁的线程</span></span></span><br><span class="line"><span class="comment"><span class="markdown">      *可能需要重新等待。</span></span></span><br><span class="line"><span class="comment"><span class="markdown">     *</span></span></span><br><span class="line"><span class="comment"><span class="markdown">     * <span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span>要排队进入CLH锁，您需要原子性地将其拼接为一个新的tail。</span></span></span><br><span class="line"><span class="comment"><span class="markdown">     *  要出队列，您只需设置head（头部）字段即可。</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">*      </span>+------+  prev +-----+       +-----+</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span>head |      | <span class="xml"><span class="tag">&lt;<span class="name">----</span> |     | &lt;<span class="attr">----</span> |     |  <span class="attr">tail</span></span></span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">*      </span>+------+       +-----+       +-----+</span></span></span><br><span class="line"><span class="comment"><span class="markdown">*</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span><span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span>Insertion into </span>a<span class="markdown"> CLH queue requires only </span>a<span class="markdown"> single atomic</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span>operation on "tail", </span>so<span class="markdown"> there is </span>a<span class="markdown"> simple atomic point of</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span>demarcation from unqueued to queued. Similarly, dequeuing</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span>involves only updating </span>the<span class="markdown"> "head". However, it takes </span>a<span class="markdown"> bit</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span></span>more<span class="markdown"> work for nodes to determine who their successors </span>are<span class="markdown">,</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span>in part to deal with possible cancellation due to timeouts</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span>and interrupts.</span></span></span><br><span class="line"><span class="comment"><span class="markdown">*</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span><span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span>The "prev" links (not used in original CLH locks), </span>are<span class="markdown"> mainly</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span>needed to handle cancellation. If </span>a<span class="markdown"> node is cancelled, its</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span>successor is (normally) relinked to </span>a<span class="markdown"> non-cancelled</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span>predecessor. For explanation of similar mechanics in </span>the<span class="markdown"> case</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span>of spin locks, see </span>the<span class="markdown"> papers by Scott and Scherer at</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span>http://www.cs.rochester.edu/u/scott/synchronization/</span></span></span><br><span class="line"><span class="comment"><span class="markdown">*</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span><span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span>We also use "next" links to implement blocking mechanics.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span>The thread id for each node is kept in its own node, </span>so<span class="markdown"> </span>a<span class="markdown"></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span>predecessor signals </span>the<span class="markdown"> next node to wake up by traversing</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span>next link to determine which thread it is.  Determination of</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span>successor must avoid races with newly queued nodes to set</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span></span>the<span class="markdown"> "next" fields of their predecessors.  This is solved</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span>when necessary by checking backwards from </span>the<span class="markdown"> atomically</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span>updated "tail" when </span>a<span class="markdown"> node's successor appears to be null.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span>(Or, said differently, </span>the<span class="markdown"> next-links </span>are<span class="markdown"> </span>an<span class="markdown"> optimization</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span></span>so<span class="markdown"> that we </span>don't<span class="markdown"> usually need </span>a<span class="markdown"> backward scan.)</span></span></span><br><span class="line"><span class="comment"><span class="markdown">*</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span><span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span>Cancellation introduces some conservatism to </span>the<span class="markdown"> basic</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span>algorithms.  Since we must poll for cancellation of other</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span>nodes, we can miss noticing whether </span>a<span class="markdown"> cancelled node is</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span>ahead or behind us. This is dealt with by always unparking</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span>successors upon cancellation, allowing them to stabilize on</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span></span>a<span class="markdown"> new predecessor, unless we can identify </span>an<span class="markdown"> uncancelled</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span>predecessor who </span>will<span class="markdown"> carry this responsibility.</span></span></span><br><span class="line"><span class="comment"><span class="markdown">*</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span><span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span>CLH queues need </span>a<span class="markdown"> dummy header node to get started. But</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span>we </span>don't<span class="markdown"> create them on construction, because it would be wasted</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span>effort if there is never contention. Instead, </span>the<span class="markdown"> node</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span>is constructed and head and tail pointers </span>are<span class="markdown"> set upon first</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span>contention.</span></span></span><br><span class="line"><span class="comment"><span class="markdown">*</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span><span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span>Threads waiting on Conditions use </span>the<span class="markdown"> same nodes, </span>but<span class="markdown"></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span>use </span>an<span class="markdown"> additional link. Conditions only need to link nodes</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span>in simple (non-concurrent) linked queues because </span>they<span class="markdown"> </span>are<span class="markdown"></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span>only accessed when exclusively held.  Upon await, </span>a<span class="markdown"> node is</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span>inserted into </span>a<span class="markdown"> condition queue.  Upon signal, </span>the<span class="markdown"> node is</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span>transferred to </span>the<span class="markdown"> main queue.  A special value of status</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span>field is used to mark which queue </span>a<span class="markdown"> node is on.</span></span></span><br><span class="line"><span class="comment"><span class="markdown">*</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span><span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span>Thanks go to Dave Dice, Mark Moir, Victor Luchangco, Bill</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span>Scherer and Michael Scott, along with members of JSR-166</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span>expert group, for helpful ideas, discussions, and critiques</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span>on </span>the<span class="markdown"> design of this class.</span></span></span><br><span class="line"><span class="comment"><span class="markdown">*/</span></span></span><br></pre></td></tr></table></figure><blockquote><p><strong>小结：</strong> AQS内部维护一个CLH队列来管理锁，线程会首先尝试获取锁，如果获取失败，则将就将当前线程以及等待状态等信息包成一个Node结点，加入到同步队列SyncQueue中，当当前结点为head的直接后继时才会不断尝试继续获取锁。如果失败则会阻塞自己直至自己被唤醒。当持有锁的线程释放时，队列中的后继线程才会被唤醒。</p></blockquote><hr><h4 id="aqs的同步组件简介"><a class="markdownIt-Anchor" href="#aqs的同步组件简介"></a> AQS的同步组件简介</h4><blockquote><p>此处仅做组件的简单的提出，后续会有详细的手记说明。</p></blockquote><h5 id="countdownlatch"><a class="markdownIt-Anchor" href="#countdownlatch"></a> CountDownLatch</h5><p>是闭锁，通过计数来保证线程间是否需要阻塞。</p><h5 id="semphore"><a class="markdownIt-Anchor" href="#semphore"></a> Semphore</h5><p>控制同一时刻并发的线程数量。</p><h5 id="cyclicbarrier"><a class="markdownIt-Anchor" href="#cyclicbarrier"></a> CyclicBarrier</h5><p>同CountDownLatch相似，均可以阻塞线程。</p><h5 id="reentrantlock"><a class="markdownIt-Anchor" href="#reentrantlock"></a> ReentrantLock</h5><p>重入锁。后续手记中会详述。</p><h5 id="condition"><a class="markdownIt-Anchor" href="#condition"></a> Condition</h5><p>使用时需结合ReentrantLock。</p><h5 id="futuretask"><a class="markdownIt-Anchor" href="#futuretask"></a> FutureTask</h5><p>后续会有FutureTask的详细介绍……</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概述&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#概述&quot;&gt;&lt;/a&gt; 概述&lt;/h3&gt;
&lt;p&gt;AQS是J.U.C中的一个非常重要的类。&lt;br&gt;
J.U.C是java.util.concurrent的首字母简称。而AQS是J.U.C下locks包的一个抽象类。&lt;/p&gt;
    
    </summary>
    
      <category term="Java之并发编程" scheme="http://suprisemf.github.io/categories/Java%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java" scheme="http://suprisemf.github.io/tags/Java/"/>
    
      <category term="并发编程" scheme="http://suprisemf.github.io/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>并发容器-J.U.C之线程安全集合</title>
    <link href="http://suprisemf.github.io/2018/08/02/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/"/>
    <id>http://suprisemf.github.io/2018/08/02/并发容器/</id>
    <published>2018-08-02T11:29:10.000Z</published>
    <updated>2018-08-02T11:31:45.937Z</updated>
    
    <content type="html"><![CDATA[<h3 id="copyonwritearraylist"><a class="markdownIt-Anchor" href="#copyonwritearraylist"></a> copyOnWriteArrayList</h3><blockquote><p>线程写操作时复制，当有新元素添加到copyOnWriteArrayList时，它先从原有的数组中拷贝出一份，在新开辟出的新数组中写入，写完后再将原数组指向新数组。其操作都是在锁的域中，防止在多线程中复制出多个副本出来，导致原数组指向错误。</p></blockquote><p><strong>特点：</strong></p><ol><li>由于写操作需进行复制操作，耗用内存；当元素内容过多时，该复制操作会占用非常多的内存，导致minor-GC，甚至full-GC。</li><li>虽然最终会保持一致性，但不能用于实时读的操作。</li><li>读写分离，且适合读多写少的场景。</li><li>若add或set的数据不清楚或过多，要慎用！</li><li>读时不加锁，写时加锁。</li></ol><a id="more"></a><p><strong>测试例子：</strong>（还是原来的测试框架，测试实例变量声明如下）</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> static <span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt; <span class="built_in">list</span> = <span class="literal">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure><p><strong>运行结果：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">22<span class="selector-pseudo">:03</span><span class="selector-pseudo">:09.363</span> <span class="selector-attr">[main]</span> <span class="selector-tag">INFO</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.concurrent</span><span class="selector-class">.CopyOnWriteArrayListExample</span> <span class="selector-tag">-</span> <span class="selector-tag">size</span><span class="selector-pseudo">:5000</span></span><br></pre></td></tr></table></figure><p>结果验证了该类为线程安全的！</p><p>看一下它的源码：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** The lock protecting all mutators */</span></span><br><span class="line">final transient ReentrantLock <span class="keyword">lock</span> = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> boolean <span class="title">add</span>(<span class="params">E e</span>) </span>&#123;</span><br><span class="line">    final ReentrantLock <span class="keyword">lock</span> = <span class="keyword">this</span>.<span class="keyword">lock</span>;</span><br><span class="line">    <span class="keyword">lock</span>.<span class="keyword">lock</span>();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">lock</span>.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>显然是使用重入锁进行操作加锁。add方法的实现与上面的说明对应！</strong></p><h3 id="copyonwritearrayset"><a class="markdownIt-Anchor" href="#copyonwritearrayset"></a> copyOnWriteArraySet</h3><blockquote><p>对应于HashSet。</p></blockquote><p><strong>它的底层实现与copyOnWriteArrayList是一样的。特点也是一样的。当使用迭代器iterator迭代时，速度快效率高线程安全。</strong></p><h3 id="concurrentskiplistset"><a class="markdownIt-Anchor" href="#concurrentskiplistset"></a> ConcurrentSkipListSet</h3><blockquote><p>对应于TreeSet。是JDK 1.6中新增的类，同样支持自然排序。在构造时可以自定义比较器。基于map集合，故而多线程并发环境下，它的类内插入、移除、访问方法都是线程安全的。但是对于批量操作，比如addAll()、removeAll()、retainAll()、containsAll并不能保证其操作的原子性。</p></blockquote><p>例子就不用演示了，跟上面的例子方法几乎完全一样，运行结果也显示是线程安全的！批量操作时就不能保证线程安全了！需额外增加锁机制。</p><h3 id="concurrenthashmap"><a class="markdownIt-Anchor" href="#concurrenthashmap"></a> ConcurrentHashMap</h3><blockquote><p>对应于HashMap。其中需注意，key或Value不需为null。高并发环境中，表现较好。（后续会详细讲）</p></blockquote><h3 id="concurrentskiplistmap"><a class="markdownIt-Anchor" href="#concurrentskiplistmap"></a> ConcurrentSkipListMap</h3><blockquote><p>对应于TreeMap。内部是使用SkipList即跳表的结构实现。</p></blockquote><p><strong>SkipList：</strong> 跳跃链表是一种随机化数据结构，基于并联的链表，其效率可比拟于二叉查找树(对于大多数操作需要O(log n)平均时间)，并且对并发算法友好。基本上，跳跃列表是对有序的链表增加上附加的前进链接，增加是以随机化的方式进行的，所以在列表中的查找可以快速的跳过部分列表(因此得名)。  <a href="https://blog.csdn.net/qpzkobe/article/details/80057046" target="_blank" rel="noopener">推荐阅读</a></p><p><strong>跳表性质：</strong></p><ol><li>由很多层结构组成；</li><li>每一层都是一个有序的链表；</li><li>最底层(Level 1)的链表包含所有元素；</li><li>如果一个元素出现在 Level i 的链表中，则它在 Level i 之下的链表也都会出现；</li><li>每个节点包含两个指针，一个指向同一链表中的下一个元素，一个指向下面一层的元素。<br><a href="https://www.cnblogs.com/a8457013/p/8251967.html" target="_blank" rel="noopener">推荐阅读</a></li></ol><p><strong>虽然ConcurrentSkipListMap的效率不及ConcurrentHashMap，但它也有ConcurrentHashMap不可比拟的优点：</strong></p><ol><li>ConcurrentSkipListMap中的key值是有序的。</li><li>支持更高的线程并发。其存取时间与线程数量是几乎没有关系的。即线程越多，越有利于ConcurrentSkipListMap的性能发挥。</li></ol><blockquote><p>上面介绍的几个例子就不进行例子演示了，均只是改变了变量的声明，其他内容仍然与原测试结构相同。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;copyonwritearraylist&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#copyonwritearraylist&quot;&gt;&lt;/a&gt; copyOnWriteArrayList&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;线程写操作时复制，当有新元素添加到copyOnWriteArrayList时，它先从原有的数组中拷贝出一份，在新开辟出的新数组中写入，写完后再将原数组指向新数组。其操作都是在锁的域中，防止在多线程中复制出多个副本出来，导致原数组指向错误。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;特点：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;由于写操作需进行复制操作，耗用内存；当元素内容过多时，该复制操作会占用非常多的内存，导致minor-GC，甚至full-GC。&lt;/li&gt;
&lt;li&gt;虽然最终会保持一致性，但不能用于实时读的操作。&lt;/li&gt;
&lt;li&gt;读写分离，且适合读多写少的场景。&lt;/li&gt;
&lt;li&gt;若add或set的数据不清楚或过多，要慎用！&lt;/li&gt;
&lt;li&gt;读时不加锁，写时加锁。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Java之并发编程" scheme="http://suprisemf.github.io/categories/Java%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java" scheme="http://suprisemf.github.io/tags/Java/"/>
    
      <category term="并发编程" scheme="http://suprisemf.github.io/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>同步容器</title>
    <link href="http://suprisemf.github.io/2018/08/02/%E7%BA%BF%E5%90%8C%E6%AD%A5%E5%AE%B9%E5%99%A8/"/>
    <id>http://suprisemf.github.io/2018/08/02/线同步容器/</id>
    <published>2018-08-02T11:20:08.000Z</published>
    <updated>2018-08-02T11:28:06.642Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本节内容不仅丰富而且十分有趣实用~</p></blockquote><h3 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h3><blockquote><p>同步容器大致分为两类：</p><ol><li>由<code>List</code>发展来的<code>Vector</code>、<code>Stack</code>；由<code>HashMap</code>发展来的<code>HashTable</code>（其中K,V均不能为null）</li><li><code>Collections</code>工具类提供的静态工厂方法 --&gt; 均为<code>synchronizedXXXX(List/Set/Map)</code>的模样。</li></ol></blockquote><a id="more"></a><h4 id="vector"><a class="markdownIt-Anchor" href="#vector"></a> Vector</h4><p>看个例子：(好吧，这个测试的框架都快看恶心了ORZ)</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VectorExample1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> clientTotal = <span class="number">5000</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> threadTotal = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Integer&gt; list = <span class="keyword">new</span> Vector&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(threadTotal);</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(clientTotal);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clientTotal; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> count = i;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    update(count);</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.<span class="keyword">error</span>(<span class="string">"exception"</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">        log.info(<span class="string">"size:&#123;&#125;"</span>, list.size());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;list.add(i);&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">14<span class="selector-pseudo">:10</span><span class="selector-pseudo">:04.044</span> <span class="selector-attr">[main]</span> <span class="selector-tag">INFO</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.syncContainer</span><span class="selector-class">.VectorExample1</span> <span class="selector-tag">-</span> <span class="selector-tag">size</span><span class="selector-pseudo">:5000</span></span><br></pre></td></tr></table></figure><p>看一下<code>Vector</code>的源码:</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> synchronized <span class="keyword">void</span> insertElementAt(E obj, <span class="keyword">int</span> <span class="keyword">index</span>) &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">index</span> &gt; elementCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(<span class="keyword">index</span></span><br><span class="line">                                                 + <span class="string">" &gt; "</span> + elementCount);</span><br><span class="line">    &#125;</span><br><span class="line">    ensureCapacityHelper(elementCount + <span class="number">1</span>);</span><br><span class="line">    System.arraycopy(elementData, <span class="keyword">index</span>, elementData, <span class="keyword">index</span> + <span class="number">1</span>, elementCount - <span class="keyword">index</span>);</span><br><span class="line">    elementData[<span class="keyword">index</span>] = obj;</span><br><span class="line">    elementCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他方法同理，基本都使用synchronized进行标识。<br><strong>但是！！</strong><br><strong>同步容器不一定就是线程安全的！</strong></p><p>再看例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">@NotThreadSafe</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VectorExample2</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Vector&lt;Integer&gt; <span class="built_in">vector</span> = <span class="keyword">new</span> Vector&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="built_in">vector</span>.add(i);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Thread thread1 = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> run() &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">vector</span>.size(); i++) &#123;</span><br><span class="line">                        <span class="built_in">vector</span>.remove(i);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            Thread thread2 = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> run() &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">vector</span>.size(); i++) &#123;</span><br><span class="line">                        <span class="built_in">vector</span>.get(i);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            thread1.start();</span><br><span class="line">            thread2.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/2018/08/02/线同步容器/%E7%BA%BF%E5%90%8C%E6%AD%A5%E5%AE%B9%E5%99%A8/%E5%90%8C%E6%AD%A5%E5%AE%B9%E5%99%A8Vector%E6%B5%8B%E8%AF%95.png" alt="图示"></p><p>既然Vector的remove和get方法都抛出ArrayIndexOutOfBoundsException异常，那看一下源码吧：</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the element at the specified position in this Vector.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param index index of the element to return</span></span><br><span class="line"><span class="comment"> * @return object at the specified index</span></span><br><span class="line"><span class="comment"> * @throws ArrayIndexOutOfBoundsException if the index is out of range</span></span><br><span class="line"><span class="comment"> *            (&#123;@code index &lt; 0 || index &gt;= size()&#125;)</span></span><br><span class="line"><span class="comment"> * @since 1.2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> synchronized E get(<span class="keyword">int</span> <span class="keyword">index</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">index</span> &gt;= elementCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(<span class="keyword">index</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> elementData(<span class="keyword">index</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> synchronized E remove(<span class="keyword">int</span> <span class="keyword">index</span>) &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">index</span> &gt;= elementCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(<span class="keyword">index</span>);</span><br><span class="line">    E oldValue = elementData(<span class="keyword">index</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> numMoved = elementCount - <span class="keyword">index</span> - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, <span class="keyword">index</span>+<span class="number">1</span>, elementData, <span class="keyword">index</span>,</span><br><span class="line">                         numMoved);</span><br><span class="line">    elementData[--elementCount] = <span class="keyword">null</span>; <span class="comment">// Let gc do its work</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>源码分析：</strong></p><ol><li><code>get</code>方法出现该异常一定是<code>remove</code>方法造成的。</li><li>数组越界情况为：<code>index &lt; 0</code> 或 <code>index &gt;= size()</code>。但既然是remove方法，那应该只能是index小于0或index不存在的情况了。</li><li><strong>同步容器不一定就能保证线程并发安全。</strong></li></ol><p><strong>例子情况分析：</strong>（常见的多线程间执行顺序的差异导致）<br>在其中的for循环中，当一个线程调用get方法时（其中其下标设为i），另一个线程恰好在前一时刻调用了remove方法（恰好其下标也是i），此时下标为i的数据已经不存在，便抛出ArrayIndexOutOfBoundsException异常。</p><p>再来看一个Vector的测试例子：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">VectorExample3</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span>(<span class="params">Vector&lt;Integer&gt; v1</span>) </span>&#123; <span class="comment">// foreach</span></span><br><span class="line">        <span class="keyword">for</span>(Integer i : v1) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i.<span class="keyword">equals</span>(<span class="number">3</span>)) &#123;</span><br><span class="line">                v1.<span class="keyword">remove</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// java.util.ConcurrentModificationException</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test2</span>(<span class="params">Vector&lt;Integer&gt; v1</span>) </span>&#123; <span class="comment">// iterator</span></span><br><span class="line">        Iterator&lt;Integer&gt; iterator = v1.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            Integer i = iterator.next();</span><br><span class="line">            <span class="keyword">if</span> (i.<span class="keyword">equals</span>(<span class="number">3</span>)) &#123;</span><br><span class="line">                v1.<span class="keyword">remove</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// success</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test3</span>(<span class="params">Vector&lt;Integer&gt; v1</span>) </span>&#123; <span class="comment">// for</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v1.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (v1.<span class="keyword">get</span>(i).<span class="keyword">equals</span>(<span class="number">3</span>)) &#123;</span><br><span class="line">                v1.<span class="keyword">remove</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">        Vector&lt;Integer&gt; vector = <span class="keyword">new</span> Vector&lt;&gt;();</span><br><span class="line">        vector.<span class="keyword">add</span>(<span class="number">1</span>);</span><br><span class="line">        vector.<span class="keyword">add</span>(<span class="number">2</span>);</span><br><span class="line">        vector.<span class="keyword">add</span>(<span class="number">3</span>);</span><br><span class="line">        test1(vector);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果：</strong></p><ol><li>main函数执行test1(vector)时，抛出java.util.ConcurrentModificationException；</li><li>main函数执行test2(vector)时，抛出java.util.ConcurrentModificationException；</li><li>main函数执行test3(vector)时，程序正常结束。</li></ol><p><strong>结果分析：</strong><br>使用迭代器iterator或foreach循环（加强版for循环）会抛出并发修改异常；但一般for语句正常结束。</p><p>废话不多说，看源码：</p> <figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function">E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (Vector.<span class="keyword">this</span>) &#123;</span><br><span class="line">        checkForComodification();</span><br><span class="line">        <span class="keyword">int</span> i = cursor;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= elementCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        cursor = i + <span class="number">1</span>;</span><br><span class="line">        <span class="function"><span class="keyword">return</span> <span class="title">elementData</span><span class="params">(lastRet = i)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lastRet == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">    <span class="keyword">synchronized</span> (Vector.<span class="keyword">this</span>) &#123;</span><br><span class="line">        checkForComodification();</span><br><span class="line">        Vector.<span class="keyword">this</span>.remove(lastRet);</span><br><span class="line">        expectedModCount = modCount;</span><br><span class="line">    &#125;</span><br><span class="line">    cursor = lastRet;</span><br><span class="line">    lastRet = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> <span class="function"><span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>源码分析：</strong><br>由于迭代器<code>iterator</code>或<code>foreach</code>循环中的<code>remove</code>操作使得<code>modCount != expectedModCount</code>，即修改后的<code>count</code>与期望的<code>count</code>不一致，定是并发过程中<code>Vector</code>被修改；但<code>for循环</code>每次循环都会重新计算i,此时<code>Vector</code>已被更新……（好吧，我承认，我其实这里还是不太懂，<code>for</code>循环这里只是我的猜想。）<br><strong>解决方案：</strong><br>在讯循环中不要进行修改操作：</p><ol><li>先查，若有需要进行修改的对象，则做上标记</li><li>循环之后进行修改</li></ol><p><strong>当使用迭代器iterator迭代时，使用synchronized或Lock做同步措施（也可以使用并发容器copyOnWriteArrayList等代替ArrayList或Vector）</strong></p><h4 id="stack"><a class="markdownIt-Anchor" href="#stack"></a> Stack</h4><p>继承了Vector，其两者用法基本一致。只不过它是一个LIFO的数据结构。</p><h4 id="hashtable"><a class="markdownIt-Anchor" href="#hashtable"></a> HashTable</h4><p>好吧，其实用的还是那套框架，换一下实例声明的名字就行了。</p><p>运行结果：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">15<span class="selector-pseudo">:05</span><span class="selector-pseudo">:24.433</span> <span class="selector-attr">[main]</span> <span class="selector-tag">INFO</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.syncContainer</span><span class="selector-class">.HashTableExample</span> <span class="selector-tag">-</span> <span class="selector-tag">size</span><span class="selector-pseudo">:5000</span></span><br></pre></td></tr></table></figure><p>既然是线程安全的，再看一下源码：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> synchronized V <span class="title">put</span>(<span class="params">K key, V <span class="keyword">value</span></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Make sure the value is not null</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">value</span> == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Makes sure the key is not already in the hashtable.</span></span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">    <span class="keyword">int</span> hash = key.hashCode();</span><br><span class="line">    <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">    @SuppressWarnings(<span class="string">"unchecked"</span>)</span><br><span class="line">    Entry&lt;K,V&gt; entry = (Entry&lt;K,V&gt;)tab[index];</span><br><span class="line">    <span class="keyword">for</span>(; entry != <span class="literal">null</span> ; entry = entry.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((entry.hash == hash) &amp;&amp; entry.key.<span class="keyword">equals</span>(key)) &#123;</span><br><span class="line">            V old = entry.<span class="keyword">value</span>;</span><br><span class="line">            entry.<span class="keyword">value</span> = <span class="keyword">value</span>;</span><br><span class="line">            <span class="keyword">return</span> old;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    addEntry(hash, key, <span class="keyword">value</span>, index);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好吧，还是synchronized标识修饰方法。故HashTable是一个线程安全的同步容器。</p><h4 id="collections工具类方法"><a class="markdownIt-Anchor" href="#collections工具类方法"></a> Collections工具类方法</h4><h5 id="synchronizedlist"><a class="markdownIt-Anchor" href="#synchronizedlist"></a> synchronizedList</h5><p>例子：（还是原来的配方，还是熟悉的测试框架…不过实例声明换成Collections的方法）</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;Integer&gt; list = Collections.synchronizedList(Lists.<span class="keyword">new</span><span class="type">ArrayList</span>());</span><br></pre></td></tr></table></figure><p>好吧，非常不幸的告诉你，它的运行结果还是:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">15<span class="selector-pseudo">:20</span><span class="selector-pseudo">:49.641</span> <span class="selector-attr">[main]</span> <span class="selector-tag">INFO</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.syncContainer</span><span class="selector-class">.CollectionsExample1</span> <span class="selector-tag">-</span> <span class="selector-tag">size</span><span class="selector-pseudo">:5000</span></span><br></pre></td></tr></table></figure><p>不管怎样，来都来了，那看一下源码：（没错，注释已经“入党”，已经自动汉化了）</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/ **</span><br><span class="line">     *返回由指定的支持的同步（线程安全）列表</span><br><span class="line">     *清单。为了保证串行访问，至关重要的是</span><br><span class="line">     * &lt;strong&gt;所有&lt;/ strong&gt;对支持列表的访问权限已完成</span><br><span class="line">     *通过返回的列表。&lt;p&gt;</span><br><span class="line">     *</span><br><span class="line">     *用户必须手动地同步返回的内容</span><br><span class="line">     *迭代时列出：</span><br><span class="line">     * &lt;pre&gt;</span><br><span class="line">     * <span class="built_in">List</span> <span class="built_in">list</span> = Collections.synchronizedList（<span class="literal">new</span> ArrayList（））;</span><br><span class="line">     * <span class="params">...</span><span class="params">...</span></span><br><span class="line">     * synchronized（<span class="built_in">list</span>）&#123;</span><br><span class="line">     * Iterator i = <span class="built_in">list</span>.iterator（）; <span class="comment">//必须在同步块中</span></span><br><span class="line">     * <span class="keyword">while</span>（i.hasNext（））</span><br><span class="line">     * foo（i.next（））;</span><br><span class="line">     *&#125;</span><br><span class="line">     * &lt;/ pre&gt;</span><br><span class="line">     *不遵循此建议可能会导致非确定性行为。</span><br><span class="line">     *</span><br><span class="line">     * &lt;p&gt;如果指定的列表是，则返回的列表将是可序列化的</span><br><span class="line">     *可序列化。</span><br><span class="line">     *</span><br><span class="line">     * @param &lt;T&gt;列表中对象的类</span><br><span class="line">     * @param列出要在同步列表中“包装”的列表。</span><br><span class="line">     * @<span class="keyword">return</span>指定列表的同步视图。</span><br><span class="line">     * /</span><br><span class="line">    <span class="keyword">public</span> static &lt;T&gt; <span class="built_in">List</span>&lt;T&gt; synchronizedList(<span class="built_in">List</span>&lt;T&gt; <span class="built_in">list</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">list</span> instanceof RandomAccess ?</span><br><span class="line">                <span class="literal">new</span> SynchronizedRandomAccessList&lt;&gt;(<span class="built_in">list</span>) :</span><br><span class="line">                <span class="literal">new</span> SynchronizedList&lt;&gt;(<span class="built_in">list</span>));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>注意到</strong>，这竟然还有SynchronizedRandomAccessList和SynchronizedList之分？</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedRandomAccessList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">SynchronizedList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">RandomAccess</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    SynchronizedRandomAccessList(<span class="keyword">List</span>&lt;E&gt; <span class="keyword">list</span>) &#123;</span><br><span class="line">        super(<span class="keyword">list</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>可知SynchronizedRandomAccessList继承SynchronizedList，并实现了RandomAccess接口。<br>那这接口是什么鬼？</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public<span class="built_in"> interface </span>RandomAccess &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没了，他就只是个接口……</p><blockquote><p>读者：求你了，看一下注释吧，老哥~<br>我：emmmm，行~~</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">  * 标记接口被<span class="tag">&lt;<span class="name">tt</span>&gt;</span> List <span class="tag">&lt;/ <span class="attr">tt</span>&gt;</span>用来指示</span><br><span class="line">  *它们支持快速（通常是恒定时间）随机访问。</span><br><span class="line">  *此接口的首要目的是允许通用算法更改它们，</span><br><span class="line">  *当被应用于随机或顺序访问多个列表时，</span><br><span class="line">  *以提供良好性能</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><blockquote><p>读者：泥垢了！！~~<br>我：emmmm~~~</p></blockquote><h5 id="synchronizedset"><a class="markdownIt-Anchor" href="#synchronizedset"></a> synchronizedSet</h5><p>只是把上面的例子的实例换成Set罢了、、</p><h5 id="synchronizedmap"><a class="markdownIt-Anchor" href="#synchronizedmap"></a> synchronizedMap</h5><p>只是把上面的例子的实例换Map罢了、、</p><blockquote><p>读者：这仨除了名字还有啥区别？尼莫不四郎肥劳资时间？（四窜口音~）<br>我：好吧，我真的不想骗大家了，这都被大家发现了~ （花泽香菜兵库北的笑~23333）</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本节内容不仅丰富而且十分有趣实用~&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;概述&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#概述&quot;&gt;&lt;/a&gt; 概述&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;同步容器大致分为两类：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;由&lt;code&gt;List&lt;/code&gt;发展来的&lt;code&gt;Vector&lt;/code&gt;、&lt;code&gt;Stack&lt;/code&gt;；由&lt;code&gt;HashMap&lt;/code&gt;发展来的&lt;code&gt;HashTable&lt;/code&gt;（其中K,V均不能为null）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Collections&lt;/code&gt;工具类提供的静态工厂方法 --&amp;gt; 均为&lt;code&gt;synchronizedXXXX(List/Set/Map)&lt;/code&gt;的模样。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Java之并发编程" scheme="http://suprisemf.github.io/categories/Java%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java" scheme="http://suprisemf.github.io/tags/Java/"/>
    
      <category term="并发编程" scheme="http://suprisemf.github.io/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>线程不安全——Part-2</title>
    <link href="http://suprisemf.github.io/2018/08/02/%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94part-2/"/>
    <id>http://suprisemf.github.io/2018/08/02/线程不安全——part-2/</id>
    <published>2018-08-02T11:16:14.000Z</published>
    <updated>2018-08-02T11:17:31.521Z</updated>
    
    <content type="html"><![CDATA[<h3 id="collections部分"><a class="markdownIt-Anchor" href="#collections部分"></a> Collections部分</h3><blockquote><p>一般情况下，我们使用ArrayList、HashSet、HashMap是在方法中定义局部变量，此时由于堆栈封闭的特性，自然不会有线程安全问题。但是，当将其定义为静态域中，且未做线程安全措施时，极有可能会导致多线程并发错误。</p></blockquote><a id="more"></a><h4 id="说明"><a class="markdownIt-Anchor" href="#说明"></a> 说明</h4><p><strong>由于该三个集合是Java中最常见的、最重要的集合，此处仅分析说明是非线程安全的类。其详细内容我会另起手记再做说明！！</strong></p><h4 id="arraylist"><a class="markdownIt-Anchor" href="#arraylist"></a> ArrayList</h4><p>弄个例子：(还是之前的框架)</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@NotThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayListExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> clientTotal = <span class="number">5000</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> threadTotal = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(threadTotal);</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(clientTotal);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clientTotal; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> count = i;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    update(count);</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.<span class="keyword">error</span>(<span class="string">"exception"</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">        log.info(<span class="string">"size:&#123;&#125;"</span>, list.size());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123; list.add(i); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">13<span class="selector-pseudo">:31</span><span class="selector-pseudo">:39.296</span> <span class="selector-attr">[main]</span> <span class="selector-tag">INFO</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.commonUnsafe</span><span class="selector-class">.ArrayListExample</span> <span class="selector-tag">-</span> <span class="selector-tag">size</span><span class="selector-pseudo">:4986</span></span><br></pre></td></tr></table></figure><p>显而易见，是非线程安全的。</p><h4 id="hashset"><a class="markdownIt-Anchor" href="#hashset"></a> HashSet</h4><p>同理，HashSet同样进行测试，结果表明同样是非线程安全的！</p><h4 id="hashmap"><a class="markdownIt-Anchor" href="#hashmap"></a> HashMap</h4><p>同理，HashMap同样进行测试，结果表明同样是非线程安全的！</p><h3 id="线程不安全的写法"><a class="markdownIt-Anchor" href="#线程不安全的写法"></a> 线程不安全的写法</h3><p><strong>先检查再执行</strong>：</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="comment">(aaaa)</span></span><br><span class="line">&#123;</span><br><span class="line">  bbbbbbbbb;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个较易解释，在之前说AtomicXXX时说过：<br>在多线程并发时，可能多个线程执行到<code>if</code>语句的判断，且同时符合，然后分别作出修改。即该操作的原子性不能得到保证！故当有多线程并发问题时，考虑清楚，加锁进行处理。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;collections部分&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#collections部分&quot;&gt;&lt;/a&gt; Collections部分&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;一般情况下，我们使用ArrayList、HashSet、HashMap是在方法中定义局部变量，此时由于堆栈封闭的特性，自然不会有线程安全问题。但是，当将其定义为静态域中，且未做线程安全措施时，极有可能会导致多线程并发错误。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Java之并发编程" scheme="http://suprisemf.github.io/categories/Java%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java" scheme="http://suprisemf.github.io/tags/Java/"/>
    
      <category term="并发编程" scheme="http://suprisemf.github.io/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>线程不安全——Part-1</title>
    <link href="http://suprisemf.github.io/2018/08/02/%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94part-1/"/>
    <id>http://suprisemf.github.io/2018/08/02/线程不安全——part-1/</id>
    <published>2018-08-02T11:09:09.000Z</published>
    <updated>2018-08-02T11:12:59.896Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h3><blockquote><p>线程不安全类：如果一个类的对象同时被多个线程访问，若不做相应的同步或并发处理，容易出现线程不安全的现象，比如：抛出异常、逻辑处理错误等。</p></blockquote><a id="more"></a><h4 id="stringbiulder"><a class="markdownIt-Anchor" href="#stringbiulder"></a> StringBiulder</h4><p>看一个例子：（借助之前的例子结构）</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@NotThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringExample1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> clientTotal = <span class="number">5000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> threadTotal = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(threadTotal);</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(clientTotal);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clientTotal ; i++) &#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    update();</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.<span class="keyword">error</span>(<span class="string">"exception"</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">        log.info(<span class="string">"size:&#123;&#125;"</span>, stringBuilder.length());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stringBuilder.append(<span class="string">"1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果分析：</strong></p><ol><li>多次运行，结果几乎未达5000，显然StringBuilder是非线程安全的。</li><li>通过定义stringBuilder对象，核心方法为update() -&gt; 每次拼接一个字符串，最后取其长度length。</li></ol><h4 id="stringbuffer"><a class="markdownIt-Anchor" href="#stringbuffer"></a> StringBuffer</h4><blockquote><p>例子代码结构跟上面一样，只需将StringBiulder换为StringBuffer，且其两者方法名相同。</p></blockquote><p><strong>运行结果：</strong><br>多次运行，结果均为5000。StringBuffer是线程安全的！</p><h5 id="查看stringbuffer源码"><a class="markdownIt-Anchor" href="#查看stringbuffer源码"></a> 查看StringBuffer源码</h5><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="built_in">append</span>(<span class="keyword">String</span> <span class="built_in">str</span>) &#123;</span><br><span class="line">    toStringCache = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">super</span>.<span class="built_in">append</span>(<span class="built_in">str</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">StringBuffer</span></span></span><br><span class="line"><span class="class">   <span class="keyword">extends</span> <span class="title">AbstractStringBuilder</span></span></span><br><span class="line"><span class="class">   <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">CharSequence</span></span>&#123;XXX省略&#125;</span><br></pre></td></tr></table></figure><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="function">String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (toStringCache == <span class="keyword">null</span>) &#123;</span><br><span class="line">        toStringCache = Arrays.copyOfRange(value, <span class="number">0</span>, count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(toStringCache, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>源码分析：</strong></p><ol><li>几乎所有复写的方法都有toStringCache变量。为对象方便转为String类型的字段，调用Arrays.copyOfRange(value, 0, count)，return new String(toStringCache, true)：其中该构造方法是String包私有的构造方法，以确保数值分享的效率。</li><li>StringBuffer继承自AbstractStringBuilder，并几乎重写了所有继承来的方法。调用父辈super的append方法，即AbstractStringBuilder的方法。且StringBuffer对象一经修改，toStringCache清空为null。类似String包装类的对象，避免多线程并发问题。（以后细说String包装类…）</li><li>为了线程安全，几乎所有复写的方法都用synchronized进行标识，即使效率较低。</li><li>StringBiulder性能好，但不适用于多线程。但适用于场景为方法内的局部变量操作（上篇线程封闭的手记中说到：隐式的堆栈封闭），线程安全且性能较好。</li></ol><h4 id="simpledateformate"><a class="markdownIt-Anchor" href="#simpledateformate"></a> SimpleDateFormate</h4><blockquote><p>Java提供的供日期转换的类。该例子结构仍然和上述例子相同。只需定义一个simpleDateFormat实例，核心方法换为parse（xxx:日期语句）</p></blockquote><p><strong>运行结果：</strong><br>出现异常：<code>parse exception -- java.lang.NumberFormatException: multiple points</code><br>非常简单，说明了该日期转换方法是非线程间安全的。</p><h5 id="正确写法通过堆栈封闭-声明为核心方法内的局部变量即每次声明一个新的对象进行调用"><a class="markdownIt-Anchor" href="#正确写法通过堆栈封闭-声明为核心方法内的局部变量即每次声明一个新的对象进行调用"></a> 正确写法：（通过堆栈封闭-&gt;声明为核心方法内的局部变量，即每次声明一个新的对象进行调用）</h5><blockquote><p>仍然是之前的测试结构，但还是贴出来看看吧。</p></blockquote><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DateFormatExample2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求总数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> clientTotal = <span class="number">5000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同时并发执行的线程数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> threadTotal = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(threadTotal);</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(clientTotal);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clientTotal ; i++) &#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    update();</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.<span class="keyword">error</span>(<span class="string">"exception"</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            SimpleDateFormat simpleDateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyyMMdd"</span>);</span><br><span class="line">            simpleDateFormat.parse(<span class="string">"20180208"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.<span class="keyword">error</span>(<span class="string">"parse exception"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果：</strong> 多次运行，不会报错！是线程安全！</p><h4 id="joda-time"><a class="markdownIt-Anchor" href="#joda-time"></a> Joda Time</h4><blockquote><p>该类本质上并不属于Java提供。需引入jar包。例子仍然是之前的测试结构。只不过日志输出了次数及当时日期</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//转换完后DateTime，调用toDate()转为Date对象。</span></span><br><span class="line">    <span class="built_in">log</span>.info(<span class="string">"&#123;&#125;, &#123;&#125;"</span>, i == <span class="number">4999</span> ? i+<span class="string">"--------------------------"</span> : i, DateTime.parse(<span class="string">"20180728"</span>, dateTimeFormatter).toDate());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果：</strong><br>由于调用是多并发的，调用次序是乱序，但总数一定！<br>由于i是从0到4999，即当i = 4999时说明已运行慢5000个，即线程安全！<br><strong>图片截图中字体小了，可以点开看~</strong><br><img src="/2018/08/02/线程不安全——part-1/%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94part-1/joda-Time%E6%B5%8B%E8%AF%95.png" alt="图示"></p><p>（后接该手记part-2……）</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概述&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#概述&quot;&gt;&lt;/a&gt; 概述&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;线程不安全类：如果一个类的对象同时被多个线程访问，若不做相应的同步或并发处理，容易出现线程不安全的现象，比如：抛出异常、逻辑处理错误等。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Java之并发编程" scheme="http://suprisemf.github.io/categories/Java%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java" scheme="http://suprisemf.github.io/tags/Java/"/>
    
      <category term="并发编程" scheme="http://suprisemf.github.io/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>线程封闭</title>
    <link href="http://suprisemf.github.io/2018/08/02/%E7%BA%BF%E7%A8%8B%E5%B0%81%E9%97%AD/"/>
    <id>http://suprisemf.github.io/2018/08/02/线程封闭/</id>
    <published>2018-08-02T11:02:38.000Z</published>
    <updated>2018-08-02T11:06:08.796Z</updated>
    
    <content type="html"><![CDATA[<h4 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h4><p>线程封闭是一种较为简单的线程并发的方法。它其实把对象封装到一个线程里，该对象只对该线程是可见的。当然也就是线程安全的了。</p><h4 id="实现线程封闭的方法"><a class="markdownIt-Anchor" href="#实现线程封闭的方法"></a> 实现线程封闭的方法</h4><ol><li>Ad-hoc 线程封闭：依赖程序控制实现，脆弱，是最糟糕的一种方式，不推荐！</li><li>堆栈封闭：应用广泛，依靠各线程局部变量的堆栈拷贝副本实现，无并发问题。避免使用全局变量。</li><li>数据库连接对应JDBC的Connection对象。</li><li>ThreadLocal线程封闭：实现较好，效率较高。（以后会做源码分析……）</li></ol><a id="more"></a><blockquote><ol start="2"><li>堆栈封闭:即指的是方法/类中的局部变量，默认是通过线程拷贝副本实现。</li><li>Connection对象在实现中并未对线程安全做过多的处理，JDBC的规范中也未要求Connection对象必须是线程安全的。但实际服务器的应用程序中，线程从连接池获取Connection对象，只有在使用结束后才将其返回给连接池，期间其他线程是获取不到Connection对象的。该机制显式提供了线程封闭。</li></ol></blockquote><h4 id="threadlocal测试例子"><a class="markdownIt-Anchor" href="#threadlocal测试例子"></a> ThreadLocal测试例子</h4><h5 id="requestholderjava"><a class="markdownIt-Anchor" href="#requestholderjava"></a> RequestHolder.java</h5><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">RequestHolder</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> final <span class="keyword">static</span> ThreadLocal&lt;Long&gt; requestHolder = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span>(<span class="params">Long id</span>) </span>&#123;</span><br><span class="line">        requestHolder.<span class="keyword">set</span>(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Long <span class="title">getId</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> requestHolder.<span class="keyword">get</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">remove</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        requestHolder.<span class="keyword">remove</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法分析：</p><ol><li>该类存放需要绑定的信息。</li><li>其中add操作是在请求进入后端服务器，但还未进行实际处理时，调用该方法，写入相关信息。（通过filter：先拦截对应的URL，当前台访问该URL时，将相关信息写入ThreadLocal中；当URL实际被处理时，可直接从ThreadLocal中取出信息）。</li><li>定义移除方法，防止内存泄漏。在接口处理完之后进行处理（通过intercepter实现）。</li></ol><h5 id="httpfilterjava"><a class="markdownIt-Anchor" href="#httpfilterjava"></a> HttpFilter.java</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//核心方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        HttpServletRequest request = (HttpServletRequest) servletRequest;</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">"do filter, &#123;&#125;, &#123;&#125;"</span>, Thread.currentThread().getId(), request.getServletPath());</span><br><span class="line"></span><br><span class="line">        RequestHolder.add(Thread.currentThread().getId());</span><br><span class="line">        filterChain.doFilter(servletRequest, servletResponse);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//销毁</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法分析：</p><ol><li>因为是通过http请求，ServletRequest需转换为HttpServletRequest类型。</li><li>在RequestHolder中放入URL相关信息。</li><li>最后若该filter不是想拦截住该请求，只是做相关的数据处理，还想让其他过滤器接收到，则需最后调用filterChain.doFilter(servletRequest, servletResponse)。</li></ol><h5 id="httpinterceptorjava"><a class="markdownIt-Anchor" href="#httpinterceptorjava"></a> HttpInterceptor.java</h5><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">HttpInterceptor</span> <span class="keyword">extends</span> <span class="title">HandlerInterceptorAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在处理之前输出</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    public boolean preHandle(<span class="type">HttpServletRequest</span> request, <span class="type">HttpServletResponse</span> response, <span class="type">Object</span> handler) <span class="keyword">throws</span> <span class="type">Exception</span> &#123;</span><br><span class="line">        log.info(<span class="string">"preHandle"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在完成之后删除信息、输出日志</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    public void afterCompletion(<span class="type">HttpServletRequest</span> request, <span class="type">HttpServletResponse</span> response, <span class="type">Object</span> handler, <span class="type">Exception</span> ex) <span class="keyword">throws</span> <span class="type">Exception</span> &#123;</span><br><span class="line">        <span class="type">RequestHolder</span>.remove();</span><br><span class="line">        log.info(<span class="string">"afterCompletion"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="threadlocalcontrollerjava"><a class="markdownIt-Anchor" href="#threadlocalcontrollerjava"></a> ThreadLocalController.java</h5><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Controller</span></span><br><span class="line"><span class="variable">@RequestMapping</span>(<span class="string">"/threadlocal"</span>)</span><br><span class="line">public class ThreadLocalController &#123;</span><br><span class="line"></span><br><span class="line">    <span class="variable">@RequestMapping</span>(<span class="string">"/test"</span>)</span><br><span class="line">    <span class="variable">@ResponseBody</span></span><br><span class="line">    public Long test() &#123;</span><br><span class="line">        <span class="selector-tag">return</span> <span class="selector-tag">RequestHolder</span><span class="selector-class">.getId</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="concurrencyapplicationjava"><a class="markdownIt-Anchor" href="#concurrencyapplicationjava"></a> ConcurrencyApplication.java</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">true<span class="comment">//使用springboot快速进行测试</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrencyApplication</span> <span class="keyword">extends</span> <span class="title">WebMvcConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">true<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">truetrueSpringApplication.run(ConcurrencyApplication.class, args);</span><br><span class="line">true&#125;</span><br><span class="line"></span><br><span class="line">true<span class="meta">@Bean</span></span><br><span class="line">true<span class="function"><span class="keyword">public</span> FilterRegistrationBean <span class="title">httpFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">truetrueFilterRegistrationBean registrationBean = <span class="keyword">new</span> FilterRegistrationBean();</span><br><span class="line">truetrueregistrationBean.setFilter(<span class="keyword">new</span> HttpFilter());</span><br><span class="line"></span><br><span class="line">truetrueregistrationBean.addUrlPatterns(<span class="string">"/threadlocal/*"</span>);</span><br><span class="line">truetrue<span class="keyword">return</span> registrationBean;</span><br><span class="line">true&#125;</span><br><span class="line"></span><br><span class="line">true<span class="meta">@Override</span></span><br><span class="line">true<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">truetrueregistry.addInterceptor(<span class="keyword">new</span> HttpInterceptor()).addPathPatterns(<span class="string">"/**"</span>);</span><br><span class="line">true&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法分析：</p><ol><li>通过springboot创建registrationBean并指定过滤URL类型为&quot;/threadlocal/*&quot;。</li><li>重写addInterceptors -&gt; 添加拦截器，并指定拦截的路径类型。</li><li>ThreadLocalController.java中指定请求映射的名称和返回内容。</li></ol><p><strong>接口测试结果：(使用Postman进行接口测试)</strong></p><p><img src="/2018/08/02/线程封闭/%E7%BA%BF%E7%A8%8B%E5%B0%81%E9%97%AD/threadlocal%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95.png" alt="图示"></p><p><strong>日志部分截图：</strong></p><p><img src="/2018/08/02/线程封闭/%E7%BA%BF%E7%A8%8B%E5%B0%81%E9%97%AD/threadlocal%E6%B5%8B%E8%AF%95%E6%97%A5%E5%BF%97.png" alt="图示"></p><p>可以看出例子是和日志完全对应的。<br>重复一下<em>threadlocal的实现思想</em>：<strong>当一个请求进来时，通过过滤器Filter，将数据信息（这里是线程id）存储到threadlocal中，当接口被调用处理时，可以直接从中取出来；当接口处理完成，通过拦截器Interceptor的afterCompletion把当前线程中的数据信息（这里是线程id）移除，避免内存泄漏。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;概述&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#概述&quot;&gt;&lt;/a&gt; 概述&lt;/h4&gt;
&lt;p&gt;线程封闭是一种较为简单的线程并发的方法。它其实把对象封装到一个线程里，该对象只对该线程是可见的。当然也就是线程安全的了。&lt;/p&gt;
&lt;h4 id=&quot;实现线程封闭的方法&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#实现线程封闭的方法&quot;&gt;&lt;/a&gt; 实现线程封闭的方法&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;Ad-hoc 线程封闭：依赖程序控制实现，脆弱，是最糟糕的一种方式，不推荐！&lt;/li&gt;
&lt;li&gt;堆栈封闭：应用广泛，依靠各线程局部变量的堆栈拷贝副本实现，无并发问题。避免使用全局变量。&lt;/li&gt;
&lt;li&gt;数据库连接对应JDBC的Connection对象。&lt;/li&gt;
&lt;li&gt;ThreadLocal线程封闭：实现较好，效率较高。（以后会做源码分析……）&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Java之并发编程" scheme="http://suprisemf.github.io/categories/Java%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java" scheme="http://suprisemf.github.io/tags/Java/"/>
    
      <category term="并发编程" scheme="http://suprisemf.github.io/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>红宝石星球</title>
  
  <subtitle>凡心所向，素履以往；生如逆旅，一苇以航。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://suprisemf.github.io/"/>
  <updated>2018-08-02T11:12:59.896Z</updated>
  <id>http://suprisemf.github.io/</id>
  
  <author>
    <name>SupriseMF</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>线程不安全——Part-1</title>
    <link href="http://suprisemf.github.io/2018/08/02/%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94part-1/"/>
    <id>http://suprisemf.github.io/2018/08/02/线程不安全——part-1/</id>
    <published>2018-08-02T11:09:09.000Z</published>
    <updated>2018-08-02T11:12:59.896Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><blockquote><p>线程不安全类：如果一个类的对象同时被多个线程访问，若不做相应的同步或并发处理，容易出现线程不安全的现象，比如：抛出异常、逻辑处理错误等。</p></blockquote><a id="more"></a><h4 id="StringBiulder"><a href="#StringBiulder" class="headerlink" title="StringBiulder"></a>StringBiulder</h4><p>看一个例子：（借助之前的例子结构）<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@NotThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringExample1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> clientTotal = <span class="number">5000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> threadTotal = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(threadTotal);</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(clientTotal);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clientTotal ; i++) &#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    update();</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.<span class="keyword">error</span>(<span class="string">"exception"</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">        log.info(<span class="string">"size:&#123;&#125;"</span>, stringBuilder.length());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stringBuilder.append(<span class="string">"1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>结果分析：</strong></p><ol><li>多次运行，结果几乎未达5000，显然StringBuilder是非线程安全的。</li><li>通过定义stringBuilder对象，核心方法为update() -&gt; 每次拼接一个字符串，最后取其长度length。</li></ol><h4 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a>StringBuffer</h4><blockquote><p>例子代码结构跟上面一样，只需将StringBiulder换为StringBuffer，且其两者方法名相同。</p></blockquote><p><strong>运行结果：</strong><br>多次运行，结果均为5000。StringBuffer是线程安全的！</p><h5 id="查看StringBuffer源码"><a href="#查看StringBuffer源码" class="headerlink" title="查看StringBuffer源码"></a>查看StringBuffer源码</h5><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="built_in">append</span>(<span class="keyword">String</span> <span class="built_in">str</span>) &#123;</span><br><span class="line">    toStringCache = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">super</span>.<span class="built_in">append</span>(<span class="built_in">str</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">StringBuffer</span></span></span><br><span class="line"><span class="class">   <span class="keyword">extends</span> <span class="title">AbstractStringBuilder</span></span></span><br><span class="line"><span class="class">   <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">CharSequence</span></span>&#123;XXX省略&#125;</span><br></pre></td></tr></table></figure><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="function">String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (toStringCache == <span class="keyword">null</span>) &#123;</span><br><span class="line">        toStringCache = Arrays.copyOfRange(value, <span class="number">0</span>, count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(toStringCache, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>源码分析：</strong></p><ol><li>几乎所有复写的方法都有toStringCache变量。为对象方便转为String类型的字段，调用Arrays.copyOfRange(value, 0, count)，return new String(toStringCache, true)：其中该构造方法是String包私有的构造方法，以确保数值分享的效率。</li><li>StringBuffer继承自AbstractStringBuilder，并几乎重写了所有继承来的方法。调用父辈super的append方法，即AbstractStringBuilder的方法。且StringBuffer对象一经修改，toStringCache清空为null。类似String包装类的对象，避免多线程并发问题。（以后细说String包装类…）</li><li>为了线程安全，几乎所有复写的方法都用synchronized进行标识，即使效率较低。</li><li>StringBiulder性能好，但不适用于多线程。但适用于场景为方法内的局部变量操作（上篇线程封闭的手记中说到：隐式的堆栈封闭），线程安全且性能较好。</li></ol><h4 id="SimpleDateFormate"><a href="#SimpleDateFormate" class="headerlink" title="SimpleDateFormate"></a>SimpleDateFormate</h4><blockquote><p>Java提供的供日期转换的类。该例子结构仍然和上述例子相同。只需定义一个simpleDateFormat实例，核心方法换为parse（xxx:日期语句）</p></blockquote><p><strong>运行结果：</strong><br>出现异常：<code>parse exception -- java.lang.NumberFormatException: multiple points</code><br>非常简单，说明了该日期转换方法是非线程间安全的。</p><h5 id="正确写法：（通过堆栈封闭-gt-声明为核心方法内的局部变量，即每次声明一个新的对象进行调用）"><a href="#正确写法：（通过堆栈封闭-gt-声明为核心方法内的局部变量，即每次声明一个新的对象进行调用）" class="headerlink" title="正确写法：（通过堆栈封闭-&gt;声明为核心方法内的局部变量，即每次声明一个新的对象进行调用）"></a>正确写法：（通过堆栈封闭-&gt;声明为核心方法内的局部变量，即每次声明一个新的对象进行调用）</h5><blockquote><p>仍然是之前的测试结构，但还是贴出来看看吧。<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DateFormatExample2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求总数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> clientTotal = <span class="number">5000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同时并发执行的线程数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> threadTotal = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(threadTotal);</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(clientTotal);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clientTotal ; i++) &#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    update();</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.<span class="keyword">error</span>(<span class="string">"exception"</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            SimpleDateFormat simpleDateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyyMMdd"</span>);</span><br><span class="line">            simpleDateFormat.parse(<span class="string">"20180208"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.<span class="keyword">error</span>(<span class="string">"parse exception"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><p><strong>运行结果：</strong> 多次运行，不会报错！是线程安全！</p><h4 id="Joda-Time"><a href="#Joda-Time" class="headerlink" title="Joda Time"></a>Joda Time</h4><blockquote><p>该类本质上并不属于Java提供。需引入jar包。例子仍然是之前的测试结构。只不过日志输出了次数及当时日期<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//转换完后DateTime，调用toDate()转为Date对象。</span></span><br><span class="line">    <span class="built_in">log</span>.info(<span class="string">"&#123;&#125;, &#123;&#125;"</span>, i == <span class="number">4999</span> ? i+<span class="string">"--------------------------"</span> : i, DateTime.parse(<span class="string">"20180728"</span>, dateTimeFormatter).toDate());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><p><strong>运行结果：</strong><br>由于调用是多并发的，调用次序是乱序，但总数一定！<br>由于i是从0到4999，即当i = 4999时说明已运行慢5000个，即线程安全！<br><strong>图片截图中字体小了，可以点开看~</strong><br><img src="/2018/08/02/线程不安全——part-1/joda-Time测试.png" alt="图示"></p><p>（后接该手记part-2……）</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;线程不安全类：如果一个类的对象同时被多个线程访问，若不做相应的同步或并发处理，容易出现线程不安全的现象，比如：抛出异常、逻辑处理错误等。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Java之并发编程" scheme="http://suprisemf.github.io/categories/Java%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java" scheme="http://suprisemf.github.io/tags/Java/"/>
    
      <category term="并发编程" scheme="http://suprisemf.github.io/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>线程封闭</title>
    <link href="http://suprisemf.github.io/2018/08/02/%E7%BA%BF%E7%A8%8B%E5%B0%81%E9%97%AD/"/>
    <id>http://suprisemf.github.io/2018/08/02/线程封闭/</id>
    <published>2018-08-02T11:02:38.000Z</published>
    <updated>2018-08-02T11:06:08.796Z</updated>
    
    <content type="html"><![CDATA[<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>线程封闭是一种较为简单的线程并发的方法。它其实把对象封装到一个线程里，该对象只对该线程是可见的。当然也就是线程安全的了。</p><h4 id="实现线程封闭的方法"><a href="#实现线程封闭的方法" class="headerlink" title="实现线程封闭的方法"></a>实现线程封闭的方法</h4><ol><li>Ad-hoc 线程封闭：依赖程序控制实现，脆弱，是最糟糕的一种方式，不推荐！</li><li>堆栈封闭：应用广泛，依靠各线程局部变量的堆栈拷贝副本实现，无并发问题。避免使用全局变量。</li><li>数据库连接对应JDBC的Connection对象。</li><li>ThreadLocal线程封闭：实现较好，效率较高。（以后会做源码分析……）</li></ol><a id="more"></a><blockquote><ol start="2"><li>堆栈封闭:即指的是方法/类中的局部变量，默认是通过线程拷贝副本实现。</li><li>Connection对象在实现中并未对线程安全做过多的处理，JDBC的规范中也未要求Connection对象必须是线程安全的。但实际服务器的应用程序中，线程从连接池获取Connection对象，只有在使用结束后才将其返回给连接池，期间其他线程是获取不到Connection对象的。该机制显式提供了线程封闭。</li></ol></blockquote><h4 id="ThreadLocal测试例子"><a href="#ThreadLocal测试例子" class="headerlink" title="ThreadLocal测试例子"></a>ThreadLocal测试例子</h4><h5 id="RequestHolder-java"><a href="#RequestHolder-java" class="headerlink" title="RequestHolder.java"></a>RequestHolder.java</h5><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">RequestHolder</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> final <span class="keyword">static</span> ThreadLocal&lt;Long&gt; requestHolder = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span>(<span class="params">Long id</span>) </span>&#123;</span><br><span class="line">        requestHolder.<span class="keyword">set</span>(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Long <span class="title">getId</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> requestHolder.<span class="keyword">get</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">remove</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        requestHolder.<span class="keyword">remove</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法分析：</p><ol><li>该类存放需要绑定的信息。</li><li>其中add操作是在请求进入后端服务器，但还未进行实际处理时，调用该方法，写入相关信息。（通过filter：先拦截对应的URL，当前台访问该URL时，将相关信息写入ThreadLocal中；当URL实际被处理时，可直接从ThreadLocal中取出信息）。</li><li>定义移除方法，防止内存泄漏。在接口处理完之后进行处理（通过intercepter实现）。</li></ol><h5 id="HttpFilter-java"><a href="#HttpFilter-java" class="headerlink" title="HttpFilter.java"></a>HttpFilter.java</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//核心方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        HttpServletRequest request = (HttpServletRequest) servletRequest;</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">"do filter, &#123;&#125;, &#123;&#125;"</span>, Thread.currentThread().getId(), request.getServletPath());</span><br><span class="line"></span><br><span class="line">        RequestHolder.add(Thread.currentThread().getId());</span><br><span class="line">        filterChain.doFilter(servletRequest, servletResponse);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//销毁</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法分析：</p><ol><li>因为是通过http请求，ServletRequest需转换为HttpServletRequest类型。</li><li>在RequestHolder中放入URL相关信息。</li><li>最后若该filter不是想拦截住该请求，只是做相关的数据处理，还想让其他过滤器接收到，则需最后调用filterChain.doFilter(servletRequest, servletResponse)。</li></ol><h5 id="HttpInterceptor-java"><a href="#HttpInterceptor-java" class="headerlink" title="HttpInterceptor.java"></a>HttpInterceptor.java</h5><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">HttpInterceptor</span> <span class="keyword">extends</span> <span class="title">HandlerInterceptorAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在处理之前输出</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    public boolean preHandle(<span class="type">HttpServletRequest</span> request, <span class="type">HttpServletResponse</span> response, <span class="type">Object</span> handler) <span class="keyword">throws</span> <span class="type">Exception</span> &#123;</span><br><span class="line">        log.info(<span class="string">"preHandle"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在完成之后删除信息、输出日志</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    public void afterCompletion(<span class="type">HttpServletRequest</span> request, <span class="type">HttpServletResponse</span> response, <span class="type">Object</span> handler, <span class="type">Exception</span> ex) <span class="keyword">throws</span> <span class="type">Exception</span> &#123;</span><br><span class="line">        <span class="type">RequestHolder</span>.remove();</span><br><span class="line">        log.info(<span class="string">"afterCompletion"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="ThreadLocalController-java"><a href="#ThreadLocalController-java" class="headerlink" title="ThreadLocalController.java"></a>ThreadLocalController.java</h5><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Controller</span></span><br><span class="line"><span class="variable">@RequestMapping</span>(<span class="string">"/threadlocal"</span>)</span><br><span class="line">public class ThreadLocalController &#123;</span><br><span class="line"></span><br><span class="line">    <span class="variable">@RequestMapping</span>(<span class="string">"/test"</span>)</span><br><span class="line">    <span class="variable">@ResponseBody</span></span><br><span class="line">    public Long test() &#123;</span><br><span class="line">        <span class="selector-tag">return</span> <span class="selector-tag">RequestHolder</span><span class="selector-class">.getId</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="ConcurrencyApplication-java"><a href="#ConcurrencyApplication-java" class="headerlink" title="ConcurrencyApplication.java"></a>ConcurrencyApplication.java</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">true<span class="comment">//使用springboot快速进行测试</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrencyApplication</span> <span class="keyword">extends</span> <span class="title">WebMvcConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">true<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">truetrueSpringApplication.run(ConcurrencyApplication.class, args);</span><br><span class="line">true&#125;</span><br><span class="line"></span><br><span class="line">true<span class="meta">@Bean</span></span><br><span class="line">true<span class="function"><span class="keyword">public</span> FilterRegistrationBean <span class="title">httpFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">truetrueFilterRegistrationBean registrationBean = <span class="keyword">new</span> FilterRegistrationBean();</span><br><span class="line">truetrueregistrationBean.setFilter(<span class="keyword">new</span> HttpFilter());</span><br><span class="line"></span><br><span class="line">truetrueregistrationBean.addUrlPatterns(<span class="string">"/threadlocal/*"</span>);</span><br><span class="line">truetrue<span class="keyword">return</span> registrationBean;</span><br><span class="line">true&#125;</span><br><span class="line"></span><br><span class="line">true<span class="meta">@Override</span></span><br><span class="line">true<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">truetrueregistry.addInterceptor(<span class="keyword">new</span> HttpInterceptor()).addPathPatterns(<span class="string">"/**"</span>);</span><br><span class="line">true&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法分析：</p><ol><li>通过springboot创建registrationBean并指定过滤URL类型为”/threadlocal/*”。</li><li>重写addInterceptors -&gt; 添加拦截器，并指定拦截的路径类型。</li><li>ThreadLocalController.java中指定请求映射的名称和返回内容。</li></ol><p><strong>接口测试结果：(使用Postman进行接口测试)</strong></p><p><img src="/2018/08/02/线程封闭/threadlocal接口测试.png" alt="图示"></p><p><strong>日志部分截图：</strong></p><p><img src="/2018/08/02/线程封闭/threadlocal测试日志.png" alt="图示"></p><p>可以看出例子是和日志完全对应的。<br>重复一下<em>threadlocal的实现思想</em>：<strong>当一个请求进来时，通过过滤器Filter，将数据信息（这里是线程id）存储到threadlocal中，当接口被调用处理时，可以直接从中取出来；当接口处理完成，通过拦截器Interceptor的afterCompletion把当前线程中的数据信息（这里是线程id）移除，避免内存泄漏。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h4&gt;&lt;p&gt;线程封闭是一种较为简单的线程并发的方法。它其实把对象封装到一个线程里，该对象只对该线程是可见的。当然也就是线程安全的了。&lt;/p&gt;
&lt;h4 id=&quot;实现线程封闭的方法&quot;&gt;&lt;a href=&quot;#实现线程封闭的方法&quot; class=&quot;headerlink&quot; title=&quot;实现线程封闭的方法&quot;&gt;&lt;/a&gt;实现线程封闭的方法&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;Ad-hoc 线程封闭：依赖程序控制实现，脆弱，是最糟糕的一种方式，不推荐！&lt;/li&gt;
&lt;li&gt;堆栈封闭：应用广泛，依靠各线程局部变量的堆栈拷贝副本实现，无并发问题。避免使用全局变量。&lt;/li&gt;
&lt;li&gt;数据库连接对应JDBC的Connection对象。&lt;/li&gt;
&lt;li&gt;ThreadLocal线程封闭：实现较好，效率较高。（以后会做源码分析……）&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Java之并发编程" scheme="http://suprisemf.github.io/categories/Java%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java" scheme="http://suprisemf.github.io/tags/Java/"/>
    
      <category term="并发编程" scheme="http://suprisemf.github.io/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>不可变对象</title>
    <link href="http://suprisemf.github.io/2018/08/02/%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%AF%B9%E8%B1%A1/"/>
    <id>http://suprisemf.github.io/2018/08/02/不可变对象/</id>
    <published>2018-08-02T10:41:54.000Z</published>
    <updated>2018-08-02T11:00:18.924Z</updated>
    
    <content type="html"><![CDATA[<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>不可变对象一经安全发布，它就是不可变的。</p><h4 id="需满足的条件"><a href="#需满足的条件" class="headerlink" title="需满足的条件"></a>需满足的条件</h4><ul><li>对象创建后其状态不能被修改；</li><li>对象所有的域都是final类型；</li><li>对象是正确创建的（在对象创建期间，其this引用未逸出）；<blockquote><p><strong>其中可以采用的方式包括：</strong></p><ol><li>将类声明为final，不可被继承；</li><li>将所有的成员声明为私有的，不允许直接访问其私有成员；</li><li>对变量不向外提供set方法；</li><li>将所有成员也声明为final，只能赋值一次；</li><li>通过构造器初始化所有成员，进行深度拷贝;</li><li>在get方法中，不直接返回对象本身，而是克隆对象，并返回对象的拷贝。<a id="more"></a></li></ol></blockquote></li></ul><hr><h4 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h4><p>可以用来修饰类、方法、变量。</p><ol><li>修饰类：该类不能被继承：如Java中的String、Integer、Long等基础类型的封装类均是。</li></ol><ul><li>final类中的成员变量可根据需要设定为final。</li><li>final类中的方法均会被隐式指为final方法。</li></ul><ol start="2"><li>修饰方法：场景如下</li></ol><ul><li>锁定方法不会被继承类修改；</li><li>效率：在早期的Java实现版本中，会将final方法转为内嵌调用；但若final方法过大，反而拉低效率。</li><li><blockquote><p><strong>一个类的private方法会被隐式地指为final方法。</strong></p></blockquote></li></ul><ol start="3"><li>修饰变量：</li></ol><ul><li>若修饰基础数据类型：一旦初始化就不再更改。</li><li>若修饰引用类型：一旦初始化之后就不能再指向另一个对象。但可以修改其中的值。（好吧，这是废话…）</li></ul><p>看个例子：<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">@NotThreadSafe  <span class="comment">//非线程安全</span></span><br><span class="line"><span class="keyword">public</span> class ImmutableExample1 &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Integer a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">String</span> b = <span class="string">"2"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Map&lt;Integer, Integer&gt; <span class="built_in">map</span> = Maps.newHashMap();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="built_in">map</span>.put(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        <span class="built_in">map</span>.put(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">        <span class="built_in">map</span>.put(<span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">map</span>.put(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">        <span class="built_in">log</span>.info(<span class="string">"&#123;&#125;"</span>, <span class="built_in">map</span>.<span class="built_in">get</span>(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> test(<span class="keyword">final</span> <span class="built_in">int</span> a) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果：</p><p><img src="/2018/08/02/不可变对象/final关键字测试.png" alt="图示"></p><p><strong>结果分析：</strong><br>final修饰引用类型的Map：一旦初始化之后就不能再指向另一个对象。<br>但可以修改其中的值 -&gt; 向map中put（a,b）。</p><hr><h4 id="Collections-unmodifiableXXX方法"><a href="#Collections-unmodifiableXXX方法" class="headerlink" title="Collections.unmodifiableXXX方法"></a>Collections.unmodifiableXXX方法</h4><p>其中XXX可以是Collection、List、Set、Map等<br><strong>相应的可以通过传入对应的数据类型作为参数传入方法，即可变为不可变对象。</strong></p><p>看一个例子：<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">@ThreadSafe</span><br><span class="line"><span class="keyword">public</span> class ImmutableExample2 &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Integer, Integer&gt; <span class="built_in">map</span> = Maps.newHashMap();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="built_in">map</span>.<span class="built_in">put</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        <span class="built_in">map</span>.<span class="built_in">put</span>(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">        <span class="built_in">map</span>.<span class="built_in">put</span>(<span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">        <span class="comment">//调用unmodifiableMap方法</span></span><br><span class="line">        <span class="built_in">map</span> = Collections.unmodifiableMap(<span class="built_in">map</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line">        <span class="built_in">map</span>.<span class="built_in">put</span>(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">        log.info(<span class="string">"&#123;&#125;"</span>, <span class="built_in">map</span>.<span class="built_in">get</span>(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果：</p><p><img src="/2018/08/02/不可变对象/Collections.unmodified测试.png" alt="图示"></p><p><strong>结果分析：</strong><br>Collections.unmodifiableMap(xxx)方法根据字面意思，不允许修改。即<strong>既不允许再指向其他对象，也不能修改其中的值。</strong></p><p>再来看一下unmodifiableMap方法的源码：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Returns an unmodifiable view <span class="keyword">of</span> <span class="keyword">the</span> specified map.  This method</span><br><span class="line"> * allows modules <span class="keyword">to</span> provide users <span class="keyword">with</span> <span class="string">"read-only"</span> access <span class="keyword">to</span> internal</span><br><span class="line"> * maps.  Query operations <span class="keyword">on</span> <span class="keyword">the</span> returned map <span class="string">"read through"</span></span><br><span class="line"> * <span class="keyword">to</span> <span class="keyword">the</span> specified map, <span class="keyword">and</span> attempts <span class="keyword">to</span> modify <span class="keyword">the</span> returned</span><br><span class="line"> * map, whether direct <span class="keyword">or</span> via <span class="keyword">its</span> collection views, <span class="literal">result</span> <span class="keyword">in</span> an</span><br><span class="line"> * &lt;tt&gt;UnsupportedOperationException&lt;/tt&gt;.&lt;p&gt;</span><br><span class="line"> *</span><br><span class="line"> * The returned map will be serializable <span class="keyword">if</span> <span class="keyword">the</span> specified map</span><br><span class="line"> * <span class="keyword">is</span> serializable.</span><br><span class="line"> *</span><br><span class="line"> * @param &lt;K&gt; <span class="keyword">the</span> <span class="built_in">class</span> <span class="keyword">of</span> <span class="keyword">the</span> map keys</span><br><span class="line"> * @param &lt;V&gt; <span class="keyword">the</span> <span class="built_in">class</span> <span class="keyword">of</span> <span class="keyword">the</span> map values</span><br><span class="line"> * @param  m <span class="keyword">the</span> map <span class="keyword">for</span> which an unmodifiable view <span class="keyword">is</span> <span class="keyword">to</span> be returned.</span><br><span class="line"> * @<span class="literal">return</span> an unmodifiable view <span class="keyword">of</span> <span class="keyword">the</span> specified map.</span><br><span class="line"> */</span><br><span class="line">public static &lt;K,V&gt; Map&lt;K,V&gt; unmodifiableMap(Map&lt;? extends K, ? extends V&gt; m) &#123;</span><br><span class="line"><span class="built_in">    return</span> new UnmodifiableMap&lt;&gt;(m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注释还是非常易懂的。该类重新自定义的UnmodifiableMap，那么再看一下UnmodifiableMap的源码：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function">V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="function">V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">putAll</span><span class="params">(Map&lt;? <span class="keyword">extends</span> K, ? <span class="keyword">extends</span> V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">replaceAll</span><span class="params">(BiFunction&lt;? <span class="keyword">super</span> K, ? <span class="keyword">super</span> V, ? <span class="keyword">extends</span> V&gt; function)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="function">V <span class="title">putIfAbsent</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object key, Object value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">replace</span><span class="params">(K key, V oldValue, V newValue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="function">V <span class="title">replace</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="function">V <span class="title">computeIfAbsent</span><span class="params">(K key, Function&lt;? <span class="keyword">super</span> K, ? <span class="keyword">extends</span> V&gt; mappingFunction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>那么为什么抛出<code>UnsupportedOperationException</code>异常就一目了然了，<strong>该unmodifiableMap类自定义或重写的方法定义了直接不允许操作。</strong></p><p>再看一下<code>Collections</code>类总共提供了多少<code>unmodifiableXXX</code>方法：</p><p><img src="/2018/08/02/不可变对象/unmodifiableXXX方法种类.png" alt="图示"></p><hr><h4 id="Guava的ImmutableXXX类"><a href="#Guava的ImmutableXXX类" class="headerlink" title="Guava的ImmutableXXX类"></a>Guava的ImmutableXXX类</h4><p>相似的，其中XXX可以是<code>Collection</code>、<code>List</code>、<code>Set</code>、<code>Map</code>等<br><strong>这些类都提供了带初始化数据的声明方法，一旦初始化完成就成不可变对象了。</strong></p><p>看一个例子：<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@ThreadSafe</span><br><span class="line"><span class="keyword">public</span> class ImmutableExample3 &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> ImmutableList&lt;Integer&gt; list = ImmutableList.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> ImmutableSet <span class="built_in">set</span> = ImmutableSet.copyOf(list);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> ImmutableMap&lt;Integer, Integer&gt; <span class="built_in">map</span> = ImmutableMap.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> ImmutableMap&lt;Integer, Integer&gt; map2 = ImmutableMap.&lt;Integer, Integer&gt;builder()</span><br><span class="line">            .put(<span class="number">1</span>, <span class="number">2</span>).put(<span class="number">3</span>, <span class="number">4</span>).put(<span class="number">5</span>, <span class="number">6</span>).build();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(map2.<span class="built_in">get</span>(<span class="number">3</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果：4</p><p><strong>例子分析：</strong></p><ol><li><code>ImmutableList</code>通过<code>of(a,b,c,xxxx)</code>方法来填充数据，其中的数据为初始化的数据。</li><li><code>copyOf(xx)</code>方法直接拷贝其他集合中数据。</li><li>通过<code>builder().put(a, b)..put(x, x).(...).build()</code>不停<code>put(x,x)</code>填充数据。</li></ol><p>如果需要初始化的数据不是三个呢？<br>废话不多说，看一下<code>of()</code>的源码：<br><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;<span class="keyword">E</span>&gt; ImmutableList&lt;<span class="keyword">E</span>&gt; of(<span class="keyword">E</span> element) &#123;</span><br><span class="line">    return new SingletonImmutableList(element);</span><br><span class="line">&#125;</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">public static &lt;<span class="keyword">E</span>&gt; ImmutableList&lt;<span class="keyword">E</span>&gt; of(<span class="keyword">E</span> e1, <span class="keyword">E</span> e2, <span class="keyword">E</span> e3, <span class="keyword">E</span> e4, <span class="keyword">E</span> e5, <span class="keyword">E</span> e6, <span class="keyword">E</span> e7, <span class="keyword">E</span> e8, <span class="keyword">E</span> e9, <span class="keyword">E</span> e10, <span class="keyword">E</span> e11) &#123;</span><br><span class="line">    return construct(e1, e2, e3, e4, e5, e6, e7, e8, e9, e10, e11);</span><br><span class="line">&#125;</span><br><span class="line">@SafeVarargs</span><br><span class="line">public static &lt;<span class="keyword">E</span>&gt; ImmutableList&lt;<span class="keyword">E</span>&gt; of(<span class="keyword">E</span> e1, <span class="keyword">E</span> e2, <span class="keyword">E</span> e3, <span class="keyword">E</span> e4, <span class="keyword">E</span> e5, <span class="keyword">E</span> e6, <span class="keyword">E</span> e7, <span class="keyword">E</span> e8, <span class="keyword">E</span> e9, <span class="keyword">E</span> e10, <span class="keyword">E</span> e11, <span class="keyword">E</span> e12, <span class="keyword">E</span>... others) &#123;</span><br><span class="line">    Object[] array = new Object[12 + others.length];</span><br><span class="line">    array[0] = e1;</span><br><span class="line">    array[1] = e2;</span><br><span class="line">    array[2] = e3;</span><br><span class="line">    array[3] = e4;</span><br><span class="line">    array[4] = e5;</span><br><span class="line">    array[5] = e6;</span><br><span class="line">    array[6] = e7;</span><br><span class="line">    array[7] = e8;</span><br><span class="line">    array[8] = e9;</span><br><span class="line">    array[9] = e10;</span><br><span class="line">    array[10] = e11;</span><br><span class="line">    array[11] = e12;</span><br><span class="line">    System.arraycopy(others, 0, array, 12, others.length);</span><br><span class="line">    return construct(array);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>源码分析：</strong><br>可以看出它提供了参数从1个到11、12个的函数重载情况。再定睛一看：</p><ul><li><strong>一个注解：@SafeVarargs –&gt;安全的可变参数函数。</strong></li><li>而且参数列表里最后还有<code>E... others</code> –&gt; 指除前12参数外的参数，用一个数组表示。<h5 id="那函数里是怎么处理这个数组呢？"><a href="#那函数里是怎么处理这个数组呢？" class="headerlink" title="那函数里是怎么处理这个数组呢？"></a>那函数里是怎么处理这个数组呢？</h5>通过系统函数，将该数组安全地拷贝进来。<br>所以无论需要初始化的参数有多少都是可以处理的~ 哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈</li></ul><p><strong>其实Guava的ImmutableXXX类和Collections.unmodifiableXXX方法的实现基本是异曲同工的：</strong></p><ol><li>都是既不允许再指向其他对象，也不能修改其中的值；</li><li>否则都会抛出<code>UnsupportedOperationException</code>异常。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h4&gt;&lt;p&gt;不可变对象一经安全发布，它就是不可变的。&lt;/p&gt;
&lt;h4 id=&quot;需满足的条件&quot;&gt;&lt;a href=&quot;#需满足的条件&quot; class=&quot;headerlink&quot; title=&quot;需满足的条件&quot;&gt;&lt;/a&gt;需满足的条件&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;对象创建后其状态不能被修改；&lt;/li&gt;
&lt;li&gt;对象所有的域都是final类型；&lt;/li&gt;
&lt;li&gt;对象是正确创建的（在对象创建期间，其this引用未逸出）；&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;其中可以采用的方式包括：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;将类声明为final，不可被继承；&lt;/li&gt;
&lt;li&gt;将所有的成员声明为私有的，不允许直接访问其私有成员；&lt;/li&gt;
&lt;li&gt;对变量不向外提供set方法；&lt;/li&gt;
&lt;li&gt;将所有成员也声明为final，只能赋值一次；&lt;/li&gt;
&lt;li&gt;通过构造器初始化所有成员，进行深度拷贝;&lt;/li&gt;
&lt;li&gt;在get方法中，不直接返回对象本身，而是克隆对象，并返回对象的拷贝。&lt;/li&gt;&lt;/ol&gt;&lt;/blockquote&gt;&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="Java之并发编程" scheme="http://suprisemf.github.io/categories/Java%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java" scheme="http://suprisemf.github.io/tags/Java/"/>
    
      <category term="并发编程" scheme="http://suprisemf.github.io/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>安对象安全发布的四种策略</title>
    <link href="http://suprisemf.github.io/2018/08/02/%E5%AE%89%E5%AF%B9%E8%B1%A1%E5%AE%89%E5%85%A8%E5%8F%91%E5%B8%83%E7%9A%84%E5%9B%9B%E7%A7%8D%E7%AD%96%E7%95%A5/"/>
    <id>http://suprisemf.github.io/2018/08/02/安对象安全发布的四种策略/</id>
    <published>2018-08-02T10:23:30.000Z</published>
    <updated>2018-08-02T10:24:28.623Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本节例子内容较多~</p></blockquote><h4 id="四种方法概述"><a href="#四种方法概述" class="headerlink" title="四种方法概述"></a>四种方法概述</h4><ul><li>在静态初始化函数中初始化一个函数的引用</li><li>将对象的引用保存到volatile类型域AtomicReference对象中</li><li>将对象的引用保存到某个正确构造对象的final类型域中（后续再进行补充！）</li><li>将对象的引用保存到一个由锁保存的域中<a id="more"></a><h4 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h4></li></ul><blockquote><p>通过在Spring框架中构造线程安全且只被初始化一次的不同单例(Singleton)进行演示。</p></blockquote><h5 id="懒汉模式：（单例实例在第一次使用时进行创建）"><a href="#懒汉模式：（单例实例在第一次使用时进行创建）" class="headerlink" title="懒汉模式：（单例实例在第一次使用时进行创建）"></a>懒汉模式：（单例实例在<strong>第一次使用时进行创建</strong>）</h5><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@NotThreadSafe</span><br><span class="line">public class SingletonExample1 &#123;</span><br><span class="line"></span><br><span class="line">    // 私有构造函数</span><br><span class="line">   <span class="keyword"> private</span> SingletonExample1() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 单例对象</span><br><span class="line">   <span class="keyword"> private</span><span class="keyword"> static</span> SingletonExample1<span class="built_in"> instance </span>= null;</span><br><span class="line"></span><br><span class="line">    // 静态的工厂方法</span><br><span class="line">   <span class="keyword"> public</span><span class="keyword"> static</span> SingletonExample1 getInstance() &#123;</span><br><span class="line">       <span class="built_in"> if </span>(instance == null) &#123;</span><br><span class="line">           <span class="built_in"> instance </span>=<span class="built_in"> new </span>SingletonExample1();</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="built_in"> return </span>instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>分析一下：</strong></p><ol><li>单线程时使用没问题。</li><li>多线程时，当多个线程同时判断到instance == null，那么该多个线程都会创建一个实例，即非线程安全，因此该方法无法保证实例只被初始化一次。</li></ol><hr><h5 id="饿汉模式：（单例实例在类装载时进行创建）"><a href="#饿汉模式：（单例实例在类装载时进行创建）" class="headerlink" title="饿汉模式：（单例实例在类装载时进行创建）"></a>饿汉模式：（单例实例在类装载时进行创建）</h5><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@ThreadSafe</span><br><span class="line">public class SingletonExample2 &#123;</span><br><span class="line"></span><br><span class="line">    // 私有构造函数</span><br><span class="line">   <span class="keyword"> private</span> SingletonExample2() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 单例对象</span><br><span class="line">   <span class="keyword"> private</span><span class="keyword"> static</span> SingletonExample2<span class="built_in"> instance </span>=<span class="built_in"> new </span>SingletonExample2();</span><br><span class="line"></span><br><span class="line">    // 静态的工厂方法</span><br><span class="line">   <span class="keyword"> public</span><span class="keyword"> static</span> SingletonExample2 getInstance() &#123;</span><br><span class="line">       <span class="built_in"> return </span>instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>分析一下：</strong></p><ol><li>该方式为线程安全。</li><li>不足：如果单例类的构造方法中有较多的处理逻辑，导致类加载慢，可能会引起性能问题。</li><li>由于是饿汉模式，如果只声明了该类但实际不调用该类，即造成系统资源的浪费。</li></ol><hr><h5 id="改造的懒汉模式-1：synchronized标识工厂方法"><a href="#改造的懒汉模式-1：synchronized标识工厂方法" class="headerlink" title="改造的懒汉模式-1：synchronized标识工厂方法"></a>改造的懒汉模式-1：synchronized标识工厂方法</h5><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@ThreadSafe</span><br><span class="line">@NotRecommend</span><br><span class="line">public class SingletonExample3 &#123;</span><br><span class="line"></span><br><span class="line">    // 私有构造函数</span><br><span class="line">   <span class="keyword"> private</span> SingletonExample3() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 单例对象</span><br><span class="line">   <span class="keyword"> private</span><span class="keyword"> static</span> SingletonExample3<span class="built_in"> instance </span>= null;</span><br><span class="line"></span><br><span class="line">    // 静态的工厂方法</span><br><span class="line">   <span class="keyword"> public</span><span class="keyword"> static</span> synchronized SingletonExample3 getInstance() &#123;</span><br><span class="line">       <span class="built_in"> if </span>(instance == null) &#123;</span><br><span class="line">           <span class="built_in"> instance </span>=<span class="built_in"> new </span>SingletonExample3();</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="built_in"> return </span>instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>分析一下：</strong></p><ol><li>是线程安全的。</li><li>通过给工厂方法添加synchronized关键字实现。</li><li>不推荐使用：通过阻塞线程-&gt;牺牲性能，达到线程安全目的。</li></ol><hr><h5 id="改造的懒汉模式-2：（双重同步锁单例模式）"><a href="#改造的懒汉模式-2：（双重同步锁单例模式）" class="headerlink" title="改造的懒汉模式-2：（双重同步锁单例模式）"></a>改造的懒汉模式-2：（双重同步锁单例模式）</h5><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">@NotThreadSafe</span><br><span class="line">public class SingletonExample4 &#123;</span><br><span class="line"></span><br><span class="line">    // 私有构造函数</span><br><span class="line">   <span class="keyword"> private</span> SingletonExample4() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // JVM和cpu优化，发生了指令重排</span><br><span class="line"></span><br><span class="line">    // 1、memory = allocate() 分配对象的内存空间</span><br><span class="line">    // 3、instance = memory 设置instance指向刚分配的内存</span><br><span class="line">    // 2、ctorInstance() 初始化对象</span><br><span class="line"></span><br><span class="line">    // 单例对象</span><br><span class="line">   <span class="keyword"> private</span><span class="keyword"> static</span> SingletonExample4<span class="built_in"> instance </span>= null;</span><br><span class="line"></span><br><span class="line">    // 静态的工厂方法</span><br><span class="line">   <span class="keyword"> public</span><span class="keyword"> static</span> SingletonExample4 getInstance() &#123;</span><br><span class="line">       <span class="built_in"> if </span>(instance == null) &#123; // 双重检测机制        // B</span><br><span class="line">            synchronized (SingletonExample4.class) &#123; // 同步锁</span><br><span class="line">               <span class="built_in"> if </span>(instance == null) &#123;</span><br><span class="line">                   <span class="built_in"> instance </span>=<span class="built_in"> new </span>SingletonExample4(); // A - 3</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="built_in"> return </span>instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>分析一下：</strong></p><ol><li><strong>非线程安全</strong>。</li><li>将synchronized标识下沉到方法的实现中</li><li>外层instance == null和方法实现中的synchronized标识共同保证只有一个线程进行初始化。</li><li>内层的instance == null为防止上一时刻中可能存在的线程进行了初始化。</li></ol><h5 id="非线程安全分析："><a href="#非线程安全分析：" class="headerlink" title="非线程安全分析："></a>非线程安全分析：</h5><p>当执行实例初始化instance = new SingletonExample4()时，CPU内部过程为：</p><ol><li>memory = allocate() -&gt; 分配对象的内存空间；</li><li>ctorInstance() -&gt; 初始化对象；</li><li>instance = memory -&gt; 设置instance指向刚分配的内存。</li></ol><p><strong>但是</strong>！！<br>在<code>多线程环境</code>中，由于<strong>JVM和CPU优化</strong>，会发生指令重排，CPU内部顺序为：（其中的1、2、3是指令间的原始顺序）</p><ol><li>memory = allocate() -&gt; 分配对象的内存空间；</li><li>instance = memory -&gt; 设置instance指向刚分配的内存。</li><li>ctorInstance() -&gt; 初始化对象；</li></ol><p>因此，此时的双重同步锁机制中产生了变化：</p><p>若两个线程A和B，其中线程A执行到初始化<code>instance = new SingletonExample4()</code>，此时恰好正处于指令重排的<code>instance = memory</code> ，即设置<code>instance</code>指向刚分配的内存，同时线程B恰好处于外层的<code>instance == null</code>判断，发现此时内存中该<code>instance</code>指向的内存地址不为<code>nul</code>，则会直接<code>return instance</code>，但此时的<code>instance</code>只是分配了内存还未进行初始化，即产生错误！为<strong>非线程安全</strong>！！</p><p><font color="#7FFFD4" size="6">但是！！！！！</font><br>既然是内存中实例未完全初始化，怎么解决呢？？<br>想起来之前说过的<strong>volatile关键字</strong>的用法了没？？？<br>它通过加入<strong>内存屏障</strong>，限制JVM或CPU进行指令重排！！</p><p>将该实例用volatile标识声明：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private volatile static SingletonExample5<span class="built_in"> instance </span>= <span class="literal">null</span>;</span><br></pre></td></tr></table></figure></p><p>此时，该双重同步锁单例模式就是线程安全的了！！</p><hr><h5 id="实例枚举模式："><a href="#实例枚举模式：" class="headerlink" title="实例枚举模式："></a>实例枚举模式：</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonExample7</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonExample7</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonExample7 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Singleton.INSTANCE.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//枚举类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">enum</span> Singleton &#123;</span><br><span class="line">        INSTANCE;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> SingletonExample7 singleton;</span><br><span class="line"></span><br><span class="line">        Singleton() &#123;</span><br><span class="line">            singleton = <span class="keyword">new</span> SingletonExample7();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> SingletonExample7 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> singleton;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>分析一下：</strong></p><ol><li>枚举模式是最安全的！较推荐的写法！</li><li>通过枚举类中指定一个单例<code>Singleton</code>的实例<code>INSTANCE</code>枚举实现。</li><li>其中<code>Singleton(){xxxx}</code>域，是通过JVM保证这个方法在被调用前初始化，并绝对只调用一次。</li><li>相比于懒汉模式，它的安全性更易保证；相比于饿汉模式，它是在实际调用时才进行初始化，并直接取到其值，不会有系统资源的占用浪费。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本节例子内容较多~&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;四种方法概述&quot;&gt;&lt;a href=&quot;#四种方法概述&quot; class=&quot;headerlink&quot; title=&quot;四种方法概述&quot;&gt;&lt;/a&gt;四种方法概述&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;在静态初始化函数中初始化一个函数的引用&lt;/li&gt;
&lt;li&gt;将对象的引用保存到volatile类型域AtomicReference对象中&lt;/li&gt;
&lt;li&gt;将对象的引用保存到某个正确构造对象的final类型域中（后续再进行补充！）&lt;/li&gt;
&lt;li&gt;将对象的引用保存到一个由锁保存的域中&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="Java之并发编程" scheme="http://suprisemf.github.io/categories/Java%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java" scheme="http://suprisemf.github.io/tags/Java/"/>
    
      <category term="并发编程" scheme="http://suprisemf.github.io/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>安全发布对象——发布与逸出</title>
    <link href="http://suprisemf.github.io/2018/08/02/%E5%AE%89%E5%85%A8%E5%8F%91%E5%B8%83%E5%AF%B9%E8%B1%A1%E2%80%94%E2%80%94%E5%8F%91%E5%B8%83%E4%B8%8E%E9%80%B8%E5%87%BA/"/>
    <id>http://suprisemf.github.io/2018/08/02/安全发布对象——发布与逸出/</id>
    <published>2018-08-02T10:07:30.000Z</published>
    <updated>2018-08-02T10:20:36.072Z</updated>
    
    <content type="html"><![CDATA[<h4 id="对象发布"><a href="#对象发布" class="headerlink" title="对象发布"></a>对象发布</h4><p>使一个对象能够被其他范围之外的对象/代码所使用。</p><blockquote><p>实际日常开发中经常发布对象的例子有：</p><ol><li>通过类的非私有方法，返回对象的引用；</li><li>通过公有的静态变量发布对象</li></ol></blockquote><a id="more"></a><h4 id="对象逸出"><a href="#对象逸出" class="headerlink" title="对象逸出"></a>对象逸出</h4><p>是一种错误的对象发布。当一个对象还未构造完成就已经被其他的线程观察到。</p><h5 id="发布对象示范例子："><a href="#发布对象示范例子：" class="headerlink" title="发布对象示范例子："></a>发布对象示范例子：</h5><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@NotThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> NotSafePublish &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">String</span>[] states = &#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过类的非私有方法，返回对象的引用</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">String</span>[] getStates() &#123;</span><br><span class="line">        <span class="keyword">return</span> states;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> main(<span class="built_in">String</span>[] args) &#123;</span><br><span class="line">        NotSafePublish unsafePublish = <span class="keyword">new</span> NotSafePublish();</span><br><span class="line">        log.info(<span class="string">"&#123;&#125;"</span>, Arrays.toString(unsafePublish.getStates()));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过上面的非法发布，修改其私有变量</span></span><br><span class="line">        unsafePublish.getStates()[<span class="number">0</span>] = <span class="string">"d"</span>;</span><br><span class="line">        log.info(<span class="string">"&#123;&#125;"</span>, Arrays.toString(unsafePublish.getStates()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察结果：</p><p><img src="/2018/08/02/安全发布对象——发布与逸出/非法发布测试.png" alt="图示"></p><p>显然该发布方式是<strong>非线程安全</strong>的。</p><h5 id="对象逸出示范例子："><a href="#对象逸出示范例子：" class="headerlink" title="对象逸出示范例子："></a>对象逸出示范例子：</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Escape</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义可能会逸出的私有变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> thisCanEscape = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回一内部类的引用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Escape</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> InnerClass();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//私有内部类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span> &#123;</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">InnerClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="built_in">log</span>.info(<span class="string">"&#123;&#125;"</span>, Escape.<span class="keyword">this</span>.thisCanEscape);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//调用公有方法</span></span><br><span class="line">        <span class="keyword">new</span> Escape();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察结果：</p><p><img src="/2018/08/02/安全发布对象——发布与逸出/发布逸出.png" alt="图示"></p><p>显然内部类的成员变量被一个公有方法观察到了！</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>显然上述的方式都是错误的，不被推荐的！<br>不正确地发布对象可能会导致两种错误：</p><ol><li>发布对象所在线程以外的线程都可以看到发布对象的值（状态）。</li><li>（更严重）其他线程看到的对象的引用是最新的，但值（状态）是已过期的。</li></ol><p>若该对象是可变对象，那么它必须要被安全发布。 <em>对象未完成之前不可以将其发布。</em> 多多注意。</p><p><strong>避免方法：通过专有的start()或初始化方法统一启动。其中可以采用工厂方法结合私有构造函数，完成对象的创建和监听器的注册</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;对象发布&quot;&gt;&lt;a href=&quot;#对象发布&quot; class=&quot;headerlink&quot; title=&quot;对象发布&quot;&gt;&lt;/a&gt;对象发布&lt;/h4&gt;&lt;p&gt;使一个对象能够被其他范围之外的对象/代码所使用。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;实际日常开发中经常发布对象的例子有：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;通过类的非私有方法，返回对象的引用；&lt;/li&gt;
&lt;li&gt;通过公有的静态变量发布对象&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Java之并发编程" scheme="http://suprisemf.github.io/categories/Java%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java" scheme="http://suprisemf.github.io/tags/Java/"/>
    
      <category term="并发编程" scheme="http://suprisemf.github.io/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>线程安全-有序性</title>
    <link href="http://suprisemf.github.io/2018/08/02/%E7%BA%BF%E7%A8%8B%E5%AE%89-%E6%9C%89%E5%BA%8F%E6%80%A7/"/>
    <id>http://suprisemf.github.io/2018/08/02/线程安-有序性/</id>
    <published>2018-08-02T10:04:36.000Z</published>
    <updated>2018-08-02T10:05:45.345Z</updated>
    
    <content type="html"><![CDATA[<h4 id="问题导出"><a href="#问题导出" class="headerlink" title="问题导出"></a>问题导出</h4><ol><li>Java内存模型中，允许编译器和翻译器对指令进行重排序，但是重排序的过程不会影响到<strong>单线程</strong>程序的运行，却会影响到多线程并发执行的正确性。</li><li>Java中的volatile通过<code>内存屏障</code>也可以一定程度上禁止指令的重排序。</li><li>synchronized和Lock机制都是通过线程阻塞对于主内存来讲其同一时刻只有一个线程可以访问操作，保证了有序性。</li><li>Java内存模型实际存在先天的有序性：不需要通过任何手段即可保证一定的有序性，即happens-before原则。</li></ol><a id="more"></a><blockquote><p>如果两个操作的次序无法从happens-before原则中得到保证，那么该两个操作不能保证自己的有序性：即被JVM随意地进行重排序。</p></blockquote><h4 id="happens-before原则"><a href="#happens-before原则" class="headerlink" title="happens-before原则"></a>happens-before原则</h4><blockquote><p>前四条较为重要，后四条浅显易懂</p></blockquote><ol><li>程序次序规则：<strong>单线程内</strong>，按照代码顺序，书写在前面的操作先行发生与书写在后面的操作。（此时的JVM只会对非数据依赖的指令进行重排序）</li><li>锁定规则：一个unlock操作先行发生于后面对同一个锁的lock操作。</li><li><strong>volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作。</strong></li><li>传递规则：若操作A先行发生于操作B，B又先行发生于操作C，那么操作A先行发生于操作C。</li><li>线程启动规则：Thread对象的start()方法先行发生于此线程的每一个动作。</li><li>线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生。</li><li>线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行。</li><li>对象终结规则：一个对象的初始化完成先行发生于它的finalize()方法的开始。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;问题导出&quot;&gt;&lt;a href=&quot;#问题导出&quot; class=&quot;headerlink&quot; title=&quot;问题导出&quot;&gt;&lt;/a&gt;问题导出&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;Java内存模型中，允许编译器和翻译器对指令进行重排序，但是重排序的过程不会影响到&lt;strong&gt;单线程&lt;/strong&gt;程序的运行，却会影响到多线程并发执行的正确性。&lt;/li&gt;
&lt;li&gt;Java中的volatile通过&lt;code&gt;内存屏障&lt;/code&gt;也可以一定程度上禁止指令的重排序。&lt;/li&gt;
&lt;li&gt;synchronized和Lock机制都是通过线程阻塞对于主内存来讲其同一时刻只有一个线程可以访问操作，保证了有序性。&lt;/li&gt;
&lt;li&gt;Java内存模型实际存在先天的有序性：不需要通过任何手段即可保证一定的有序性，即happens-before原则。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Java之并发编程" scheme="http://suprisemf.github.io/categories/Java%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java" scheme="http://suprisemf.github.io/tags/Java/"/>
    
      <category term="并发编程" scheme="http://suprisemf.github.io/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>线程安全-可见性</title>
    <link href="http://suprisemf.github.io/2018/08/02/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8-%E5%8F%AF%E8%A7%81%E6%80%A7/"/>
    <id>http://suprisemf.github.io/2018/08/02/线程安全-可见性/</id>
    <published>2018-08-02T09:55:33.000Z</published>
    <updated>2018-08-02T10:01:10.467Z</updated>
    
    <content type="html"><![CDATA[<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>指一个线程对主内存的修改，可以及时地被其他线程观察到。</p><blockquote><p>导致共享变量在线程间不可见的原因有：</p><ol><li>多线程交叉进行。</li><li>重排序结合多线程运行。</li><li>共享变量更新后的值未及时进行工作内存与主内存的更新。</li></ol></blockquote><a id="more"></a><h4 id="可见性之synchronized关键字"><a href="#可见性之synchronized关键字" class="headerlink" title="可见性之synchronized关键字"></a>可见性之synchronized关键字</h4><p>Java内存模型对synchronized关键字有两条规定。</p><ol><li>线程解锁前必须把共享变量的最新值刷新到主内存。</li><li>线程加锁时，将清空工作内存中共享变量的值。那么工作内存需要时只能从工作内存中取值。</li></ol><p><strong>工作原理：此时的加锁和解锁用的是一个锁，即多线程之间共享synchronized一个锁。</strong></p><h4 id="可见性之volatile关键字"><a href="#可见性之volatile关键字" class="headerlink" title="可见性之volatile关键字"></a>可见性之volatile关键字</h4><p><strong>工作原理：通过加入<code>内存屏障</code>和<code>禁止重排序优化</code>来实现，即通过<code>内存屏障</code>保证了<code>禁止重排序优化</code></strong><br><code>内存屏障</code>从以下两点进行说明：</p><ol><li>对volatile变量进行写操作时，会在写操作后加入一条store屏障指令，将本地工作内存中的值刷新到主内存。</li><li>对volatile变量进行读操作时，会在读操作前加入一条load屏障指令，从主内存读取共享变量的值。<blockquote><p>即强迫从主内存中的共享变量进行交互。</p></blockquote></li></ol><p><strong>volatile写原理：</strong></p><p><img src="/2018/08/02/线程安全-可见性/volatile写.png" alt="volatile写"></p><p><strong>volatile读原理：</strong></p><p><img src="/2018/08/02/线程安全-可见性/volatile读.png" alt="volatile读"></p><p>示例代码：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@NotThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountExample4</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求总数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> clientTotal = <span class="number">5000</span>;</span><br><span class="line">    <span class="comment">// 同时并发执行的线程数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> threadTotal = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(threadTotal);</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(clientTotal);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clientTotal ; i++) &#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    add();</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.<span class="keyword">error</span>(<span class="string">"exception"</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">        log.info(<span class="string">"count:&#123;&#125;"</span>, count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="comment">// 1、count</span></span><br><span class="line">        <span class="comment">// 2、+1</span></span><br><span class="line"></span><br><span class="line">    &#125;<span class="comment">// 3、count</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>多次运行结果：仍然无法保证线程安全<br>两次测试结果如下：</p><p><img src="/2018/08/02/线程安全-可见性/volatile可见性测试-1.png" alt="图示"></p><p><img src="/2018/08/02/线程安全-可见性/volatile可见性测试-2.png" alt="图示"></p><h5 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h5><p>volatile修饰的count进行++时，分为三步进行：</p><ol><li>取出count</li><li>count+1</li><li>写入count</li></ol><p>已知在第一步的取数时，取出的都是主内存的最新值。<strong>但是写入的时候就可能发生问题。</strong> 当多个线程进行操作时，同时取出主内存中的<code>count</code>，并执行+1，然后同时写入主内存，那么导致请求总数永远比<code>clientcount</code>值小，即<strong>volatile关键字只能保证可见性，但并具有原子性，不能保证线程安全</strong>！</p><h5 id="volatile使用的场景"><a href="#volatile使用的场景" class="headerlink" title="volatile使用的场景"></a>volatile使用的场景</h5><p>场景需具备的条件：</p><ol><li>对变量的写操作不依赖与当前值</li><li>该变量没有包含在具有其他变量的不变的式子中。</li></ol><p>因此，</p><ol><li><strong><code>volatile</code>适合作为状态标记量(boolean型)</strong></li><li><strong>适用于<code>doublecheck</code>场景。</strong>（例子会在之后手记中添上……）</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h4&gt;&lt;p&gt;指一个线程对主内存的修改，可以及时地被其他线程观察到。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;导致共享变量在线程间不可见的原因有：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;多线程交叉进行。&lt;/li&gt;
&lt;li&gt;重排序结合多线程运行。&lt;/li&gt;
&lt;li&gt;共享变量更新后的值未及时进行工作内存与主内存的更新。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Java之并发编程" scheme="http://suprisemf.github.io/categories/Java%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java" scheme="http://suprisemf.github.io/tags/Java/"/>
    
      <category term="并发编程" scheme="http://suprisemf.github.io/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>内在锁Synchronized关键字</title>
    <link href="http://suprisemf.github.io/2018/08/02/%E5%86%85%E5%9C%A8%E9%94%81synchronized%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>http://suprisemf.github.io/2018/08/02/内在锁synchronized关键字/</id>
    <published>2018-08-02T09:50:50.000Z</published>
    <updated>2018-08-02T09:51:56.257Z</updated>
    
    <content type="html"><![CDATA[<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>Java 语言中主要的同步手段就是 synchronized 关键字，它强制实行互斥，确保执行 synchronized 块的线程的动作，能够被后来执行受相同锁保护的 synchronized 块的其他线程看到。<a id="more"></a><br>在使用得当的时候，内在锁可以让程序做到线程安全，但是在使用锁定保护短的代码路径，而且线程频繁地争用锁的时候，锁定可能成为相当繁重的操作。<a href="https://www.ibm.com/developerworks/cn/java/j-jtp04186/" target="_blank" rel="noopener">参考学习</a></p><blockquote><p>内在锁synchronized关键字的实现依赖于JVM，因此<strong>在这个关键字作用的对象的作用范围内都是同一时刻只能有一个线程进行操作。</strong></p></blockquote><p>它是一种同步锁，作用对象有四种：</p><ol><li>修饰代码块：指用大括号括起来的代码，被称为“同步代码块”，作用于调用该代码块的对象。</li><li>修饰方法：指整个方法，被称为同步方法，作用于调用该方法的对象。</li><li>修饰静态方法：指整个静态方法，由于静态方法可以被理解为类级别的对象，因此它作用于该类的所有的对象。</li><li>修饰类：指整个类，作用于该类的所有的对象。</li></ol><h4 id="引申拓展：另一种锁Lock"><a href="#引申拓展：另一种锁Lock" class="headerlink" title="引申拓展：另一种锁Lock"></a>引申拓展：另一种锁Lock</h4><p>JDK提供的基于源码的锁，依赖于特殊的CPU指令、代码实现。其代表为ReentrantLock.<br>后续将会单独做一篇手记。</p><h4 id="线程安全中原子性方式的简单对比"><a href="#线程安全中原子性方式的简单对比" class="headerlink" title="线程安全中原子性方式的简单对比"></a>线程安全中原子性方式的简单对比</h4><ol><li>synchronized：是不可中断锁，适合竞争不激烈的场景，其可读性较好。</li><li>Lock：可通过unlock进行锁的中断，在竞争激烈时仍可以保持常态，同步多样化。</li><li>Atomic包：竞争激烈时也可以保持常态，性能比Lock好，但缺点是只能通过CAS同步一个值。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h4&gt;&lt;p&gt;Java 语言中主要的同步手段就是 synchronized 关键字，它强制实行互斥，确保执行 synchronized 块的线程的动作，能够被后来执行受相同锁保护的 synchronized 块的其他线程看到。&lt;/p&gt;
    
    </summary>
    
      <category term="Java之并发编程" scheme="http://suprisemf.github.io/categories/Java%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java" scheme="http://suprisemf.github.io/tags/Java/"/>
    
      <category term="并发编程" scheme="http://suprisemf.github.io/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>AtomicStampReference：CAS中的ABA问题</title>
    <link href="http://suprisemf.github.io/2018/08/02/AtomicStampReference%EF%BC%9ACAS%E4%B8%AD%E7%9A%84ABA%E9%97%AE%E9%A2%98/"/>
    <id>http://suprisemf.github.io/2018/08/02/AtomicStampReference：CAS中的ABA问题/</id>
    <published>2018-08-02T09:47:36.000Z</published>
    <updated>2018-08-02T09:48:37.806Z</updated>
    
    <content type="html"><![CDATA[<h4 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h4><blockquote><p>CAS算法实现一个重要前提：<strong>需要取出内存中某时刻的数据，而在下时刻比较并替换，那么在这个时间差类会导致数据的变化。</strong></p></blockquote><a id="more"></a><p>举一个例子：<br>现有一个用单向链表实现的堆栈，栈顶为A，这时线程T1已经知道A.next为B，然后希望用CAS将栈顶替换为B：进行<code>head.compareAndSet(A,B)</code>，在T1执行上面这条指令之前，线程T2介入，将A、B出栈，再pushD、C、A，而对象B此时正处于游离状态；若此时轮到线程T1执行CAS操作，检测发现栈顶仍为A，所以CAS成功，栈顶变为B，但实际上B.next为null。结果现在堆栈中只有B一个元素，C和D组成的链表不再存在于堆栈中，此时C、D平白无故被弄丢了。</p><h5 id="其实还有另外一种情况："><a href="#其实还有另外一种情况：" class="headerlink" title="其实还有另外一种情况："></a>其实还有另外一种情况：</h5><p><strong>A最开始的内存地址是X，然后失效了，有分配了B，恰好内存地址是X，这时候通过CAS操作也成功了</strong>，但是在像Java这种有GC机制的语言中，若A失效就被GC处理了，不会发生这种情况。若是在像C/C++没有GC机制的语言中是有可能出现的。</p><h5 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h5><ol><li>像各种乐观锁的实现中通常都会用版本戳version(保持递增加一规则)来对记录或对象标记，在CAS时加上对该版本戳的比较。</li><li>在Java语言中，AtomicStampedReference<e>也是使用类似的机制做解决方案。</e></li></ol><p>其核心方法为：<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Atomically sets the value of both the reference and stamp</span></span><br><span class="line"><span class="comment"> * to the given update values if the</span></span><br><span class="line"><span class="comment"> * current reference is &#123;@code ==&#125; to the expected reference</span></span><br><span class="line"><span class="comment"> * and the current stamp is equal to the expected stamp.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param expectedReference the expected value of the reference</span></span><br><span class="line"><span class="comment"> * @param newReference the new value for the reference</span></span><br><span class="line"><span class="comment"> * @param expectedStamp the expected value of the stamp</span></span><br><span class="line"><span class="comment"> * @param newStamp the new value for the stamp</span></span><br><span class="line"><span class="comment"> * @return &#123;@code true&#125; if successful</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> boolean compareAndSet(V   expectedReference,</span><br><span class="line">                             V   <span class="keyword">new</span><span class="type">Reference</span>,</span><br><span class="line">                             int expectedStamp,</span><br><span class="line">                             int <span class="keyword">new</span><span class="type">Stamp</span>) &#123;</span><br><span class="line">    Pair&lt;V&gt; current = pair;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">        expectedReference == current.reference &amp;&amp;</span><br><span class="line">        expectedStamp == current.stamp &amp;&amp;</span><br><span class="line">        ((<span class="keyword">new</span><span class="type">Reference</span> == current.reference &amp;&amp;</span><br><span class="line">          <span class="keyword">new</span><span class="type">Stamp</span> == current.stamp) ||</span><br><span class="line">         casPair(current, Pair.of(<span class="keyword">new</span><span class="type">Reference</span>, <span class="keyword">new</span><span class="type">Stamp</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中设定stamp值的原子性方法为：由于是非阻塞方法，即使两个参数对应，请求也会不合逻辑地失败。但最终当没有其他线程请求时就会成功。<a href="https://www.ibm.com/developerworks/cn/java/j-jtp04186/" target="_blank" rel="noopener">推荐阅读</a><br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Atomically sets <span class="keyword">the</span> value <span class="keyword">of</span> <span class="keyword">the</span> stamp <span class="keyword">to</span> <span class="keyword">the</span> <span class="keyword">given</span> update value</span><br><span class="line"> * <span class="keyword">if</span> <span class="keyword">the</span> current <span class="keyword">reference</span> <span class="keyword">is</span> &#123;@code ==&#125; <span class="keyword">to</span> <span class="keyword">the</span> expected</span><br><span class="line"> * <span class="keyword">reference</span>.  Any <span class="keyword">given</span> invocation <span class="keyword">of</span> this operation may fail</span><br><span class="line"> * (<span class="literal">return</span> &#123;@code <span class="literal">false</span>&#125;) spuriously, <span class="keyword">but</span> repeated invocation</span><br><span class="line"> * when <span class="keyword">the</span> current value holds <span class="keyword">the</span> expected value <span class="keyword">and</span> no other</span><br><span class="line"> * thread <span class="keyword">is</span> also attempting <span class="keyword">to</span> <span class="keyword">set</span> <span class="keyword">the</span> value will eventually</span><br><span class="line"> * succeed.</span><br><span class="line"> *</span><br><span class="line"> * @param expectedReference <span class="keyword">the</span> expected value <span class="keyword">of</span> <span class="keyword">the</span> <span class="keyword">reference</span></span><br><span class="line"> * @param newStamp <span class="keyword">the</span> new value <span class="keyword">for</span> <span class="keyword">the</span> stamp</span><br><span class="line"> * @<span class="literal">return</span> &#123;@code <span class="literal">true</span>&#125; <span class="keyword">if</span> successful</span><br><span class="line"> */</span><br><span class="line">public <span class="built_in">boolean</span> attemptStamp(V expectedReference, int newStamp) &#123;</span><br><span class="line">    Pair&lt;V&gt; current = pair;</span><br><span class="line"><span class="built_in">    return</span></span><br><span class="line">        expectedReference == current.<span class="keyword">reference</span> &amp;&amp;</span><br><span class="line">        (newStamp == current.stamp ||</span><br><span class="line">         casPair(current, Pair.<span class="keyword">of</span>(expectedReference, newStamp)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面都用到unsafe的原子性方法compareAndSwapObject(xxxx)：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> boolean casPair(Pair&lt;V&gt; cmp, Pair&lt;V&gt; <span class="keyword">val</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, pairOffset, cmp, <span class="keyword">val</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;问题分析&quot;&gt;&lt;a href=&quot;#问题分析&quot; class=&quot;headerlink&quot; title=&quot;问题分析&quot;&gt;&lt;/a&gt;问题分析&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;CAS算法实现一个重要前提：&lt;strong&gt;需要取出内存中某时刻的数据，而在下时刻比较并替换，那么在这个时间差类会导致数据的变化。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Java之并发编程" scheme="http://suprisemf.github.io/categories/Java%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java" scheme="http://suprisemf.github.io/tags/Java/"/>
    
      <category term="并发编程" scheme="http://suprisemf.github.io/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>线程安全之原子性--Atomic包-Part-3</title>
    <link href="http://suprisemf.github.io/2018/08/02/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B9%8B%E5%8E%9F%E5%AD%90%E6%80%A7-Atomic%E5%8C%85-part-3/"/>
    <id>http://suprisemf.github.io/2018/08/02/线程安全之原子性-Atomic包-part-3/</id>
    <published>2018-08-02T09:33:31.000Z</published>
    <updated>2018-08-02T09:44:22.954Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p> AtomicReference与AtomicReferenceFiledUpdater比较分析</p></blockquote><a id="more"></a><h4 id="AtomicReference分析"><a href="#AtomicReference分析" class="headerlink" title="AtomicReference分析"></a>AtomicReference分析</h4><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">@ThreadSafe</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicExample4</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicReference&lt;Integer&gt; <span class="keyword">count</span> = <span class="keyword">new</span> AtomicReference&lt;&gt;(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</span><br><span class="line">        <span class="keyword">count</span>.compareAndSet(<span class="number">0</span>, <span class="number">2</span>); <span class="comment">// 更新为2</span></span><br><span class="line">        <span class="keyword">count</span>.compareAndSet(<span class="number">0</span>, <span class="number">1</span>); <span class="comment">// 不</span></span><br><span class="line">        <span class="keyword">count</span>.compareAndSet(<span class="number">1</span>, <span class="number">3</span>); <span class="comment">// 不</span></span><br><span class="line">        <span class="keyword">count</span>.compareAndSet(<span class="number">2</span>, <span class="number">4</span>); <span class="comment">// 更新为4</span></span><br><span class="line">        <span class="keyword">count</span>.compareAndSet(<span class="number">3</span>, <span class="number">5</span>); <span class="comment">// 不</span></span><br><span class="line">        log.info(<span class="string">"count:&#123;&#125;"</span>, <span class="keyword">count</span>.get());</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果为：</p><p><img src="/2018/08/02/线程安全之原子性-Atomic包-part-3/AtomicReference测试-1.png" alt="图示"></p><p>根据结果，可以看出其运行顺序跟我们预期是完全吻合的。</p><p>看一下AtomicReference的compareAndSet(a, b)方法源码：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="function"><span class="keyword">void</span> <span class="title">lazySet</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">    unsafe.putOrderedObject(<span class="keyword">this</span>, valueOffset, newValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Atomically sets the value to the given updated value</span></span><br><span class="line"><span class="comment"> * if the current value &#123;<span class="doctag">@code</span> ==&#125; the expected value.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> expect the expected value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> update the new value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if successful. False return indicates that</span></span><br><span class="line"><span class="comment"> * the actual value was not equal to the expected value.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="function"><span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(V expect, V update)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">return</span> unsafe.<span class="title">compareAndSwapObject</span><span class="params">(<span class="keyword">this</span>, valueOffset, expect, update)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>又是调用的unsafe.compareAndSwapObject(xxx)，再看一下：<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="built_in">boolean</span> compareAndSwapObject(<span class="keyword">Object</span> var1, <span class="keyword">long</span> var2, <span class="keyword">Object</span> var4, <span class="keyword">Object</span> var5);</span><br></pre></td></tr></table></figure></p><p>看来这个类真的是个典型的AtomicXXX类！</p><h4 id="AtomicReferenceFiledUpdater分析"><a href="#AtomicReferenceFiledUpdater分析" class="headerlink" title="AtomicReferenceFiledUpdater分析"></a>AtomicReferenceFiledUpdater分析</h4><p>写出一个小例子：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">@ThreadSafe</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicExample5</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//指明更新的类为AtomicExample5</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicIntegerFieldUpdater&lt;AtomicExample5&gt; updater =</span><br><span class="line">            <span class="comment">//newUpdater()的第一个参数为该指明的类的class，第二参数为作用的字段区域的名字filedName（该字段必须被volatile标识声明）</span></span><br><span class="line">            AtomicIntegerFieldUpdater.newUpdater(AtomicExample5.class, <span class="string">"count"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加get方法</span></span><br><span class="line">    @Getter</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">int</span> count = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        AtomicExample5 example5 = <span class="keyword">new</span> AtomicExample5();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (updater.compareAndSet(example5, <span class="number">100</span>, <span class="number">120</span>)) &#123;</span><br><span class="line">            <span class="built_in">log</span>.info(<span class="string">"update success 1, &#123;&#125;"</span>, example5.getCount());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (updater.compareAndSet(example5, <span class="number">100</span>, <span class="number">120</span>)) &#123;</span><br><span class="line">            <span class="built_in">log</span>.info(<span class="string">"update success 2, &#123;&#125;"</span>, example5.getCount());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">log</span>.info(<span class="string">"update failed, &#123;&#125;"</span>, example5.getCount());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其输出结果正如预期为：</p><p><img src="/2018/08/02/线程安全之原子性-Atomic包-part-3/AtomicReferenceFiledUpdater测试.png" alt="图示"></p><p><strong>AtomicReferenceFieldUpdater的核心为：原子性地去更新某一个类的实例中指定的某一个字段，而该字段必须使用volatile标识且不能被static标识进行声明。</strong></p><h4 id="手记小总结"><a href="#手记小总结" class="headerlink" title="手记小总结"></a>手记小总结</h4><p>AtomicReference与AtomicReferenceFieldUpdater都是用于原子性地修改更新，都是线程安全的。但是后者是通过指定类的实例中的某一个字段，且该字段必须使用volatile标识且非static标识进行声明。<br>这两个类实际中用到的都不是很多……</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt; AtomicReference与AtomicReferenceFiledUpdater比较分析&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Java之并发编程" scheme="http://suprisemf.github.io/categories/Java%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java" scheme="http://suprisemf.github.io/tags/Java/"/>
    
      <category term="并发编程" scheme="http://suprisemf.github.io/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>线程安全之原子性--Atomic包-Part-2</title>
    <link href="http://suprisemf.github.io/2018/08/02/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B9%8B%E5%8E%9F%E5%AD%90%E6%80%A7-Atomic%E5%8C%85-part-2/"/>
    <id>http://suprisemf.github.io/2018/08/02/线程安全之原子性-Atomic包-part-2/</id>
    <published>2018-08-02T09:29:56.000Z</published>
    <updated>2018-08-02T09:32:36.242Z</updated>
    
    <content type="html"><![CDATA[<h4 id="AtomicLong与AtomicInteger"><a href="#AtomicLong与AtomicInteger" class="headerlink" title="AtomicLong与AtomicInteger"></a>AtomicLong与AtomicInteger</h4><p>根据part-1中代码，其实使用<code>AtomicLong</code>代替<code>AtomicInteger</code>，而其他不用替换是完全可以的。同样也是线程安全的。</p><h3 id="AtomicLong与LongAdder"><a href="#AtomicLong与LongAdder" class="headerlink" title="AtomicLong与LongAdder"></a>AtomicLong与LongAdder</h3><p>但是重点是JDK 1.8中新增的<code>LongAdder</code>类，它与<code>AtomicLong</code>在上节的测试中有相同的效果（线程安全），只需稍微换成各自对应的方法即可。</p><a id="more"></a><p><strong>那两者的区别是什么？</strong></p><p>肯定的说，新增的该类一定或多或少比<code>AtomicLong</code>类及<code>AtomicInteger</code>类有优点的，那么是什么？<br>浅析如下：</p><h5 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h5><ol><li><p>由于AtomicLong的底层是CAS原理，即通过死循环不断地比较当前值与主内存的值，那么当线程并发量较少时其比较成功的概率是高的，但放并发量很大时，比较成功概率就会很低，越低则死循环持续的时间越久，占用的系统资源越大，系统运行的效率越低。</p></li><li><p>对于基础数据类型的long或double时,JVM会允许将64位的读操作或写操作拆分为两个32位的操作。同理，LongAdder也是采用相似的思想。</p><blockquote><p>LongAdder的实现思想为：<strong>热点数据分离</strong>：将AtomicLong的核心数据value分离为一个数组，每个线程访问时通过hash等算法预测到其中的一个数字进行计数，最终的计数结果为该数组各部分的求和。热点数据value会被分为多个部分的shell，每个shell独自维护各自的值，而当前对象的实际值为各部分shell的累加和。保证热点数据的有效分离，提高并行度。<strong>LongAdder类实际是在AtomicLong的基础上进行了优化：在低并发时不做分离，同AtomicLong是对base的直接CAS更新，但是高并发时将单点的压力分摊到各部分的shell上以提高性能。</strong></p></blockquote></li></ol><h5 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h5><p>该类将数据分类后，再次进行各部分shell的数据进行统计时，如果此时存在并发更新，可能会导致统计的数据出现误差。</p><p><strong>实际使用中，在处理高并发情况的时候要优先使用LongAdder类。当线程竞争低、全局唯一的准确是数值类似序列号生成等情况优先使用AtomicXXX类</strong></p><h4 id="知识拓展补充"><a href="#知识拓展补充" class="headerlink" title="知识拓展补充"></a>知识拓展补充</h4><p>下表为JAVA的8种基本数据类型所占位数及初始值:<br>基础数据类型 | 所占位数 | 初始值<br>-|-|-<br>byte字节型| 1字节(8bit) |    0<br>char字符型  | 2字节(16bit)    | 空格<br>short短整型 |  2字节(16bit)    | 0<br>int整型 |  4字节(32bit)    | 0<br>long长整型  | 8字节(64Bit)    | 0L<br>float单精度浮点型 |  4字节(32bit)    | 0.0f<br>double双精度浮点型  | 8字节(64bit) |    0.0d<br>boolean    | java未明确指出的大小(可能1bit、1byte、4byte)    | false</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;AtomicLong与AtomicInteger&quot;&gt;&lt;a href=&quot;#AtomicLong与AtomicInteger&quot; class=&quot;headerlink&quot; title=&quot;AtomicLong与AtomicInteger&quot;&gt;&lt;/a&gt;AtomicLong与AtomicInteger&lt;/h4&gt;&lt;p&gt;根据part-1中代码，其实使用&lt;code&gt;AtomicLong&lt;/code&gt;代替&lt;code&gt;AtomicInteger&lt;/code&gt;，而其他不用替换是完全可以的。同样也是线程安全的。&lt;/p&gt;
&lt;h3 id=&quot;AtomicLong与LongAdder&quot;&gt;&lt;a href=&quot;#AtomicLong与LongAdder&quot; class=&quot;headerlink&quot; title=&quot;AtomicLong与LongAdder&quot;&gt;&lt;/a&gt;AtomicLong与LongAdder&lt;/h3&gt;&lt;p&gt;但是重点是JDK 1.8中新增的&lt;code&gt;LongAdder&lt;/code&gt;类，它与&lt;code&gt;AtomicLong&lt;/code&gt;在上节的测试中有相同的效果（线程安全），只需稍微换成各自对应的方法即可。&lt;/p&gt;
    
    </summary>
    
      <category term="Java之并发编程" scheme="http://suprisemf.github.io/categories/Java%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java" scheme="http://suprisemf.github.io/tags/Java/"/>
    
      <category term="并发编程" scheme="http://suprisemf.github.io/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>第一次并发模拟</title>
    <link href="http://suprisemf.github.io/2018/08/02/%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%B9%B6%E5%8F%91%E6%A8%A1%E6%8B%9F/"/>
    <id>http://suprisemf.github.io/2018/08/02/第一次并发模拟/</id>
    <published>2018-08-02T08:47:39.000Z</published>
    <updated>2018-08-02T09:20:30.750Z</updated>
    
    <content type="html"><![CDATA[<h4 id="关键源码"><a href="#关键源码" class="headerlink" title="关键源码"></a>关键源码</h4><blockquote><p>这是我的第一次并发模拟的演示例子，是使用SpringBoot搭建演示环境。虽然很简单，但是万丈高楼平地起，基础得打好~之后我会更加详实地补充高级内容！</p></blockquote><a id="more"></a><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//为输出方便，加log注解</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@NotThreadSafe</span>  <span class="comment">//该自定义注解只是标示其为非线程安全类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrencyTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//请求总数量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> clientTotal = <span class="number">5000</span>;</span><br><span class="line">    <span class="comment">//并发数量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> threadTotal = <span class="number">200</span>;</span><br><span class="line">    <span class="comment">//用来计数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//定义线程池</span></span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="comment">//定义信号量,参数为并发数量</span></span><br><span class="line">        <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(threadTotal);</span><br><span class="line">        <span class="comment">//参数为请求总数</span></span><br><span class="line">        <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(clientTotal);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clientTotal; i++) &#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                <span class="comment">//核心方法执行前后需获取/释放信号量</span></span><br><span class="line">                <span class="comment">//由于使用信号量可能会因执行中断而产生异常</span></span><br><span class="line">                <span class="comment">//只有当semaphore.acquire()执行完（根据目前的并发数判断该线程是否允许被执行，否则会被阻塞）有返回效果，线程才会执行其核心方法</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    add();</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="comment">//                    e.printStackTrace();</span></span><br><span class="line">                    log.<span class="keyword">error</span>(<span class="string">"中断异常InterruptedException:"</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//执行闭锁，进行请求总数减一</span></span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//调用countDownLatch.await()方法保证目前已经**减为零**。</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            countDownLatch.await();</span><br><span class="line">            <span class="comment">//闭锁执行完毕，关闭线程池</span></span><br><span class="line">            executorService.shutdown();</span><br><span class="line">            log.info(<span class="string">"计数count:&#123;&#125;"</span>,count);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="comment">//            e.printStackTrace();</span></span><br><span class="line">            log.<span class="keyword">error</span>(<span class="string">"计数产生中断异常InterruptedException:"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计数方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="第一次运行结果"><a href="#第一次运行结果" class="headerlink" title="第一次运行结果"></a>第一次运行结果</h5><p><img src="/2018/08/02/第一次并发模拟/第一次并发模拟-第一次结果.png" alt="图"></p><h5 id="第二次运行结果"><a href="#第二次运行结果" class="headerlink" title="第二次运行结果"></a>第二次运行结果</h5><p><img src="/2018/08/02/第一次并发模拟/第二次结果.png" alt="图"></p><h5 id="第三次运行结果"><a href="#第三次运行结果" class="headerlink" title="第三次运行结果"></a>第三次运行结果</h5><p><img src="/2018/08/02/第一次并发模拟/第三次结果.png" alt="图"></p><h5 id="根据三次结果，显然该类是非线程安全的类。所以其前面标注上之前定义的注解。"><a href="#根据三次结果，显然该类是非线程安全的类。所以其前面标注上之前定义的注解。" class="headerlink" title="根据三次结果，显然该类是非线程安全的类。所以其前面标注上之前定义的注解。"></a>根据三次结果，显然该类是非线程安全的类。所以其前面标注上之前定义的注解。</h5>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;关键源码&quot;&gt;&lt;a href=&quot;#关键源码&quot; class=&quot;headerlink&quot; title=&quot;关键源码&quot;&gt;&lt;/a&gt;关键源码&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;这是我的第一次并发模拟的演示例子，是使用SpringBoot搭建演示环境。虽然很简单，但是万丈高楼平地起，基础得打好~之后我会更加详实地补充高级内容！&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Java之并发编程" scheme="http://suprisemf.github.io/categories/Java%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java" scheme="http://suprisemf.github.io/tags/Java/"/>
    
      <category term="并发编程" scheme="http://suprisemf.github.io/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>并发模拟</title>
    <link href="http://suprisemf.github.io/2018/08/02/%E5%B9%B6%E5%8F%91%E6%A8%A1%E6%8B%9F/"/>
    <id>http://suprisemf.github.io/2018/08/02/并发模拟/</id>
    <published>2018-08-02T08:07:40.000Z</published>
    <updated>2018-08-02T09:20:11.555Z</updated>
    
    <content type="html"><![CDATA[<h4 id="并发模拟之工具"><a href="#并发模拟之工具" class="headerlink" title="并发模拟之工具"></a>并发模拟之工具</h4><h6 id="Postman：Http请求模拟工具。"><a href="#Postman：Http请求模拟工具。" class="headerlink" title="Postman：Http请求模拟工具。"></a>Postman：Http请求模拟工具。</h6><p>在接口测试中是一个十分给力的工具；但在并发模拟方面做得不够专业。</p><h6 id="Apache-Bench-AB-：Apache附带的工具，用以测试网站性能。"><a href="#Apache-Bench-AB-：Apache附带的工具，用以测试网站性能。" class="headerlink" title="Apache Bench (AB)：Apache附带的工具，用以测试网站性能。"></a>Apache Bench (AB)：Apache附带的工具，用以测试网站性能。</h6><p>AB小巧简单，上手容易，但是没有图形化界面，也无法做到实时监控。</p><h6 id="JMeter：Apache组织开发的压力测试工具。"><a href="#JMeter：Apache组织开发的压力测试工具。" class="headerlink" title="JMeter：Apache组织开发的压力测试工具。"></a>JMeter：Apache组织开发的压力测试工具。</h6><blockquote><p>下载安装并配置环境变量。</p></blockquote><a id="more"></a><p>配置总请求数量、线程上升期间(s)、循环次数：<br><img src="/2018/08/02/并发模拟/jmeter一.png" alt="实操+图示"><br>指定HTTP请求的基本信息：端口信息、请求方法、路径、编码方式等<br><img src="/2018/08/02/并发模拟/jmeter二.png" alt="实操+图示"><br>JMeter测试中数据统计：<br><img src="/2018/08/02/并发模拟/jmeter三.png" alt="实操+图示"><br>JMeter第一次测试失败，原因是连接异常（自己没启动SpringBoot，笑死我了……）<br><img src="/2018/08/02/并发模拟/jmeter四.png" alt="实操+图示"><br><strong>JMeter测试成功截图：</strong><br>jmeter结果树：<br><img src="/2018/08/02/并发模拟/jmeter结果树.png" alt="实操+图示"><br>jmeter结果树请求头：<br><img src="/2018/08/02/并发模拟/jmeter结果树请求头.png" alt="实操+图示"><br>jmeter结果树响应数据：<br><img src="/2018/08/02/并发模拟/jmeter结果树响应数据.png" alt="实操+图示"></p><hr><h4 id="并发模拟之代码"><a href="#并发模拟之代码" class="headerlink" title="并发模拟之代码"></a>并发模拟之代码</h4><h6 id="CountDownLatch类"><a href="#CountDownLatch类" class="headerlink" title="CountDownLatch类"></a>CountDownLatch类</h6><p>其原理图如下：</p><p><img src="/2018/08/02/并发模拟/CountDownLatch类.png" alt="图示+解释"></p><p>根据上图：其他线程每次执行结束即执行一次countDown()，已经执行结束任务的线程执行await()判断当前计数cnt是否为零，未至0则等待其他线程，只当计数cnt为0时该线程会被resumed去执行后续的操作。</p><p>该类可以通过计数来阻塞线程，主要用于线程执行完之后的其他处理：指定一个计数值，在并发环境下由线程进行减1操作，当计数值变为0之后，被await方法阻塞的线程将会唤醒，实现线程间的同步。<strong>通俗理解：已经执行完成的线程等待还未完成的线程，最后所有线程一同执行另外的任务。</strong></p><h6 id="Semphore类"><a href="#Semphore类" class="headerlink" title="Semphore类"></a>Semphore类</h6><p>Semphore从字面上理解就是信号量，学过《操作系统》课程的人应该知道，在操作系统调度任务时，根据其设定的Semphore值进行同时运行的线程数量的操作。<br>同理，此处的Semphore的含义也是如此。<strong>它主要是用来控制同时并发的线程数。</strong></p><blockquote><p><strong>该两个类通常会结合线程池ThreadPool进行并发的模拟。</strong></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;并发模拟之工具&quot;&gt;&lt;a href=&quot;#并发模拟之工具&quot; class=&quot;headerlink&quot; title=&quot;并发模拟之工具&quot;&gt;&lt;/a&gt;并发模拟之工具&lt;/h4&gt;&lt;h6 id=&quot;Postman：Http请求模拟工具。&quot;&gt;&lt;a href=&quot;#Postman：Http请求模拟工具。&quot; class=&quot;headerlink&quot; title=&quot;Postman：Http请求模拟工具。&quot;&gt;&lt;/a&gt;Postman：Http请求模拟工具。&lt;/h6&gt;&lt;p&gt;在接口测试中是一个十分给力的工具；但在并发模拟方面做得不够专业。&lt;/p&gt;
&lt;h6 id=&quot;Apache-Bench-AB-：Apache附带的工具，用以测试网站性能。&quot;&gt;&lt;a href=&quot;#Apache-Bench-AB-：Apache附带的工具，用以测试网站性能。&quot; class=&quot;headerlink&quot; title=&quot;Apache Bench (AB)：Apache附带的工具，用以测试网站性能。&quot;&gt;&lt;/a&gt;Apache Bench (AB)：Apache附带的工具，用以测试网站性能。&lt;/h6&gt;&lt;p&gt;AB小巧简单，上手容易，但是没有图形化界面，也无法做到实时监控。&lt;/p&gt;
&lt;h6 id=&quot;JMeter：Apache组织开发的压力测试工具。&quot;&gt;&lt;a href=&quot;#JMeter：Apache组织开发的压力测试工具。&quot; class=&quot;headerlink&quot; title=&quot;JMeter：Apache组织开发的压力测试工具。&quot;&gt;&lt;/a&gt;JMeter：Apache组织开发的压力测试工具。&lt;/h6&gt;&lt;blockquote&gt;
&lt;p&gt;下载安装并配置环境变量。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Java之并发编程" scheme="http://suprisemf.github.io/categories/Java%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java" scheme="http://suprisemf.github.io/tags/Java/"/>
    
      <category term="并发编程" scheme="http://suprisemf.github.io/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Spring的自定义注解</title>
    <link href="http://suprisemf.github.io/2018/08/02/spring%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/"/>
    <id>http://suprisemf.github.io/2018/08/02/spring的自定义注解/</id>
    <published>2018-08-02T07:56:47.000Z</published>
    <updated>2018-08-02T09:19:48.930Z</updated>
    
    <content type="html"><![CDATA[<h4 id="自定义的注解"><a href="#自定义的注解" class="headerlink" title="自定义的注解"></a>自定义的注解</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明注解需两个属性。此ThreadSafe只是一个**线程安全**的标识</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span><span class="comment">//给类做注解，其中target的其他值很多</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span><span class="comment">//只在源码中起作用：标识。其他值详述。</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ThreadSafe &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过value（）给其名字，并给出默认名称。</span></span><br><span class="line">    String value() <span class="keyword">default</span> <span class="string">""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="注解的作用范围"><a href="#注解的作用范围" class="headerlink" title="注解的作用范围"></a>注解的作用范围</h4><p><img src="/2018/08/02/spring的自定义注解/注解作用范围.png" alt="截图"></p><h5 id="Target源码"><a href="#Target源码" class="headerlink" title="@Target源码"></a>@Target源码</h5><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * The constants <span class="keyword">of</span> this enumerated <span class="keyword">type</span> <span class="type">provide </span>a simple classification <span class="keyword">of</span> the</span><br><span class="line"> * syntactic locations where annotations may appear <span class="keyword">in</span> a Java program. These</span><br><span class="line"> * constants are used <span class="keyword">in</span> &#123;@link Target java.lang.annotation.Target&#125;</span><br><span class="line"> * meta-annotations to specify where it <span class="keyword">is</span> legal to write annotations <span class="keyword">of</span> a</span><br><span class="line"> * given <span class="keyword">type</span>.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;The syntactic locations where annotations may appear are split into</span><br><span class="line"> * &lt;em&gt;declaration contexts&lt;/em&gt; , where annotations apply to declarations, <span class="keyword">and</span></span><br><span class="line"> * &lt;em&gt;<span class="keyword">type</span> <span class="type">contexts&lt;/em&gt; </span>, where annotations apply to types used <span class="keyword">in</span></span><br><span class="line"> * declarations <span class="keyword">and</span> expressions.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;The constants &#123;@link #ANNOTATION_TYPE&#125; , &#123;@link #CONSTRUCTOR&#125; , &#123;@link</span><br><span class="line"> * #FIELD&#125; , &#123;@link #LOCAL_VARIABLE&#125; , &#123;@link #METHOD&#125; , &#123;@link #<span class="keyword">PACKAGE</span>&#125; ,</span><br><span class="line"> * &#123;@link #PARAMETER&#125; , &#123;@link #<span class="keyword">TYPE</span>&#125; , <span class="keyword">and</span> &#123;@link #TYPE_PARAMETER&#125; correspond</span><br><span class="line"> * to the declaration contexts <span class="keyword">in</span> JLS <span class="number">9.6</span>.<span class="number">4.1</span>.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;<span class="keyword">For</span> example, an annotation whose <span class="keyword">type</span> <span class="type">is </span>meta-annotated <span class="keyword">with</span></span><br><span class="line"> * &#123;@code @Target(ElementType.FIELD)&#125; may only be written as a modifier <span class="keyword">for</span> a</span><br><span class="line"> * field declaration.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;The <span class="keyword">constant</span> &#123;@link #TYPE_USE&#125; corresponds to the <span class="number">15</span> <span class="keyword">type</span> <span class="type">contexts </span><span class="keyword">in</span> JLS</span><br><span class="line"> * <span class="number">4.11</span>, as well as to two declaration contexts: <span class="keyword">type</span> <span class="type">declarations </span>(including</span><br><span class="line"> * annotation <span class="keyword">type</span> <span class="type">declarations) </span><span class="keyword">and</span> <span class="keyword">type</span> <span class="type">parameter </span>declarations.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;<span class="keyword">For</span> example, an annotation whose <span class="keyword">type</span> <span class="type">is </span>meta-annotated <span class="keyword">with</span></span><br><span class="line"> * &#123;@code @Target(ElementType.TYPE_USE)&#125; may be written on the <span class="keyword">type</span> <span class="type">of </span>a field</span><br><span class="line"> * (<span class="keyword">or</span> within the <span class="keyword">type</span> <span class="type">of </span>the field, <span class="keyword">if</span> it <span class="keyword">is</span> a nested, parameterized, <span class="keyword">or</span> <span class="keyword">array</span></span><br><span class="line"> * <span class="keyword">type</span>), <span class="keyword">and</span> may also appear as a modifier <span class="keyword">for</span>, say, a class declaration.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;The &#123;@code TYPE_USE&#125; <span class="keyword">constant</span> includes <span class="keyword">type</span> <span class="type">declarations </span><span class="keyword">and</span> <span class="keyword">type</span></span><br><span class="line"> * parameter declarations as a convenience <span class="keyword">for</span> designers <span class="keyword">of</span> <span class="keyword">type</span> <span class="type">checkers </span>which</span><br><span class="line"> * give semantics to annotation types. <span class="keyword">For</span> example, <span class="keyword">if</span> the annotation <span class="keyword">type</span></span><br><span class="line"> * &#123;@code NonNull&#125; <span class="keyword">is</span> meta-annotated <span class="keyword">with</span></span><br><span class="line"> * &#123;@code @Target(ElementType.TYPE_USE)&#125;, <span class="keyword">then</span> &#123;@code @NonNull&#125;</span><br><span class="line"> * &#123;@code class C &#123;...&#125;&#125; could be treated by a <span class="keyword">type</span> <span class="type">checker </span>as indicating that</span><br><span class="line"> * <span class="keyword">all</span> variables <span class="keyword">of</span> class &#123;@code C&#125; are non-null, <span class="keyword">while</span> still allowing</span><br><span class="line"> * variables <span class="keyword">of</span> other classes to be non-null <span class="keyword">or</span> <span class="keyword">not</span> non-null based on whether</span><br><span class="line"> * &#123;@code @NonNull&#125; appears <span class="keyword">at</span> the variable<span class="symbol">'s</span> declaration.</span><br><span class="line"> *</span><br><span class="line"> * @author  Joshua Bloch</span><br><span class="line"> * @since <span class="number">1.5</span></span><br><span class="line"> * @jls <span class="number">9.6</span>.<span class="number">4.1</span> @Target</span><br><span class="line"> * @jls <span class="number">4.1</span> The Kinds <span class="keyword">of</span> Types <span class="keyword">and</span> Values</span><br><span class="line"> */</span><br><span class="line">public enum ElementType &#123;</span><br><span class="line">    /** Class, <span class="keyword">interface</span> (including annotation <span class="keyword">type</span>), <span class="keyword">or</span> enum declaration */</span><br><span class="line">    <span class="keyword">TYPE</span>,</span><br><span class="line"></span><br><span class="line">    /** Field declaration (includes enum constants) */</span><br><span class="line">    FIELD,</span><br><span class="line"></span><br><span class="line">    /** Method declaration */</span><br><span class="line">    METHOD,</span><br><span class="line"></span><br><span class="line">    /** Formal parameter declaration */</span><br><span class="line">    PARAMETER,</span><br><span class="line"></span><br><span class="line">    /** Constructor declaration */</span><br><span class="line">    CONSTRUCTOR,</span><br><span class="line"></span><br><span class="line">    /** Local variable declaration */</span><br><span class="line">    LOCAL_VARIABLE,</span><br><span class="line"></span><br><span class="line">    /** Annotation <span class="keyword">type</span> <span class="type">declaration </span>*/</span><br><span class="line">    ANNOTATION_TYPE,</span><br><span class="line"></span><br><span class="line">    /** <span class="keyword">Package</span> <span class="title">declaration */</span></span><br><span class="line">    <span class="keyword">PACKAGE</span>,</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * <span class="keyword">Type</span> <span class="type">parameter </span>declaration</span><br><span class="line">     *</span><br><span class="line">     * @since <span class="number">1.8</span></span><br><span class="line">     */</span><br><span class="line">    TYPE_PARAMETER,</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * <span class="keyword">Use</span> <span class="keyword">of</span> a <span class="keyword">type</span></span><br><span class="line">     *</span><br><span class="line">     * @since <span class="number">1.8</span></span><br><span class="line">     */</span><br><span class="line">    TYPE_USE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="解读源码："><a href="#解读源码：" class="headerlink" title="解读源码："></a><strong>解读源码：</strong></h6><h5 id="Retention源码"><a href="#Retention源码" class="headerlink" title="@Retention源码"></a>@Retention源码</h5><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Annotation retention policy.  The constants <span class="keyword">of</span> this enumerated type</span><br><span class="line"> * describe <span class="keyword">the</span> various policies <span class="keyword">for</span> retaining annotations.  They are used</span><br><span class="line"> * <span class="keyword">in</span> conjunction <span class="keyword">with</span> <span class="keyword">the</span> &#123;@link Retention&#125; meta-annotation type <span class="keyword">to</span> specify</span><br><span class="line"> * how long annotations are <span class="keyword">to</span> be retained.</span><br><span class="line"> *</span><br><span class="line"> * @author  Joshua Bloch</span><br><span class="line"> * @<span class="keyword">since</span> <span class="number">1.5</span></span><br><span class="line"> */</span><br><span class="line">public enum RetentionPolicy &#123;</span><br><span class="line">    /**</span><br><span class="line">     * Annotations are <span class="keyword">to</span> be discarded <span class="keyword">by</span> <span class="keyword">the</span> compiler.</span><br><span class="line">     */</span><br><span class="line">    SOURCE,</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Annotations are <span class="keyword">to</span> be recorded <span class="keyword">in</span> <span class="keyword">the</span> <span class="built_in">class</span> <span class="built_in">file</span> <span class="keyword">by</span> <span class="keyword">the</span> compiler</span><br><span class="line">     * <span class="keyword">but</span> need <span class="keyword">not</span> be retained <span class="keyword">by</span> <span class="keyword">the</span> VM <span class="keyword">at</span> <span class="built_in">run</span> <span class="built_in">time</span>.  This <span class="keyword">is</span> <span class="keyword">the</span> default</span><br><span class="line">     * behavior.</span><br><span class="line">     */</span><br><span class="line">    CLASS,</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Annotations are <span class="keyword">to</span> be recorded <span class="keyword">in</span> <span class="keyword">the</span> <span class="built_in">class</span> <span class="built_in">file</span> <span class="keyword">by</span> <span class="keyword">the</span> compiler <span class="keyword">and</span></span><br><span class="line">     * retained <span class="keyword">by</span> <span class="keyword">the</span> VM <span class="keyword">at</span> <span class="built_in">run</span> <span class="built_in">time</span>, so they may be <span class="built_in">read</span> reflectively.</span><br><span class="line">     *</span><br><span class="line">     * @see java.lang.reflect.AnnotatedElement</span><br><span class="line">     */</span><br><span class="line">    RUNTIME</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="解读源码：-1"><a href="#解读源码：-1" class="headerlink" title="解读源码："></a><strong>解读源码：</strong></h6><p>此处为坑，后续会补上！！！</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;自定义的注解&quot;&gt;&lt;a href=&quot;#自定义的注解&quot; class=&quot;headerlink&quot; title=&quot;自定义的注解&quot;&gt;&lt;/a&gt;自定义的注解&lt;/h4&gt;&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//声明注解需两个属性。此ThreadSafe只是一个**线程安全**的标识&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@Target(ElementType.TYPE)&lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;//给类做注解，其中target的其他值很多&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@Retention(RetentionPolicy.SOURCE)&lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;//只在源码中起作用：标识。其他值详述。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;meta&quot;&gt;@interface&lt;/span&gt; ThreadSafe &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//通过value（）给其名字，并给出默认名称。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    String value() &lt;span class=&quot;keyword&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Java之并发编程" scheme="http://suprisemf.github.io/categories/Java%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java" scheme="http://suprisemf.github.io/tags/Java/"/>
    
      <category term="并发编程" scheme="http://suprisemf.github.io/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>线程安全之原子性--Atomic包-Part-1</title>
    <link href="http://suprisemf.github.io/2018/08/02/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B9%8B%E5%8E%9F%E5%AD%90%E6%80%A7-Atomic%E5%8C%85-part-1/"/>
    <id>http://suprisemf.github.io/2018/08/02/线程安全之原子性-Atomic包-part-1/</id>
    <published>2018-08-02T07:47:11.000Z</published>
    <updated>2018-08-02T09:19:28.776Z</updated>
    
    <content type="html"><![CDATA[<h4 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h4><h6 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h6><ul><li>原子性：提供了互斥访问，同一时刻只能有一个线程来对它进行操作；</li><li>可见性：一个线程对主内存的修改可以及时地被其他线程知道；</li><li>有序性：一个线程观察其他线程中的指令执行顺序，由于指令重排序的存在，该观察结果一般杂乱无序。<a id="more"></a><h4 id="使用AtomicInteger类"><a href="#使用AtomicInteger类" class="headerlink" title="使用AtomicInteger类"></a>使用AtomicInteger类</h4>之前当使用int时，根据结果知道，该操作是非线程安全的。<br>当使用AtomicInteger类时，并使用<code>count.incrementAndGet();</code>而不是<code>count++;</code>后，多次验证其结果为：</li></ul><p><img src="/2018/08/02/线程安全之原子性-Atomic包-part-1/使用AtomicInteger代替int测试.png" alt="图"></p><h5 id="为什么使用了count的incrementAndGet-方法后就变成线程安全的了呢？"><a href="#为什么使用了count的incrementAndGet-方法后就变成线程安全的了呢？" class="headerlink" title="为什么使用了count的incrementAndGet()方法后就变成线程安全的了呢？"></a>为什么使用了count的incrementAndGet()方法后就变成线程安全的了呢？</h5><p><strong>查看源码！</strong><br><code>count.incrementAndGet():</code><br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Atomically increments by one the current value.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the updated value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="function"><span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>其中使用到unsafe的getAndAddInt(xxx)方法！！</strong></p><p><em>那么这个方法是何方神圣？</em><br><strong>看看它的实现：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var5;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看出它使用do-while语句实现，其实不止getAndAddInt用到，其他的get(或set)AndAddxxx(Object)都是一样的实现方式。其中其判断的条件又用到unsafe类的compareAndSwapInt(xxx)方法，再点进去看看！！<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="function"><span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4, <span class="keyword">int</span> var5)</span></span>;</span><br></pre></td></tr></table></figure></p><p>就这一句没了……</p><h5 id="但是！！！"><a href="#但是！！！" class="headerlink" title="但是！！！"></a><strong>但是！！！</strong></h5><p>我看到方法类型中有一个字段<code>native</code>！！！<br>这说明该方法是JNI框架(Java Native Interface,Java本地接口)的方法。</p><p>再Google一下：</p><blockquote><p>在编程领域, JNI (Java Native Interface,Java本地接口)是一种编程框架,使得Java虚拟机中的Java程序可以调用本地应用/或库,也可以被其他程序调用。<strong>本地程序一般是用其它语言（C、C++或汇编语言等）编写的, 并且被编译为基于本机硬件和操作系统的程序。</strong><br>JNI框架允许Native方法调用Java对象，就像Java程序访问Native对象一样方便。Native方法可以创建Java对象，读取这些对象, 并调用Java对象执行某些方法。当然Native方法也可以读取由Java程序自身创建的对象,并调用这些对象的方法。</p></blockquote><blockquote><p>JNI在某些情况下可能带来很大的开销和性能损失:</p><ul><li>调用 JNI 方法是很笨重的操作, 特别是在多次重复调用的情况下.</li><li>Native 方法不会被 JVM 内联, 也不会被 JIT compiled 优化 , 因为方法已经被编译过了.</li><li>Java 数组可能会被拷贝一份,以传递给 native 方法, 执行完之后再拷贝回去. 其开销与数组的长度是线性相关的.</li><li>如果传递一个对象给方法,或者需要一个回调,那么 Native 方法可能会自己调用JVM。 访问Java对象的属性、方法和类型时, Native代码需要类似reflection的东西。签名由字符串指定,通从JVM中查询。这非常缓慢并且容易出错。</li><li>Java 中的字符串(String) 也是对象, 有 length 属性,并且是编码过的. 读取或者创建字符串都需要一次时间复杂度为 O(n) 的复制操作.</li></ul></blockquote><h5 id="再分析其函数的调用："><a href="#再分析其函数的调用：" class="headerlink" title="再分析其函数的调用："></a>再分析其函数的调用：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var5;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中var1为当前传入的对象即count，var2是当前count的值，var4即为incrementAndGet()方法的默认加数，为1，var5是调用的另一个JNI的方法得到底层当前的count值。<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="function"><span class="keyword">int</span> <span class="title">getIntVolatile</span><span class="params">(Object var1, <span class="keyword">long</span> var2)</span></span>;</span><br></pre></td></tr></table></figure></p><p><strong>Volatile关键字很熟悉，简述是保证了线程之间操作的对象的值互相透明、可见性。</strong><br>（Volatile关键字的详述又该是一个大文章了！过阵子再写！）<br>那么现在应该就懂了，<strong>用底层得到的值不断循环比较当前的值，如果两者相等就加一并再用JNI底层方法写入主内存。</strong><br>AtomicInteger类就是使用了该方法即<strong>CAS原理</strong>来保证线程安全的。（CAS原理也是一个大块头。。）<br>同理，AtomicXXX类（XXX是属于Java的Object，例如Long、Double等）都是该方法保证的！</p><h4 id="ConpareAndSet概述"><a href="#ConpareAndSet概述" class="headerlink" title="ConpareAndSet概述"></a>ConpareAndSet概述</h4><p>该方法和ConpareAndSwap有些相似，但还有不同：ConpareAndSet(a,b)更多的是用在AtomicBoolean类中（Boolean要求false与true的转换同一时间只能被一个线程调用，且false(true)只能转换为true(false)，其中的参数a,b即为只能相互转换的数，<strong>顺序为：当为a的时候更新为b</strong>）。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;概览&quot;&gt;&lt;a href=&quot;#概览&quot; class=&quot;headerlink&quot; title=&quot;概览&quot;&gt;&lt;/a&gt;概览&lt;/h4&gt;&lt;h6 id=&quot;线程安全&quot;&gt;&lt;a href=&quot;#线程安全&quot; class=&quot;headerlink&quot; title=&quot;线程安全&quot;&gt;&lt;/a&gt;线程安全&lt;/h6&gt;&lt;ul&gt;
&lt;li&gt;原子性：提供了互斥访问，同一时刻只能有一个线程来对它进行操作；&lt;/li&gt;
&lt;li&gt;可见性：一个线程对主内存的修改可以及时地被其他线程知道；&lt;/li&gt;
&lt;li&gt;有序性：一个线程观察其他线程中的指令执行顺序，由于指令重排序的存在，该观察结果一般杂乱无序。&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="Java之并发编程" scheme="http://suprisemf.github.io/categories/Java%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java" scheme="http://suprisemf.github.io/tags/Java/"/>
    
      <category term="并发编程" scheme="http://suprisemf.github.io/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>并发的优势与风险</title>
    <link href="http://suprisemf.github.io/2018/08/02/%E5%B9%B6%E5%8F%91%E7%9A%84%E4%BC%98%E5%8A%BF%E4%B8%8E%E9%A3%8E%E9%99%A9/"/>
    <id>http://suprisemf.github.io/2018/08/02/并发的优势与风险/</id>
    <published>2018-08-02T07:43:02.000Z</published>
    <updated>2018-08-02T09:18:59.322Z</updated>
    
    <content type="html"><![CDATA[<h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><h4 id="速度"><a href="#速度" class="headerlink" title="速度"></a>速度</h4><ul><li>系统可以处理多个请求，响应速度更快；</li><li>复杂的操作可以分割为多个进程同时进行。<a id="more"></a><h4 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h4></li><li>程序的设计更加简单；</li><li>设计有更多的选择。<h4 id="资源利用"><a href="#资源利用" class="headerlink" title="资源利用"></a>资源利用</h4>CPU在等待IO时候可以做其他的工作，提高硬件资源利用率<h3 id="风险"><a href="#风险" class="headerlink" title="风险"></a>风险</h3><h4 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h4>多个线程共享数据可能会产生与期望不相符的结果<h4 id="活跃性"><a href="#活跃性" class="headerlink" title="活跃性"></a>活跃性</h4>某个操作无法继续进行下去时，会产生活跃性问题。如死锁饥饿等。<h4 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h4>线程过多时会使：</li></ul><ol><li>CPU上下文切换频繁，调度时间增加，想能降低；</li><li>同步机制耗时增加；</li><li>内存容量剧增。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;优势&quot;&gt;&lt;a href=&quot;#优势&quot; class=&quot;headerlink&quot; title=&quot;优势&quot;&gt;&lt;/a&gt;优势&lt;/h3&gt;&lt;h4 id=&quot;速度&quot;&gt;&lt;a href=&quot;#速度&quot; class=&quot;headerlink&quot; title=&quot;速度&quot;&gt;&lt;/a&gt;速度&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;系统可以处理多个请求，响应速度更快；&lt;/li&gt;
&lt;li&gt;复杂的操作可以分割为多个进程同时进行。&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="Java之并发编程" scheme="http://suprisemf.github.io/categories/Java%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java" scheme="http://suprisemf.github.io/tags/Java/"/>
    
      <category term="并发编程" scheme="http://suprisemf.github.io/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java内存模型</title>
    <link href="http://suprisemf.github.io/2018/08/02/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    <id>http://suprisemf.github.io/2018/08/02/Java内存模型/</id>
    <published>2018-08-02T07:29:16.000Z</published>
    <updated>2018-08-02T09:18:34.726Z</updated>
    
    <content type="html"><![CDATA[<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><blockquote><p>已知多核CPU对于代码指令的乱序执行存在跟我们预期结果不一致的问题，解决方法就是使用Java内存模型规范对多线程操作进行约束。<br>其中<strong>Java内存模型是为屏蔽掉不同操作系统，不同硬件设备的差异，使Java程序对于多线程的环境有相同的执行结果，而对Java虚拟机（JVM）与硬件设备交互协调的规范</strong></p></blockquote><a id="more"></a><h5 id="JMM规定一个线程在何时、如何对内存中其他线程修改后的共享变量的可见性，及如何在必须时同步访问共享变量。"><a href="#JMM规定一个线程在何时、如何对内存中其他线程修改后的共享变量的可见性，及如何在必须时同步访问共享变量。" class="headerlink" title="JMM规定一个线程在何时、如何对内存中其他线程修改后的共享变量的可见性，及如何在必须时同步访问共享变量。"></a>JMM规定一个线程在何时、如何对内存中其他线程修改后的共享变量的可见性，及如何在必须时同步访问共享变量。</h5><h4 id="Java内存模型（JMM）"><a href="#Java内存模型（JMM）" class="headerlink" title="Java内存模型（JMM）"></a>Java内存模型（JMM）</h4><p>JMM与硬件结构如下图：</p><p><img src="/2018/08/02/Java内存模型/JMM与硬件结构.png" alt=""></p><p>JMM内部抽象结构如下图：</p><p><img src="/2018/08/02/Java内存模型/JMM抽象结构.png" alt="此处JMM"></p><p>堆区（Heap）：是运行时数据区，并由GC（Garbage Collection）负责，可以在运行时动态分配内存大小，也不必通知编译器。<strong>缺点：由于运行时动态分配内存，故存取速度稍慢</strong></p><blockquote><p>静态成员变量跟随类的定义一起存放在堆中。堆中的对象可以被对该对象持有引用的线程访问，且其成员变量也可以被访问；<strong>当多个线程对同一对象的同一方法进行访问时，其实每个线程都有对该对象的数据的<em>私有拷贝</em>，而不会出现混乱</strong>。</p></blockquote><hr><p>栈区（Stack）：主要存放8种基本类型的变量和句柄，JMM要求调用栈的本地变量存放在本地线程栈中，但对象是存放在堆中；优点：存取速度快（相对于Heap），仅次于寄存器，其中的数据可以共享；缺点：其中的数据与其生存期是确定的，缺乏灵活性。</p><blockquote><p>本地变量（local variable）也可能是一个引用变量，指向一个变量的引用，此时引用变量是存放在线程栈（Thread Stack）中，但被引用变量仍然存放在堆Heap中。</p></blockquote><hr><h3 id="同步的八种操纵"><a href="#同步的八种操纵" class="headerlink" title="同步的八种操纵"></a>同步的八种操纵</h3><ul><li>lock（锁定）：作用于主内存的变量，把一个标示为一条线程独占状态；</li><li>unloc（解锁）：作用于主内存的变量，把一个处于锁定状态的变量释放；</li><li>read（读取）：作用于主内存的变量，把一个变量从主内存传输到编程的工作内存，供随后的load操作使用；</li><li>load（载入）：作用于主内存的变量，它把read操作从主内存得到的变量值放入工作内存的变量副本中；</li><li>use（使用）：作用于主内存的变量，把工作内存的一个变量值传递给执行引擎；</li><li>assign（赋值）：作用于主内存的变量，它把一个从执行引擎收到的值赋值给工作内存的变量；</li><li>store（存储）：作用于主内存的变量，将工作内存的一个变量的值传递给主内存中，供随后的write操作使用；</li><li>write（写入）：作用于主内存的变量，将store操作从内存中的一个变量值传送到主内存的变量中。</li></ul><h3 id="同步的规则"><a href="#同步的规则" class="headerlink" title="同步的规则"></a>同步的规则</h3><p>同步操作与规则如下图：</p><p><img src="/2018/08/02/Java内存模型/同步操作与规则.png" alt=""></p><ul><li>如果把一个变量从主内存中复制到工作内存，需要按顺序执行read和load操作；如果把变量从工作内存同步回主内存中，需要按顺序执行store和write操作。<strong>需要按照先后顺序，但不要求连续执行！</strong></li><li>不允许read和load、store和write操作之一单独出现。</li><li>不允许一个线程丢弃它的最近assign的操作，即变量在工作内存中改变了之后必须同步到主内存中。</li><li>不允许一个线程无原因地（没有发生过任何assign操作）把数据从工作内存同步到主内存中。</li><li>一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量。即对一个变量执行use或store操作之前，必须先执行assign或load操作。</li><li>一个变量在同一时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次；多次执行lock后，只有执行相同次数的unlock后，变量才会被解锁。即lock和unlock必须成对出现。</li><li>如果对一个变量执行lock操作，将会清空工作内存中此变量的值；在执行引擎使用这个变量前需要重新执行load或assign操作初始化变量的值。</li><li>如果一个变量事先没有被lock操作锁定，则不允许对它执行unlock操作；也不允许去unlock一个被其他线程锁定的变量。</li><li>对一个变量执行unlock操作之前，必须先把此变量同步到主内存中（执行store和write操作）。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;已知多核CPU对于代码指令的乱序执行存在跟我们预期结果不一致的问题，解决方法就是使用Java内存模型规范对多线程操作进行约束。&lt;br&gt;其中&lt;strong&gt;Java内存模型是为屏蔽掉不同操作系统，不同硬件设备的差异，使Java程序对于多线程的环境有相同的执行结果，而对Java虚拟机（JVM）与硬件设备交互协调的规范&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Java之并发编程" scheme="http://suprisemf.github.io/categories/Java%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java" scheme="http://suprisemf.github.io/tags/Java/"/>
    
      <category term="并发编程" scheme="http://suprisemf.github.io/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>CPU多级缓存——乱序执行优化</title>
    <link href="http://suprisemf.github.io/2018/08/02/%E4%B9%B1%E5%BA%8F%E6%89%A7%E8%A1%8C%E4%BC%98%E5%8C%96/"/>
    <id>http://suprisemf.github.io/2018/08/02/乱序执行优化/</id>
    <published>2018-08-02T07:25:46.000Z</published>
    <updated>2018-08-02T09:17:47.599Z</updated>
    
    <content type="html"><![CDATA[<h3 id="处理器为提高运算速度而做出违反源代码执行顺序的优化"><a href="#处理器为提高运算速度而做出违反源代码执行顺序的优化" class="headerlink" title="处理器为提高运算速度而做出违反源代码执行顺序的优化"></a>处理器为提高运算速度而做出违反源代码执行顺序的优化</h3><p>此方法在编译器的中间代码或四元式优化阶段及生成目标代码优化有过大量的使用，是主要的优化手段！<br><a id="more"></a></p><blockquote><p>关于乱序执行及代码优化中的原则，笔者会在编译器笔记中再次详细说明！</p></blockquote><p><strong>在单核CPU中是保证不会出现跟我们预期结果不一致的问题，但在多核CPU中，由于每个核心都有自己的缓存，而缓存又分多级缓存，导致即使的后层的代码也可能先执行，更不用说代码优化后的乱序执行了</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;处理器为提高运算速度而做出违反源代码执行顺序的优化&quot;&gt;&lt;a href=&quot;#处理器为提高运算速度而做出违反源代码执行顺序的优化&quot; class=&quot;headerlink&quot; title=&quot;处理器为提高运算速度而做出违反源代码执行顺序的优化&quot;&gt;&lt;/a&gt;处理器为提高运算速度而做出违反源代码执行顺序的优化&lt;/h3&gt;&lt;p&gt;此方法在编译器的中间代码或四元式优化阶段及生成目标代码优化有过大量的使用，是主要的优化手段！&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java之并发编程" scheme="http://suprisemf.github.io/categories/Java%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java" scheme="http://suprisemf.github.io/tags/Java/"/>
    
      <category term="并发编程" scheme="http://suprisemf.github.io/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>CPU多级缓存——缓存一致性</title>
    <link href="http://suprisemf.github.io/2018/08/02/cpu%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98/"/>
    <id>http://suprisemf.github.io/2018/08/02/cpu多级缓存/</id>
    <published>2018-08-02T07:12:45.000Z</published>
    <updated>2018-08-02T09:20:34.683Z</updated>
    
    <content type="html"><![CDATA[<h4 id="CPU多级缓存演进"><a href="#CPU多级缓存演进" class="headerlink" title="CPU多级缓存演进"></a>CPU多级缓存演进</h4><a id="more"></a><p><img src="/2018/08/02/cpu多级缓存/CPU多级缓存.png" alt="CPU多级缓存"></p><h4 id="CPU中cache的意义"><a href="#CPU中cache的意义" class="headerlink" title="CPU中cache的意义"></a>CPU中cache的意义</h4><p>由于CPU的频率太快了，快到主存跟不上，这样在处理器时钟周期内，CPU常常需要等待主存，浪费资源。所以cache的出现，是为了缓解CPU和内存之间速度的不匹配问题(结构：cpu-&gt;cache-&gt;memory)</p><h5 id="CPU-cache的局部性："><a href="#CPU-cache的局部性：" class="headerlink" title="CPU cache的局部性："></a>CPU cache的局部性：</h5><ol><li>时间局部性：如果某个数据被访问，那么在不久的将来它很可能再次被访问；</li><li>空间局部性：如果某个数据被访问，那么与它相邻的数据很快也能被访问。<h3 id="缓存一致性-MESI"><a href="#缓存一致性-MESI" class="headerlink" title="缓存一致性(MESI)"></a>缓存一致性(MESI)</h3>保证多个CPU的cache之间缓存共享数据的一致性，其中MESI即其中的四种状态：Modified（被修改的）、Exclusive（独享的）、Shared（共享的）、Invalid（无效的）；<br>如下图所示：图中M、E、S、I分别指的是Modified、Exclusive、Shared、Invalid。</li></ol><p><img src="/2018/08/02/cpu多级缓存/MESI.png" alt="图示"></p><blockquote><ul><li>Modified（被修改的）:该值现存于缓存cache中，且由于被修改而与内存中的对应值不一致，且在未来会被写入内存；</li><li>Exclusive（独享的）：该缓存行中的数据与内存中的对应值是一致的，当系统调用到该数据时及转化为Shared（共享的）状态；</li><li>Shared（共享的）：该缓存行可能会被多个CPU调用，且与多个cache中数据一致，当被一个CPU修改时，其他缓存中的该数据转化为Invalid（无效的）即被作废；</li><li>Invalid（无效的）：可能是其他CPU修改了该缓存行；</li><li><strong>其中四个状态转换之间的操作为：local read、local write、remote read、remote write。其中local指的是本地缓存，remote指的是主内存</strong></li></ul></blockquote><h4 id="在典型的多核系统中，每个核都有属于自己的缓存来共享内存总线bus，每个相应的CPU会发出自己的读写请求；而缓存的目的是为了减少各CPU读写共享内存的次数。上图中：除了Invalid（无效的）状态不可本地读，其他均可满足CPU的读请求；一个写请求只有在该缓存行处于Modified（被修改的）、Exclusive（独享的）状态时才可以被执行（local-write或remote-write）；若当前状态为Shared（共享的），且被remote-write修改，则CPU须将其转化为Invalid（无效的），通过广播方式完成，此时及不允许CPU修改同一缓存行（即使修改该缓存行的不同位置的数据也是不允许）；处于Modified（被修改的）的缓存行须时刻监听试图读该缓存行（相对于内存）的操作，该操作必须将该缓存行写入内存，并将在其状态变为Shared（共享的）之前被延迟执行；一个处于Shared（共享的）状态的缓存行需要监听其他缓存使该缓存行无效或独享该缓存行的请求，若有则将转化为Invalid（无效的）状态；处于Exclusive（独享的）状态的缓存行须监听其他缓存的读缓存操作，一旦有关于该缓存行的操作，它须转化为Shared（共享的）状态；因此对于Modified（被修改的）、Exclusive（独享的）状态，其数据总是精确的，他们和缓存行的真正状态是一致的，而Shared（共享的）状态可能是非一致的；如果一个缓存将处于Shared（共享的）状态的缓存行作废，另外的缓存可能以及读取了该缓存行，但是该缓存却不会讲其升级为Exclusive（独享的）状态，是因为：其他缓存不会广播该缓存行作废的通知，同样，由于缓存并不保存该缓存行的copy的数量，因此也无法确定自己是否已经对该缓存行处于Exclusive（独享的）状态。"><a href="#在典型的多核系统中，每个核都有属于自己的缓存来共享内存总线bus，每个相应的CPU会发出自己的读写请求；而缓存的目的是为了减少各CPU读写共享内存的次数。上图中：除了Invalid（无效的）状态不可本地读，其他均可满足CPU的读请求；一个写请求只有在该缓存行处于Modified（被修改的）、Exclusive（独享的）状态时才可以被执行（local-write或remote-write）；若当前状态为Shared（共享的），且被remote-write修改，则CPU须将其转化为Invalid（无效的），通过广播方式完成，此时及不允许CPU修改同一缓存行（即使修改该缓存行的不同位置的数据也是不允许）；处于Modified（被修改的）的缓存行须时刻监听试图读该缓存行（相对于内存）的操作，该操作必须将该缓存行写入内存，并将在其状态变为Shared（共享的）之前被延迟执行；一个处于Shared（共享的）状态的缓存行需要监听其他缓存使该缓存行无效或独享该缓存行的请求，若有则将转化为Invalid（无效的）状态；处于Exclusive（独享的）状态的缓存行须监听其他缓存的读缓存操作，一旦有关于该缓存行的操作，它须转化为Shared（共享的）状态；因此对于Modified（被修改的）、Exclusive（独享的）状态，其数据总是精确的，他们和缓存行的真正状态是一致的，而Shared（共享的）状态可能是非一致的；如果一个缓存将处于Shared（共享的）状态的缓存行作废，另外的缓存可能以及读取了该缓存行，但是该缓存却不会讲其升级为Exclusive（独享的）状态，是因为：其他缓存不会广播该缓存行作废的通知，同样，由于缓存并不保存该缓存行的copy的数量，因此也无法确定自己是否已经对该缓存行处于Exclusive（独享的）状态。" class="headerlink" title="在典型的多核系统中，每个核都有属于自己的缓存来共享内存总线bus，每个相应的CPU会发出自己的读写请求；而缓存的目的是为了减少各CPU读写共享内存的次数。上图中：除了Invalid（无效的）状态不可本地读，其他均可满足CPU的读请求；一个写请求只有在该缓存行处于Modified（被修改的）、Exclusive（独享的）状态时才可以被执行（local write或remote write）；若当前状态为Shared（共享的），且被remote write修改，则CPU须将其转化为Invalid（无效的），通过广播方式完成，此时及不允许CPU修改同一缓存行（即使修改该缓存行的不同位置的数据也是不允许）；处于Modified（被修改的）的缓存行须时刻监听试图读该缓存行（相对于内存）的操作，该操作必须将该缓存行写入内存，并将在其状态变为Shared（共享的）之前被延迟执行；一个处于Shared（共享的）状态的缓存行需要监听其他缓存使该缓存行无效或独享该缓存行的请求，若有则将转化为Invalid（无效的）状态；处于Exclusive（独享的）状态的缓存行须监听其他缓存的读缓存操作，一旦有关于该缓存行的操作，它须转化为Shared（共享的）状态；因此对于Modified（被修改的）、Exclusive（独享的）状态，其数据总是精确的，他们和缓存行的真正状态是一致的，而Shared（共享的）状态可能是非一致的；如果一个缓存将处于Shared（共享的）状态的缓存行作废，另外的缓存可能以及读取了该缓存行，但是该缓存却不会讲其升级为Exclusive（独享的）状态，是因为：其他缓存不会广播该缓存行作废的通知，同样，由于缓存并不保存该缓存行的copy的数量，因此也无法确定自己是否已经对该缓存行处于Exclusive（独享的）状态。"></a><strong>在典型的多核系统中，每个核都有属于自己的缓存来共享内存总线bus，每个相应的CPU会发出自己的读写请求；而缓存的目的是为了减少各CPU读写共享内存的次数。上图中：除了Invalid（无效的）状态不可本地读，其他均可满足CPU的读请求；一个写请求只有在该缓存行处于Modified（被修改的）、Exclusive（独享的）状态时才可以被执行（local write或remote write）；若当前状态为Shared（共享的），且被remote write修改，则CPU须将其转化为Invalid（无效的），通过广播方式完成，此时及不允许CPU修改同一缓存行（即使修改该缓存行的不同位置的数据也是不允许）；处于Modified（被修改的）的缓存行须时刻监听试图读该缓存行（相对于内存）的操作，该操作必须将该缓存行写入内存，并将在其状态变为Shared（共享的）之前被延迟执行；一个处于Shared（共享的）状态的缓存行需要监听其他缓存使该缓存行无效或独享该缓存行的请求，若有则将转化为Invalid（无效的）状态；处于Exclusive（独享的）状态的缓存行须监听其他缓存的读缓存操作，一旦有关于该缓存行的操作，它须转化为Shared（共享的）状态；因此对于Modified（被修改的）、Exclusive（独享的）状态，其数据总是精确的，他们和缓存行的真正状态是一致的，而Shared（共享的）状态可能是非一致的；如果一个缓存将处于Shared（共享的）状态的缓存行作废，另外的缓存可能以及读取了该缓存行，但是该缓存却不会讲其升级为Exclusive（独享的）状态，是因为：其他缓存不会广播该缓存行作废的通知，同样，由于缓存并不保存该缓存行的copy的数量，因此也无法确定自己是否已经对该缓存行处于Exclusive（独享的）状态。</strong></h4><blockquote><p>由上来看：Exclusive（独享的）状态更像是一中投机性优化，因为若一个CPU想修改处于Shared（共享的）状态的缓存行，须调用总线bus事务将所有该缓存行的copy值转化为Invalid（无效的）状态；而修改处于Exclusive（独享的）状态的缓存行则不需使用总线事务</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;CPU多级缓存演进&quot;&gt;&lt;a href=&quot;#CPU多级缓存演进&quot; class=&quot;headerlink&quot; title=&quot;CPU多级缓存演进&quot;&gt;&lt;/a&gt;CPU多级缓存演进&lt;/h4&gt;
    
    </summary>
    
      <category term="Java之并发编程" scheme="http://suprisemf.github.io/categories/Java%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java" scheme="http://suprisemf.github.io/tags/Java/"/>
    
      <category term="并发编程" scheme="http://suprisemf.github.io/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>并发编程与高并发解决方案概论</title>
    <link href="http://suprisemf.github.io/2018/08/02/%E6%A6%82%E8%AE%BA%E5%A4%A7%E7%AC%94%E8%AE%B0/"/>
    <id>http://suprisemf.github.io/2018/08/02/概论大笔记/</id>
    <published>2018-08-02T06:58:51.000Z</published>
    <updated>2018-08-02T09:13:35.401Z</updated>
    
    <content type="html"><![CDATA[<h3 id="覆盖知识点"><a href="#覆盖知识点" class="headerlink" title="覆盖知识点"></a>覆盖知识点</h3><h4 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h4><h4 id="线程封闭"><a href="#线程封闭" class="headerlink" title="线程封闭"></a>线程封闭</h4><a id="more"></a><h4 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h4><h4 id="同步容器"><a href="#同步容器" class="headerlink" title="同步容器"></a>同步容器</h4><h4 id="并发容器"><a href="#并发容器" class="headerlink" title="并发容器"></a>并发容器</h4><h4 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h4><h4 id="J-U-C"><a href="#J-U-C" class="headerlink" title="J.U.C"></a>J.U.C</h4><h4 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h4><h3 id="高并发解决思路与方法"><a href="#高并发解决思路与方法" class="headerlink" title="高并发解决思路与方法"></a>高并发解决思路与方法</h3><h4 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h4><h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><h4 id="拆分"><a href="#拆分" class="headerlink" title="拆分"></a>拆分</h4><h4 id="服务降级与熔断"><a href="#服务降级与熔断" class="headerlink" title="服务降级与熔断"></a>服务降级与熔断</h4><h4 id="数据库切库"><a href="#数据库切库" class="headerlink" title="数据库切库"></a>数据库切库</h4><h4 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h4><h4 id="杂项-1"><a href="#杂项-1" class="headerlink" title="杂项"></a>杂项</h4><h3 id="总体架构"><a href="#总体架构" class="headerlink" title="总体架构"></a>总体架构</h3><ul><li>Spring Boot</li><li>Maven</li><li>JDK 8</li><li>MySQL<h3 id="基础组件"><a href="#基础组件" class="headerlink" title="基础组件"></a>基础组件</h3></li><li>Mybatis</li><li>Guava</li><li>Lombok</li><li>Redis</li><li>Kafka<h3 id="高级组件"><a href="#高级组件" class="headerlink" title="高级组件"></a>高级组件</h3></li><li>Joda-Time</li><li>Atomic包</li><li>J.U.C(java.util.concurrent)</li><li>AQS</li><li>ThreadLocal</li><li>RateLimiter</li><li>Hystrix</li><li>threadPool</li><li>shardbatis</li><li>curator</li><li>elastic-job</li><li>…</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;覆盖知识点&quot;&gt;&lt;a href=&quot;#覆盖知识点&quot; class=&quot;headerlink&quot; title=&quot;覆盖知识点&quot;&gt;&lt;/a&gt;覆盖知识点&lt;/h3&gt;&lt;h4 id=&quot;线程安全&quot;&gt;&lt;a href=&quot;#线程安全&quot; class=&quot;headerlink&quot; title=&quot;线程安全&quot;&gt;&lt;/a&gt;线程安全&lt;/h4&gt;&lt;h4 id=&quot;线程封闭&quot;&gt;&lt;a href=&quot;#线程封闭&quot; class=&quot;headerlink&quot; title=&quot;线程封闭&quot;&gt;&lt;/a&gt;线程封闭&lt;/h4&gt;
    
    </summary>
    
      <category term="Java之并发编程" scheme="http://suprisemf.github.io/categories/Java%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java" scheme="http://suprisemf.github.io/tags/Java/"/>
    
      <category term="并发编程" scheme="http://suprisemf.github.io/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>红宝石星球</title>
  
  <subtitle>凡心所向，素履以往；生如逆旅，一苇以航。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://suprisemf.github.io/"/>
  <updated>2018-08-02T07:22:46.344Z</updated>
  <id>http://suprisemf.github.io/</id>
  
  <author>
    <name>SupriseMF</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CPU多级缓存</title>
    <link href="http://suprisemf.github.io/2018/08/02/cpu%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98/"/>
    <id>http://suprisemf.github.io/2018/08/02/cpu多级缓存/</id>
    <published>2018-08-02T07:12:45.000Z</published>
    <updated>2018-08-02T07:22:46.344Z</updated>
    
    <content type="html"><![CDATA[<h4 id="CPU多级缓存演进"><a href="#CPU多级缓存演进" class="headerlink" title="CPU多级缓存演进"></a>CPU多级缓存演进</h4><a id="more"></a><p><img src="/2018/08/02/cpu多级缓存/CPU多级缓存.png" alt="CPU多级缓存"></p><h4 id="CPU中cache的意义"><a href="#CPU中cache的意义" class="headerlink" title="CPU中cache的意义"></a>CPU中cache的意义</h4><p>由于CPU的频率太快了，快到主存跟不上，这样在处理器时钟周期内，CPU常常需要等待主存，浪费资源。所以cache的出现，是为了缓解CPU和内存之间速度的不匹配问题(结构：cpu-&gt;cache-&gt;memory)</p><h5 id="CPU-cache的局部性："><a href="#CPU-cache的局部性：" class="headerlink" title="CPU cache的局部性："></a>CPU cache的局部性：</h5><ol><li>时间局部性：如果某个数据被访问，那么在不久的将来它很可能再次被访问；</li><li>空间局部性：如果某个数据被访问，那么与它相邻的数据很快也能被访问。<h3 id="缓存一致性-MESI"><a href="#缓存一致性-MESI" class="headerlink" title="缓存一致性(MESI)"></a>缓存一致性(MESI)</h3>保证多个CPU的cache之间缓存共享数据的一致性，其中MESI即其中的四种状态：Modified（被修改的）、Exclusive（独享的）、Shared（共享的）、Invalid（无效的）；<br>如下图所示：图中M、E、S、I分别指的是Modified、Exclusive、Shared、Invalid。</li></ol><p><img src="/2018/08/02/cpu多级缓存/MESI.png" alt="图示"></p><blockquote><ul><li>Modified（被修改的）:该值现存于缓存cache中，且由于被修改而与内存中的对应值不一致，且在未来会被写入内存；</li><li>Exclusive（独享的）：该缓存行中的数据与内存中的对应值是一致的，当系统调用到该数据时及转化为Shared（共享的）状态；</li><li>Shared（共享的）：该缓存行可能会被多个CPU调用，且与多个cache中数据一致，当被一个CPU修改时，其他缓存中的该数据转化为Invalid（无效的）即被作废；</li><li>Invalid（无效的）：可能是其他CPU修改了该缓存行；</li><li><strong>其中四个状态转换之间的操作为：local read、local write、remote read、remote write。其中local指的是本地缓存，remote指的是主内存</strong></li></ul></blockquote><h4 id="在典型的多核系统中，每个核都有属于自己的缓存来共享内存总线bus，每个相应的CPU会发出自己的读写请求；而缓存的目的是为了减少各CPU读写共享内存的次数。上图中：除了Invalid（无效的）状态不可本地读，其他均可满足CPU的读请求；一个写请求只有在该缓存行处于Modified（被修改的）、Exclusive（独享的）状态时才可以被执行（local-write或remote-write）；若当前状态为Shared（共享的），且被remote-write修改，则CPU须将其转化为Invalid（无效的），通过广播方式完成，此时及不允许CPU修改同一缓存行（即使修改该缓存行的不同位置的数据也是不允许）；处于Modified（被修改的）的缓存行须时刻监听试图读该缓存行（相对于内存）的操作，该操作必须将该缓存行写入内存，并将在其状态变为Shared（共享的）之前被延迟执行；一个处于Shared（共享的）状态的缓存行需要监听其他缓存使该缓存行无效或独享该缓存行的请求，若有则将转化为Invalid（无效的）状态；处于Exclusive（独享的）状态的缓存行须监听其他缓存的读缓存操作，一旦有关于该缓存行的操作，它须转化为Shared（共享的）状态；因此对于Modified（被修改的）、Exclusive（独享的）状态，其数据总是精确的，他们和缓存行的真正状态是一致的，而Shared（共享的）状态可能是非一致的；如果一个缓存将处于Shared（共享的）状态的缓存行作废，另外的缓存可能以及读取了该缓存行，但是该缓存却不会讲其升级为Exclusive（独享的）状态，是因为：其他缓存不会广播该缓存行作废的通知，同样，由于缓存并不保存该缓存行的copy的数量，因此也无法确定自己是否已经对该缓存行处于Exclusive（独享的）状态。"><a href="#在典型的多核系统中，每个核都有属于自己的缓存来共享内存总线bus，每个相应的CPU会发出自己的读写请求；而缓存的目的是为了减少各CPU读写共享内存的次数。上图中：除了Invalid（无效的）状态不可本地读，其他均可满足CPU的读请求；一个写请求只有在该缓存行处于Modified（被修改的）、Exclusive（独享的）状态时才可以被执行（local-write或remote-write）；若当前状态为Shared（共享的），且被remote-write修改，则CPU须将其转化为Invalid（无效的），通过广播方式完成，此时及不允许CPU修改同一缓存行（即使修改该缓存行的不同位置的数据也是不允许）；处于Modified（被修改的）的缓存行须时刻监听试图读该缓存行（相对于内存）的操作，该操作必须将该缓存行写入内存，并将在其状态变为Shared（共享的）之前被延迟执行；一个处于Shared（共享的）状态的缓存行需要监听其他缓存使该缓存行无效或独享该缓存行的请求，若有则将转化为Invalid（无效的）状态；处于Exclusive（独享的）状态的缓存行须监听其他缓存的读缓存操作，一旦有关于该缓存行的操作，它须转化为Shared（共享的）状态；因此对于Modified（被修改的）、Exclusive（独享的）状态，其数据总是精确的，他们和缓存行的真正状态是一致的，而Shared（共享的）状态可能是非一致的；如果一个缓存将处于Shared（共享的）状态的缓存行作废，另外的缓存可能以及读取了该缓存行，但是该缓存却不会讲其升级为Exclusive（独享的）状态，是因为：其他缓存不会广播该缓存行作废的通知，同样，由于缓存并不保存该缓存行的copy的数量，因此也无法确定自己是否已经对该缓存行处于Exclusive（独享的）状态。" class="headerlink" title="在典型的多核系统中，每个核都有属于自己的缓存来共享内存总线bus，每个相应的CPU会发出自己的读写请求；而缓存的目的是为了减少各CPU读写共享内存的次数。上图中：除了Invalid（无效的）状态不可本地读，其他均可满足CPU的读请求；一个写请求只有在该缓存行处于Modified（被修改的）、Exclusive（独享的）状态时才可以被执行（local write或remote write）；若当前状态为Shared（共享的），且被remote write修改，则CPU须将其转化为Invalid（无效的），通过广播方式完成，此时及不允许CPU修改同一缓存行（即使修改该缓存行的不同位置的数据也是不允许）；处于Modified（被修改的）的缓存行须时刻监听试图读该缓存行（相对于内存）的操作，该操作必须将该缓存行写入内存，并将在其状态变为Shared（共享的）之前被延迟执行；一个处于Shared（共享的）状态的缓存行需要监听其他缓存使该缓存行无效或独享该缓存行的请求，若有则将转化为Invalid（无效的）状态；处于Exclusive（独享的）状态的缓存行须监听其他缓存的读缓存操作，一旦有关于该缓存行的操作，它须转化为Shared（共享的）状态；因此对于Modified（被修改的）、Exclusive（独享的）状态，其数据总是精确的，他们和缓存行的真正状态是一致的，而Shared（共享的）状态可能是非一致的；如果一个缓存将处于Shared（共享的）状态的缓存行作废，另外的缓存可能以及读取了该缓存行，但是该缓存却不会讲其升级为Exclusive（独享的）状态，是因为：其他缓存不会广播该缓存行作废的通知，同样，由于缓存并不保存该缓存行的copy的数量，因此也无法确定自己是否已经对该缓存行处于Exclusive（独享的）状态。"></a><strong>在典型的多核系统中，每个核都有属于自己的缓存来共享内存总线bus，每个相应的CPU会发出自己的读写请求；而缓存的目的是为了减少各CPU读写共享内存的次数。上图中：除了Invalid（无效的）状态不可本地读，其他均可满足CPU的读请求；一个写请求只有在该缓存行处于Modified（被修改的）、Exclusive（独享的）状态时才可以被执行（local write或remote write）；若当前状态为Shared（共享的），且被remote write修改，则CPU须将其转化为Invalid（无效的），通过广播方式完成，此时及不允许CPU修改同一缓存行（即使修改该缓存行的不同位置的数据也是不允许）；处于Modified（被修改的）的缓存行须时刻监听试图读该缓存行（相对于内存）的操作，该操作必须将该缓存行写入内存，并将在其状态变为Shared（共享的）之前被延迟执行；一个处于Shared（共享的）状态的缓存行需要监听其他缓存使该缓存行无效或独享该缓存行的请求，若有则将转化为Invalid（无效的）状态；处于Exclusive（独享的）状态的缓存行须监听其他缓存的读缓存操作，一旦有关于该缓存行的操作，它须转化为Shared（共享的）状态；因此对于Modified（被修改的）、Exclusive（独享的）状态，其数据总是精确的，他们和缓存行的真正状态是一致的，而Shared（共享的）状态可能是非一致的；如果一个缓存将处于Shared（共享的）状态的缓存行作废，另外的缓存可能以及读取了该缓存行，但是该缓存却不会讲其升级为Exclusive（独享的）状态，是因为：其他缓存不会广播该缓存行作废的通知，同样，由于缓存并不保存该缓存行的copy的数量，因此也无法确定自己是否已经对该缓存行处于Exclusive（独享的）状态。</strong></h4><blockquote><p>由上来看：Exclusive（独享的）状态更像是一中投机性优化，因为若一个CPU想修改处于Shared（共享的）状态的缓存行，须调用总线bus事务将所有该缓存行的copy值转化为Invalid（无效的）状态；而修改处于Exclusive（独享的）状态的缓存行则不需使用总线事务</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;CPU多级缓存演进&quot;&gt;&lt;a href=&quot;#CPU多级缓存演进&quot; class=&quot;headerlink&quot; title=&quot;CPU多级缓存演进&quot;&gt;&lt;/a&gt;CPU多级缓存演进&lt;/h4&gt;
    
    </summary>
    
      <category term="Java并发编程" scheme="http://suprisemf.github.io/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java" scheme="http://suprisemf.github.io/tags/Java/"/>
    
      <category term="并发编程" scheme="http://suprisemf.github.io/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>并发编程与高并发解决方案概论</title>
    <link href="http://suprisemf.github.io/2018/08/02/%E6%A6%82%E8%AE%BA%E5%A4%A7%E7%AC%94%E8%AE%B0/"/>
    <id>http://suprisemf.github.io/2018/08/02/概论大笔记/</id>
    <published>2018-08-02T06:58:51.000Z</published>
    <updated>2018-08-02T07:15:53.117Z</updated>
    
    <content type="html"><![CDATA[<h3 id="覆盖知识点"><a href="#覆盖知识点" class="headerlink" title="覆盖知识点"></a>覆盖知识点</h3><h4 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h4><h4 id="线程封闭"><a href="#线程封闭" class="headerlink" title="线程封闭"></a>线程封闭</h4><a id="more"></a><h4 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h4><h4 id="同步容器"><a href="#同步容器" class="headerlink" title="同步容器"></a>同步容器</h4><h4 id="并发容器"><a href="#并发容器" class="headerlink" title="并发容器"></a>并发容器</h4><h4 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h4><h4 id="J-U-C"><a href="#J-U-C" class="headerlink" title="J.U.C"></a>J.U.C</h4><h4 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h4><h3 id="高并发解决思路与方法"><a href="#高并发解决思路与方法" class="headerlink" title="高并发解决思路与方法"></a>高并发解决思路与方法</h3><h4 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h4><h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><h4 id="拆分"><a href="#拆分" class="headerlink" title="拆分"></a>拆分</h4><h4 id="服务降级与熔断"><a href="#服务降级与熔断" class="headerlink" title="服务降级与熔断"></a>服务降级与熔断</h4><h4 id="数据库切库"><a href="#数据库切库" class="headerlink" title="数据库切库"></a>数据库切库</h4><h4 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h4><h4 id="杂项-1"><a href="#杂项-1" class="headerlink" title="杂项"></a>杂项</h4><h3 id="总体架构"><a href="#总体架构" class="headerlink" title="总体架构"></a>总体架构</h3><ul><li>Spring Boot</li><li>Maven</li><li>JDK 8</li><li>MySQL<h3 id="基础组件"><a href="#基础组件" class="headerlink" title="基础组件"></a>基础组件</h3></li><li>Mybatis</li><li>Guava</li><li>Lombok</li><li>Redis</li><li>Kafka<h3 id="高级组件"><a href="#高级组件" class="headerlink" title="高级组件"></a>高级组件</h3></li><li>Joda-Time</li><li>Atomic包</li><li>J.U.C(java.util.concurrent)</li><li>AQS</li><li>ThreadLocal</li><li>RateLimiter</li><li>Hystrix</li><li>threadPool</li><li>shardbatis</li><li>curator</li><li>elastic-job</li><li>…</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;覆盖知识点&quot;&gt;&lt;a href=&quot;#覆盖知识点&quot; class=&quot;headerlink&quot; title=&quot;覆盖知识点&quot;&gt;&lt;/a&gt;覆盖知识点&lt;/h3&gt;&lt;h4 id=&quot;线程安全&quot;&gt;&lt;a href=&quot;#线程安全&quot; class=&quot;headerlink&quot; title=&quot;线程安全&quot;&gt;&lt;/a&gt;线程安全&lt;/h4&gt;&lt;h4 id=&quot;线程封闭&quot;&gt;&lt;a href=&quot;#线程封闭&quot; class=&quot;headerlink&quot; title=&quot;线程封闭&quot;&gt;&lt;/a&gt;线程封闭&lt;/h4&gt;
    
    </summary>
    
      <category term="Java并发编程" scheme="http://suprisemf.github.io/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java" scheme="http://suprisemf.github.io/tags/Java/"/>
    
      <category term="并发编程" scheme="http://suprisemf.github.io/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>（基于Java）编写编译器和解释器-第二章：初始框架-Part-1</title>
    <link href="http://suprisemf.github.io/2018/07/18/%E7%BC%96%E8%AF%91%E5%99%A8%E7%AC%AC%E4%BA%8C%E7%AB%A0Part1/"/>
    <id>http://suprisemf.github.io/2018/07/18/编译器第二章Part1/</id>
    <published>2018-07-18T12:27:15.000Z</published>
    <updated>2018-07-18T13:06:09.767Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本章将会从前一章的概念设计带你到初级的实现过程。你将先为编译器和解释器构造一个灵活的框架，接着将初级版的编译器解释器组件集成到框架中。最后编写端对端的测试用例检验这些框架和组件。<br><a id="more"></a></p></blockquote><h2 id="目标和方法"><a href="#目标和方法" class="headerlink" title="目标和方法"></a>目标和方法</h2><p>此章的设计方法首先会让你觉得过于繁琐啰嗦，的确，本章结束后将会有一大堆超过你预期数量的代码。但请记你在用早被证明的软件工程法则和优秀面向对象设计构建编译器和解释器。</p><p>如在概念设计中描述的那样，编译器和解释器将尽可能复用组件，因只有后端有所不同。在这章中，你将构建一个灵活的框架并首先放置那些已被深度简化的编译器和解释器组件。不过它们足够验证你设计的框架是否恰当即组件能很好的耦合并能协同工作。这个成功前提将会使得从公用前端到编译器解释器后端的端对端执行代码编写，还有后续的增量式组件开发变得简单。</p><p>本章的目标是：</p><ul><li>一个语言无关的框架，可支持编译器和解释器。</li><li>集成进框架前端(<strong>front end</strong>)的初级版Pascal语言相关组件。</li><li>集成进框架后端(<strong>back end</strong>)的初级版编译器和解释器组件。</li><li>通过从公共前端生成源程序清单以及从编译器或解释器后端生成消息，简单的运行端对端测试，测试相关组件。</li></ul><blockquote><p><strong>设计笔记</strong>：<br>不管任何时候开发负责程序如编译器或解释器，成功的首要步骤是：</p><ul><li>设计和实现一个合适的框架。</li><li>开发能与框架良好集成的初级组件，且这些组件也能良好集成在一起。</li><li>通过运行简单端对端代码来测试框架和组件的融合程度。</li></ul><p>早期的组件集成是关键，甚至你已经简化了初级组件<code>(没有完善的组件称之为初级组件）</code>也一样。尽可能早的测试矿建和组件以让它们更好的协作。框架和初级组件组成你后续开发的基础。开发将是增量式的进行，代码在每次增量后都能继续工作<code>（附加更多功能）</code>。你该永远基于可运行的代码去构建。</p></blockquote><h2 id="语言无关的框架组件"><a href="#语言无关的框架组件" class="headerlink" title="语言无关的框架组件"></a>语言无关的框架组件</h2><p>基于概念设计，框架包含三个包：frontend、intermediate、 backend。</p><p>框架组件是用来定义框架且语言无关的接口和类。有些是抽象类。一旦框架组件就绪，你能开发抽象类的Pascal实现<code>（组件语言无关，实现语言相关）</code>。图2-1 展示了使用UML 包和类图的框架组件。<br>下图在frontend，intermediate，backend包中的语言无关组件一起定义了一个能支持编译器和解释器后续开发的框架。</p><p><img src="/2018/07/18/编译器第二章Part1/2-1.png" alt="图2-1"></p><blockquote><p><strong>设计笔记</strong>：统一建模语言是一个工业级的展示面向对象软件架构和过程的图形化语言。各种图表(序列图，类图等）能表示程序的结构组件之间的静态关系，也能表示组件运行期的动态行为。</p></blockquote><h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h2><p>在前端包中，语言无关类Paser，Scanner，Token，Source代表框架组件。框架类强制你在忽略具体源语言的情况下，能尽力思考每个前端组件的职责，还有它们之间的交互。图2-2中的UML 类图展示了它们的关系。</p><p><img src="/2018/07/18/编译器第二章Part1/2-2.png" alt="图2-2"></p><p>Parser和Scanner是抽象类；语言相关的子类将实现它们的抽象方法。parser和scanner联系紧密，Parser有一个受保护域(<strong>protected field</strong>)scanner指向Scanner。Parser从Scanner请求token，所以它依赖Token。Scanner有一个私有域currentToken，它通过受保护域source引用Source，还将source引用传给每个自己构造的token。每个Token也能通过受保护域source拥有Source引用，在它的构造过程中，通过source读取字符。<br>下面的类图更进一步展示了四个前端框架类。它展示了域，方法和其他的前端类和接口。例如每个Token有一个用TokenType类表示的token类型，EofToken是Token的子类。</p><p><img src="/2018/07/18/编译器第二章Part1/2-3.png" alt="图2-3"></p><p>按照概念设计，parser控制翻译过程，它翻译源程序，所以Parser类有一个抽象方法parser()；语言相关的方法实现将不断的找scanner索取下一个token。Parser的currentToken()和nextToken()仅仅是scanner的代理方法而已<code>(参考代理模式，不过这儿是为了少写点代码）</code>。语言相关的getErrorCount()方法实现返回语法错误数量。</p><blockquote><p><strong>设计笔记</strong>：在UML类图中，一个未填充箭头的箭号表示一个类引用或依赖另一个类。虚线箭号<code>(比如从Parser到Token的肩头)</code>表示一个仅仅在方法调用期间<code>(比如Parser的nextToken()方法返回一个Token对象）</code>存在的引用。实线箭号且在出发端有一个空菱形意味着一个类通过在对象生命周期持续的引用，拥有(<strong>owns</strong>)或聚合(<strong>aggregates</strong>)另一个类。<code>(假设类A通过引用域ref聚合类B，那么类A的对象a1聚合类B的对象b1的这种关系在a1的生命周期一直存在，聚合相当于包含，a1负责b1的生命周期)</code>。 域名称保存标识箭头的引用<code>（例如，Parser类用它的scanner域维护对Scanner类的引用)</code>。<br>实心箭号带空箭头（如EofToken类到Token类)表示一个子类到它的父类。<br>类名称下，一个类图可选择的包含域(field)描述区域和方法描述区域。标识箭号名称的域名不在域描述区域出现(Parser有个域scanner引用类Scanner，它不在Parser的域描述区域出现，在生成代码后就会有）。在域名或者方法名前面的字符表明访问控制。</p><ul><li>+：public 公共</li><li>-：private 私有</li><li>#：protected 受保护</li><li>~：package 包权限，即此包中的其它类都可以访问。<br>跟在域名或方法名冒号后面的分别是域类型或者返回值类型。为省地方，类图通常不显示构造函数和域名的getter和setter方法。<br>抽象类名以斜体出现。抽象方法名还是斜体。</li></ul></blockquote><p>scanner从源程序中抽取token。Scanner类抽象方法extractToken()的语言相关实现将会根据具体语言从Source中读取字符，以便构造Token。Scanner的快捷方法currentChar()和nextChar()会调用Source类中的对应方法<code>(还是代理模式)</code></p><p>Token的域保存有关Token的有用信息，包括类型，文本串<code>（即字面上的字符串）</code>，值和它在源程序中的位置<code>（行号和位置【相对于行】)</code>。Token同样有Source类的快捷方法currentChar()和nextChar()。Token类型与具体语言有关。当前的Token类型是一个占位符<code>(因为一个具体类型都没有)</code>。</p><p>后面你将会根据具体语言创建语言相关的Token子类。但目前只有语言无关EofToken子类，它表示源文件终止。使用Token子类使得scanner代码更加模块化，因为不同类型Token需要不同计算方式。<code>（原文是算法，我认为谈不上算法）</code>。</p><h2 id="Parser"><a href="#Parser" class="headerlink" title="Parser"></a>Parser</h2><p>清单2-1 展示了框架抽象类Parser的关键方法。语言相关的Parser子类要实现parse()方法和getErrorCount()，分别用来表示源程序分析过程和返回语法错误。如上文提到的，Parser的currentToken()和nextToken()方法是scanner对应方法的代理。<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>: <span class="comment">/**</span></span><br><span class="line"><span class="comment"> 2:  * &lt;p&gt;语言无关的Parser，有子类完成具体语言解析&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> 3:  */</span></span><br><span class="line"> <span class="number">4</span>: <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> Parser <span class="keyword">implements</span> MessageProducer</span><br><span class="line"> <span class="number">5</span>: &#123;</span><br><span class="line"> <span class="number">6</span>:     <span class="keyword">protected</span> <span class="keyword">static</span> SymTab symTab = <span class="keyword">null</span>;                  <span class="comment">// 生成的符号表</span></span><br><span class="line"> <span class="number">7</span>:</span><br><span class="line"> <span class="number">8</span>:     <span class="keyword">protected</span> <span class="keyword">final</span> Scanner scanner;  <span class="comment">// 扫描器SCANNER，Parser找它要token</span></span><br><span class="line"> <span class="number">9</span>:     <span class="keyword">protected</span> ICode iCode;      <span class="comment">// 语法树根节点。</span></span><br><span class="line"><span class="number">10</span>:</span><br><span class="line"><span class="number">11</span>:     <span class="keyword">protected</span> Parser(Scanner scanner)</span><br><span class="line"><span class="number">12</span>:     &#123;</span><br><span class="line"><span class="number">13</span>:         <span class="keyword">this</span>.scanner = scanner;</span><br><span class="line"><span class="number">14</span>:         <span class="keyword">this</span>.iCode = <span class="keyword">null</span>;</span><br><span class="line"><span class="number">15</span>:     &#125;</span><br><span class="line"><span class="number">16</span>:     <span class="comment">/**</span></span><br><span class="line"><span class="comment">17:      * 交由子类完成具体语言相关的解析过程，这个方法调用之后将会产生符号表和中间码iCode。</span></span><br><span class="line"><span class="comment">18:      * @throws Exception</span></span><br><span class="line"><span class="comment">19:      */</span></span><br><span class="line"><span class="number">20</span>:     <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> parse()</span><br><span class="line"><span class="number">21</span>:         <span class="keyword">throws</span> Exception;</span><br><span class="line"><span class="number">22</span>:     <span class="comment">/**</span></span><br><span class="line"><span class="comment">23:      * @return 解析过程中的错误数</span></span><br><span class="line"><span class="comment">24:      */</span></span><br><span class="line"><span class="number">25</span>:     <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> getErrorCount();</span><br><span class="line"><span class="number">26</span>:</span><br><span class="line"><span class="number">27</span>:     <span class="keyword">public</span> Token currentToken()</span><br><span class="line"><span class="number">28</span>:     &#123;</span><br><span class="line"><span class="number">29</span>:         <span class="keyword">return</span> scanner.currentToken();</span><br><span class="line"><span class="number">30</span>:     &#125;</span><br><span class="line"><span class="number">31</span>:</span><br><span class="line"><span class="number">32</span>:     <span class="keyword">public</span> Token nextToken()</span><br><span class="line"><span class="number">33</span>:         <span class="keyword">throws</span> Exception</span><br><span class="line"><span class="number">34</span>:     &#123;</span><br><span class="line"><span class="number">35</span>:         <span class="keyword">return</span> scanner.nextToken();</span><br><span class="line"><span class="number">36</span>:     &#125;</span><br><span class="line"><span class="number">37</span>:     <span class="comment">//.....</span></span><br><span class="line"><span class="number">38</span>: &#125;</span><br></pre></td></tr></table></figure></p><p>因为前端只会产生一个符号表SymTab，所以符号表在Parser中以symTab域出现。</p><h4 id="Source类"><a href="#Source类" class="headerlink" title="Source类"></a>Source类</h4><p>清单2-2 展示了框架类Source的关键方法。<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">1</span>: <span class="comment">/**</span></span><br><span class="line"><span class="comment">  2:  * &lt;p&gt;此框架类的每个对象代表一个源文件&lt;/p&gt;</span></span><br><span class="line"><span class="comment">  3:  */</span></span><br><span class="line">  <span class="number">4</span>: <span class="keyword">public</span> class Source implements MessageProducer</span><br><span class="line">  <span class="number">5</span>: &#123;</span><br><span class="line">  <span class="number">6</span>:     <span class="comment">// 行结束符，注意在Windows平台上，默认行结束符是\r\n，</span></span><br><span class="line">  <span class="number">7</span>:     <span class="comment">//如果用记事本之类的写的pascal源程序，可以使用Ultraedit之类的给转成Unix格式的。</span></span><br><span class="line">  <span class="number">8</span>:     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">char</span> EOL = <span class="string">'\n'</span>;</span><br><span class="line">  <span class="number">9</span>:     <span class="comment">//文件结束标识</span></span><br><span class="line"> <span class="number">10</span>:     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">char</span> EOF = (<span class="built_in">char</span>) <span class="number">0</span>;</span><br><span class="line"> <span class="number">11</span>:     <span class="comment">//源程序reader</span></span><br><span class="line"> <span class="number">12</span>:     <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">BufferedReader</span> reader;</span><br><span class="line"> <span class="number">13</span>:     <span class="keyword">private</span> <span class="keyword">String</span> <span class="built_in">line</span>;</span><br><span class="line"> <span class="number">14</span>:     <span class="keyword">private</span> <span class="built_in">int</span> lineNum;</span><br><span class="line"> <span class="number">15</span>:     <span class="keyword">private</span> <span class="built_in">int</span> currentPos;                   <span class="comment">// 当前行相对位置，不是整个文件的offset！！</span></span><br><span class="line"> <span class="number">16</span>:     <span class="keyword">public</span> Source(<span class="keyword">BufferedReader</span> reader)</span><br><span class="line"> <span class="number">17</span>:         <span class="keyword">throws</span> IOException</span><br><span class="line"> <span class="number">18</span>:     &#123;</span><br><span class="line"> <span class="number">19</span>:         <span class="keyword">this</span>.lineNum = <span class="number">0</span>;</span><br><span class="line"> <span class="number">20</span>:         <span class="keyword">this</span>.currentPos = <span class="number">-2</span>;  <span class="comment">// 设置为-2表示文件一行都没有读，后面的判断可以根据是否等于-2读文件第一行。</span></span><br><span class="line"> <span class="number">21</span>:         <span class="keyword">this</span>.reader = reader;</span><br><span class="line"> <span class="number">22</span>:         <span class="keyword">this</span>.messageHandler = <span class="keyword">new</span> MessageHandler();</span><br><span class="line"> <span class="number">23</span>:     &#125;</span><br><span class="line"> <span class="number">24</span>:</span><br><span class="line"> <span class="number">25</span>:     <span class="comment">/**</span></span><br><span class="line"><span class="comment"> 26:      * @return 要去读的字符</span></span><br><span class="line"><span class="comment"> 27:      * @throws Exception(read过程中的异常)</span></span><br><span class="line"><span class="comment"> 28:      */</span></span><br><span class="line"> <span class="number">29</span>:     <span class="keyword">public</span> <span class="built_in">char</span> currentChar()</span><br><span class="line"> <span class="number">30</span>:         <span class="keyword">throws</span> Exception</span><br><span class="line"> <span class="number">31</span>:     &#123;</span><br><span class="line"> <span class="number">32</span>:         <span class="comment">// 第一次读?</span></span><br><span class="line"> <span class="number">33</span>:         <span class="keyword">if</span> (currentPos == <span class="number">-2</span>) &#123;</span><br><span class="line"> <span class="number">34</span>:             readLine();</span><br><span class="line"> <span class="number">35</span>:             <span class="keyword">return</span> nextChar();</span><br><span class="line"> <span class="number">36</span>:         &#125;</span><br><span class="line"> <span class="number">37</span>:</span><br><span class="line"> <span class="number">38</span>:         <span class="comment">// 文件结束?</span></span><br><span class="line"> <span class="number">39</span>:         <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">line</span> == <span class="keyword">null</span>) &#123;</span><br><span class="line"> <span class="number">40</span>:             <span class="keyword">return</span> EOF;</span><br><span class="line"> <span class="number">41</span>:         &#125;</span><br><span class="line"> <span class="number">42</span>:</span><br><span class="line"> <span class="number">43</span>:         <span class="comment">// 行结束?</span></span><br><span class="line"> <span class="number">44</span>:         <span class="keyword">else</span> <span class="keyword">if</span> ((currentPos == <span class="number">-1</span>) || (currentPos == <span class="built_in">line</span>.length())) &#123;</span><br><span class="line"> <span class="number">45</span>:             <span class="keyword">return</span> EOL;</span><br><span class="line"> <span class="number">46</span>:         &#125;</span><br><span class="line"> <span class="number">47</span>:</span><br><span class="line"> <span class="number">48</span>:         <span class="comment">// 超过一行，换一行再读</span></span><br><span class="line"> <span class="number">49</span>:         <span class="keyword">else</span> <span class="keyword">if</span> (currentPos &gt; <span class="built_in">line</span>.length()) &#123;</span><br><span class="line"> <span class="number">50</span>:             readLine();</span><br><span class="line"> <span class="number">51</span>:             <span class="keyword">return</span> nextChar();</span><br><span class="line"> <span class="number">52</span>:         &#125;</span><br><span class="line"> <span class="number">53</span>:</span><br><span class="line"> <span class="number">54</span>:         <span class="comment">// 正常读取当前行的某一列的字符</span></span><br><span class="line"> <span class="number">55</span>:         <span class="keyword">else</span> &#123;</span><br><span class="line"> <span class="number">56</span>:             <span class="keyword">return</span> <span class="built_in">line</span>.charAt(currentPos);</span><br><span class="line"> <span class="number">57</span>:         &#125;</span><br><span class="line"> <span class="number">58</span>:     &#125;</span><br><span class="line"> <span class="number">59</span>:</span><br><span class="line"> <span class="number">60</span>:     <span class="comment">/**</span></span><br><span class="line"><span class="comment"> 61:      *位置游标前进一步并返回对应的字符，记住source的位置游标&lt;b&gt;从来不后退，只有向前操作。&lt;/b&gt;</span></span><br><span class="line"><span class="comment"> 62:      * @return 下一个要读取的字符</span></span><br><span class="line"><span class="comment"> 63:      * @throws Exception</span></span><br><span class="line"><span class="comment"> 64:      */</span></span><br><span class="line"> <span class="number">65</span>:     <span class="keyword">public</span> <span class="built_in">char</span> nextChar()</span><br><span class="line"> <span class="number">66</span>:         <span class="keyword">throws</span> Exception</span><br><span class="line"> <span class="number">67</span>:     &#123;</span><br><span class="line"> <span class="number">68</span>:         ++currentPos;</span><br><span class="line"> <span class="number">69</span>:         <span class="keyword">return</span> currentChar();</span><br><span class="line"> <span class="number">70</span>:     &#125;</span><br><span class="line"> <span class="number">71</span>:</span><br><span class="line"> <span class="number">72</span>:     <span class="comment">/**</span></span><br><span class="line"><span class="comment"> 73:      * 探测下一字符，位置游标不增加，跟Stack（栈）的Peek方法一样效果。</span></span><br><span class="line"><span class="comment"> 74:      * @return 当前位置的字符</span></span><br><span class="line"><span class="comment"> 75:      * @throws Exception</span></span><br><span class="line"><span class="comment"> 76:      */</span></span><br><span class="line"> <span class="number">77</span>:     <span class="keyword">public</span> <span class="built_in">char</span> peekChar()</span><br><span class="line"> <span class="number">78</span>:         <span class="keyword">throws</span> Exception</span><br><span class="line"> <span class="number">79</span>:     &#123;</span><br><span class="line"> <span class="number">80</span>:         currentChar();</span><br><span class="line"> <span class="number">81</span>:         <span class="keyword">if</span> (<span class="built_in">line</span> == <span class="keyword">null</span>) &#123;</span><br><span class="line"> <span class="number">82</span>:             <span class="keyword">return</span> EOF;</span><br><span class="line"> <span class="number">83</span>:         &#125;</span><br><span class="line"> <span class="number">84</span>:</span><br><span class="line"> <span class="number">85</span>:         <span class="built_in">int</span> nextPos = currentPos + <span class="number">1</span>;</span><br><span class="line"> <span class="number">86</span>:         <span class="keyword">return</span> nextPos &lt; <span class="built_in">line</span>.length() ? <span class="built_in">line</span>.charAt(nextPos) : EOL;</span><br><span class="line"> <span class="number">87</span>:     &#125;</span><br><span class="line"> <span class="number">88</span>:     <span class="comment">/**</span></span><br><span class="line"><span class="comment"> 89:      * 读入一行</span></span><br><span class="line"><span class="comment"> 90:      * @throws IOException</span></span><br><span class="line"><span class="comment"> 91:      */</span></span><br><span class="line"> <span class="number">92</span>:     <span class="keyword">private</span> <span class="keyword">void</span> readLine()</span><br><span class="line"> <span class="number">93</span>:         <span class="keyword">throws</span> IOException</span><br><span class="line"> <span class="number">94</span>:     &#123;</span><br><span class="line"> <span class="number">95</span>:         <span class="built_in">line</span> = reader.readLine();</span><br><span class="line"> <span class="number">96</span>:         currentPos = <span class="number">-1</span>;</span><br><span class="line"> <span class="number">97</span>:         <span class="comment">//如果读成功，行数+1</span></span><br><span class="line"> <span class="number">98</span>:         <span class="keyword">if</span> (<span class="built_in">line</span> != <span class="keyword">null</span>) &#123;</span><br><span class="line"> <span class="number">99</span>:             ++lineNum;</span><br><span class="line"><span class="number">100</span>:         &#125;</span><br><span class="line"><span class="number">101</span>:         <span class="comment">//每成功读入一行，将当前行数和当前行文本内容以消息方式广播，方便监听器处理。</span></span><br><span class="line"><span class="number">102</span>:         <span class="keyword">if</span> (<span class="built_in">line</span> != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="number">103</span>:             sendMessage(<span class="keyword">new</span> Message(SOURCE_LINE,</span><br><span class="line"><span class="number">104</span>:                                     <span class="keyword">new</span> <span class="keyword">Object</span>[] &#123;lineNum, <span class="built_in">line</span>&#125;));</span><br><span class="line"><span class="number">105</span>:         &#125;</span><br><span class="line"><span class="number">106</span>:     &#125;</span><br><span class="line"><span class="number">107</span>:     <span class="keyword">public</span> <span class="keyword">void</span> close()</span><br><span class="line"><span class="number">108</span>:         <span class="keyword">throws</span> Exception</span><br><span class="line"><span class="number">109</span>:     &#123;</span><br><span class="line"><span class="number">110</span>:         <span class="keyword">if</span> (reader != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="number">111</span>:             <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="number">112</span>:                 reader.close();</span><br><span class="line"><span class="number">113</span>:             &#125;</span><br><span class="line"><span class="number">114</span>:             <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line"><span class="number">115</span>:                 ex.printStackTrace();</span><br><span class="line"><span class="number">116</span>:                 <span class="keyword">throw</span> ex;</span><br><span class="line"><span class="number">117</span>:             &#125;</span><br><span class="line"><span class="number">118</span>:         &#125;</span><br><span class="line"><span class="number">119</span>:     &#125;</span><br><span class="line"><span class="number">120</span>:     <span class="comment">//more ignored</span></span><br><span class="line"><span class="number">121</span>: &#125;</span><br></pre></td></tr></table></figure></p><p>构造函数的参数是一个给Source使用的BufferdReader<code>（I/O类用来按字符读取源程序文件）</code>。你将会看到通过源文件创建BufferedReader是件很Easy的事情。你也可通过其它对象如路径串创建BufferedReader。BufferedReader是一个抽象类。你肯定不想Source类操心到底源程序文本内容怎么来的<code>（找bufferedReader即可)</code>。</p><p>方法currentChar()干了大部分事情，先前的调用会让它会调用readLine()方法读取第一行，则currentChar()返回这行的第一个字符。在后续的调用中，如果当前位置在行尾，它返回特别的EOL字符；如果已经超过行尾，currentChar再次readLine()返回下一行的第一个字符。如果读到文件末尾，line会是null值，那currentChar()返回一个特殊的EOF字符。其它情况下，此方法currentChar()简单的返回当在当前行currentPos位置的字符。</p><p>方法nextChar()将当前行的currentPos位置前进一步，接着调用chrrentChar()去返回下一个字符。<code>(注意位置指针前移了)</code></p><p>假设源文件当前行包含ABCDE五个字符且currentPos是0。那么按如下顺序调用currentChar()和nextChar()，每次调用返回字符如下标：<br><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">1</span>: currentChar() ⇒ 'A'</span><br><span class="line"><span class="attribute">2</span>:  nextChar()    ⇒ 'B'</span><br><span class="line"><span class="attribute">3</span>:  nextChar()    ⇒ 'C'</span><br><span class="line"><span class="attribute">4</span>:  nextChar()    ⇒ 'D'</span><br><span class="line"><span class="attribute">5</span>:  currentChar() ⇒ 'D'</span><br><span class="line"><span class="attribute">6</span>:  currentChar() ⇒ 'D'</span><br><span class="line"><span class="attribute">7</span>:  nextChar()    ⇒ 'E'</span><br><span class="line"><span class="attribute">8</span>:  nextChar()    ⇒ EOL</span><br></pre></td></tr></table></figure></p><p>nextChar()　“吞噬”当前字符<code>（将currentPos增1使其指向下一个字符）</code>，但currentChar()不是。有时候你需要调用nextChar()吞噬当前字符，但不用它返回的字符。你将会在后面和下章看到怎么使用这两个方法。</p><p>方法peekChar() “向前探测”<code>（后续将简称前探）</code>挨着当前字符的下一个字符，此操作不吞噬当前字符。下章中此方法将会区分单个Pascal Token “3.14”和三个Token “3..14.”。注意peekChar在当前位置处于行尾或者超过行尾是，不会读下一行，它总会返回EOL字符，这不会有啥问题。</p><p>在更新域line同时，方法readLine()会把lineNum加1且设置currentPos为0。</p><h4 id="Scanner类"><a href="#Scanner类" class="headerlink" title="Scanner类"></a>Scanner类</h4><p>清单2-3 展示了框架抽象类Scanner。语言相关的子类将会实现extractMethod方法。Parser调用其nextToken() 方法，而nextToken()方法调用extractToken()去设置和返回私有域currentToken的值。快捷方法currentChar()和nextChar()来自于Source类对应的方法。<br>清单2-3 抽象类Scanner<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"> 1: /**</span><br><span class="line"> 2:  * &lt;p&gt;语言无关的scanner，产生Token&lt;/p&gt;</span><br><span class="line"> 3:  */</span><br><span class="line"> 4: public abstract class Scanner</span><br><span class="line"> 5: &#123;</span><br><span class="line"> 6:     protected Source source;</span><br><span class="line"> 7:     <span class="keyword">private</span> Token currentToken;  //当前Token</span><br><span class="line"> 8:     public Scanner(Source source)</span><br><span class="line"> 9:     &#123;</span><br><span class="line"><span class="section">10:         this.source = source;</span></span><br><span class="line"><span class="section">11:     &#125;</span></span><br><span class="line"><span class="section">12:     public Token currentToken()</span></span><br><span class="line"><span class="section">13:     &#123;</span></span><br><span class="line"><span class="section">14:         return currentToken;</span></span><br><span class="line"><span class="section">15:     &#125;</span></span><br><span class="line"><span class="section">16:</span></span><br><span class="line"><span class="section">17:     /**</span></span><br><span class="line"><span class="section">18:      * 以source中的char序列模式抽取token</span></span><br><span class="line"><span class="section">19:      * @return 下一个token</span></span><br><span class="line"><span class="section">20:      * @throws Exception</span></span><br><span class="line"><span class="section">21:      */</span></span><br><span class="line"><span class="section">22:     public Token nextToken()</span></span><br><span class="line"><span class="section">23:         throws Exception</span></span><br><span class="line"><span class="section">24:     &#123;</span></span><br><span class="line"><span class="section">25:         currentToken = extractToken();</span></span><br><span class="line"><span class="section">26:         return currentToken;</span></span><br><span class="line"><span class="section">27:     &#125;</span></span><br><span class="line"><span class="section">28:</span></span><br><span class="line"><span class="section">29:     /**</span></span><br><span class="line"><span class="section">30:      * 因为每个源语言的Token构成方式不一样，所以这个具体语言的子类去实现。</span></span><br><span class="line"><span class="section">31:      * @return 语言相关的Token</span></span><br><span class="line"><span class="section">32:      * @throws Exception</span></span><br><span class="line"><span class="section">33:      */</span></span><br><span class="line"><span class="section">34:     protected abstract Token extractToken()</span></span><br><span class="line"><span class="section">35:         throws Exception;</span></span><br><span class="line"><span class="section">36:</span></span><br><span class="line"><span class="section">37:    /**</span></span><br><span class="line"><span class="section">38:     * source的一个快捷方法，可让子类比不依赖source</span></span><br><span class="line"><span class="section">39:     * @return 要读取的字符</span></span><br><span class="line"><span class="section">40:     * @throws Exception</span></span><br><span class="line"><span class="section">41:     */</span></span><br><span class="line"><span class="section">42:     public char currentChar()</span></span><br><span class="line"><span class="section">43:         throws Exception</span></span><br><span class="line"><span class="section">44:     &#123;</span></span><br><span class="line"><span class="section">45:         return source.currentChar();</span></span><br><span class="line"><span class="section">46:     &#125;</span></span><br><span class="line"><span class="section">47:     /**</span></span><br><span class="line"><span class="section">48:      * source的一个快捷方法，可让子类比不依赖source</span></span><br><span class="line"><span class="section">49:      * @return 下一个要读取的字符</span></span><br><span class="line"><span class="section">50:      * @throws Exception</span></span><br><span class="line"><span class="section">51:      */</span></span><br><span class="line"><span class="section">52:</span></span><br><span class="line"><span class="section">53:     public char nextChar()</span></span><br><span class="line"><span class="section">54:         throws Exception</span></span><br><span class="line"><span class="section">55:     &#123;</span></span><br><span class="line"><span class="section">56:         return source.nextChar();</span></span><br><span class="line"><span class="section">57:     &#125;</span></span><br><span class="line"><span class="section">58: &#125;</span></span><br></pre></td></tr></table></figure></p><h4 id="Token类"><a href="#Token类" class="headerlink" title="Token类"></a>Token类</h4><p>代码清单2-4 展示了Token类的关键方法<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span>: <span class="comment">/**</span></span><br><span class="line"><span class="comment"> 2:  * &lt;p&gt;Scanner扫描返回的最小语法单元，也是个比不可少的框架类&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> 3:  */</span></span><br><span class="line"> <span class="number">4</span>: <span class="keyword">public</span> <span class="keyword">class</span> Token</span><br><span class="line"> <span class="number">5</span>: &#123;</span><br><span class="line"> <span class="number">6</span>:     <span class="keyword">protected</span> TokenType type;  <span class="comment">// 语言相关的Token类型</span></span><br><span class="line"> <span class="number">7</span>:     <span class="keyword">protected</span> String text;     <span class="comment">// 字面文本</span></span><br><span class="line"> <span class="number">8</span>:     <span class="keyword">protected</span> Object value;    <span class="comment">// 值，如果是一些常量，直接可以算出值来的</span></span><br><span class="line"> <span class="number">9</span>:     <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">Source</span> <span class="keyword">source</span>;   <span class="comment">// source</span></span><br><span class="line"><span class="number">10</span>:     <span class="keyword">protected</span> <span class="keyword">int</span> lineNum;     <span class="comment">// 所在行</span></span><br><span class="line"><span class="number">11</span>:     <span class="keyword">protected</span> <span class="keyword">int</span> position;    <span class="comment">// Token第一个字符所在的位置，即行中列位置</span></span><br><span class="line"><span class="number">12</span>:     <span class="keyword">public</span> Token(<span class="keyword">Source</span> <span class="keyword">source</span>)</span><br><span class="line"><span class="number">13</span>:         <span class="keyword">throws</span> Exception</span><br><span class="line"><span class="number">14</span>:     &#123;</span><br><span class="line"><span class="number">15</span>:         <span class="keyword">this</span>.<span class="keyword">source</span> = <span class="keyword">source</span>;</span><br><span class="line"><span class="number">16</span>:         <span class="keyword">this</span>.lineNum = <span class="keyword">source</span>.getLineNum();</span><br><span class="line"><span class="number">17</span>:         <span class="keyword">this</span>.position = <span class="keyword">source</span>.getPosition();</span><br><span class="line"><span class="number">18</span>:         extract();</span><br><span class="line"><span class="number">19</span>:     &#125;</span><br><span class="line"><span class="number">20</span>:</span><br><span class="line"><span class="number">21</span>:     <span class="comment">/**</span></span><br><span class="line"><span class="comment">22:      * 当前为演示框架组件，每次都返回一个字符的Token，实际不是这样的，后面章节会改。&lt;br&gt;</span></span><br><span class="line"><span class="comment">23:      * 但是吞噬原理是一样的，每当Token构成完之后，都把位置游标前移一步。</span></span><br><span class="line"><span class="comment">24:      * @throws Exception</span></span><br><span class="line"><span class="comment">25:      */</span></span><br><span class="line"><span class="number">26</span>:     <span class="keyword">protected</span> <span class="keyword">void</span> extract()</span><br><span class="line"><span class="number">27</span>:         <span class="keyword">throws</span> Exception</span><br><span class="line"><span class="number">28</span>:     &#123;</span><br><span class="line"><span class="number">29</span>:         text = Character.toString(currentChar());</span><br><span class="line"><span class="number">30</span>:         value = <span class="keyword">null</span>;</span><br><span class="line"><span class="number">31</span>:         <span class="comment">//吞噬&amp;前进</span></span><br><span class="line"><span class="number">32</span>:         nextChar();</span><br><span class="line"><span class="number">33</span>:     &#125;</span><br><span class="line"><span class="number">34</span>:</span><br><span class="line"><span class="number">35</span>:     <span class="keyword">protected</span> <span class="keyword">char</span> currentChar()</span><br><span class="line"><span class="number">36</span>:         <span class="keyword">throws</span> Exception</span><br><span class="line"><span class="number">37</span>:     &#123;</span><br><span class="line"><span class="number">38</span>:         <span class="keyword">return</span> <span class="keyword">source</span>.currentChar();</span><br><span class="line"><span class="number">39</span>:     &#125;</span><br><span class="line"><span class="number">40</span>:</span><br><span class="line"><span class="number">41</span>:     <span class="keyword">protected</span> <span class="keyword">char</span> nextChar()</span><br><span class="line"><span class="number">42</span>:         <span class="keyword">throws</span> Exception</span><br><span class="line"><span class="number">43</span>:     &#123;</span><br><span class="line"><span class="number">44</span>:         <span class="keyword">return</span> <span class="keyword">source</span>.nextChar();</span><br><span class="line"><span class="number">45</span>:     &#125;</span><br><span class="line"><span class="number">46</span>:</span><br><span class="line"><span class="number">47</span>:     <span class="keyword">protected</span> <span class="keyword">char</span> peekChar()</span><br><span class="line"><span class="number">48</span>:         <span class="keyword">throws</span> Exception</span><br><span class="line"><span class="number">49</span>:     &#123;</span><br><span class="line"><span class="number">50</span>:         <span class="keyword">return</span> <span class="keyword">source</span>.peekChar();</span><br><span class="line"><span class="number">51</span>:     &#125;</span><br><span class="line"><span class="number">52</span>: &#125;</span><br></pre></td></tr></table></figure></p><p>根据概念设计，scanner构造出token然后把它们交给parser。因为TokenType是一个接口，你能设置Token的类型<code>(域type)</code>为一个语言相关的值。下章将会演示scanner如何根据当前字符<code>（源文件中）</code>，也就是token的首字符，判定要构造的下一个Token的类型。例如，如果首字符为数字，则下一个token为number类型；如果为字母，则下一个token可以是标识符(ID)或关键字，因为你用不同Token子类来表示不同Token类型，scanner将会根据首字符调用Token子类相应的构造函数。</p><p>构造函数调用extract()方法去实际构造一个Token。方法(<strong>extract</strong>)名意味着此方法将会从source中读取字符来抽取token。Token子类根据语言相关的token类型逻辑实现extract方法。Token类提供了一个默认的单字符Token实现。除少数情况，extract()实现会吞噬token字符，而把行的当前位置到Token尾字符的下一个位置<code>（假设when i &lt; k 抽取到Token when，那么首字符为w，尾字符为n，则当前行位置会定位到 i，因为一般空格会被忽略）</code>。<br>调用extract方法之前，构造函数设置token文本所在行和首字符行中位置。比如关键字BEGIN的文本串可为”begin”<code>（Pascal大小写不敏感）</code>，如果文本begin在第11到15位置，那么首字符位置为11，在extract方法返回后，当前位置为16。<code>(15的下一个）</code></p><p>有些Token有值<code>（一般为常量Token)</code>。比如一个数字token的文本是”3.14159”则值与Pi近似。</p><p>跟Scanner类一样，Token类同样是调用source对象响应方法，实现了currentChar()和nextChar()和peekChar()。</p><p>清单2-5 展示了TokenType标记接口。语言相关的Token类型将会用到实现接口。<code>（标记接口不定义任何方法，它主要用来标识实现了此接口的类。比如所有实现了TokeType接口被认为是Token类型，这在JDK中就有，比如有名的java.io.Serializable类)</code></p><p>清单2-5：TokenType接口<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">1: package wci.frontend;</span></span><br><span class="line"><span class="section">2:</span></span><br><span class="line"><span class="section">3: /**</span></span><br><span class="line"><span class="section">4:  * &lt;p&gt;Token类型，此章没有任何具体类型实现，仅仅是个为演示框架的占位类&lt;/p&gt;</span></span><br><span class="line"><span class="section">5:  */</span></span><br><span class="line"><span class="section">6: public interface TokenType</span></span><br><span class="line"><span class="section">7: &#123;</span></span><br><span class="line"><span class="section">8: &#125;</span></span><br></pre></td></tr></table></figure></p><p>清单2-6 暂时了语言无关的EofToken子类。因为它仅仅表示文件结束，所以覆盖extract方法后啥事都没干。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span>: <span class="keyword">package</span> wci.frontend;</span><br><span class="line"> <span class="number">2</span>:</span><br><span class="line"> <span class="number">3</span>: <span class="comment">/**</span></span><br><span class="line"><span class="comment"> 4:  * &lt;p&gt;表示文件结束的特殊Token&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> 5:  */</span></span><br><span class="line"> <span class="number">6</span>: public <span class="class"><span class="keyword">class</span> <span class="title">EofToken</span> <span class="keyword">extends</span> <span class="title">Token</span></span></span><br><span class="line"><span class="class"> 7</span>: &#123;</span><br><span class="line"> <span class="number">8</span>:     public <span class="type">EofToken</span>(<span class="type">Source</span> source)</span><br><span class="line"> <span class="number">9</span>:         <span class="keyword">throws</span> <span class="type">Exception</span></span><br><span class="line"><span class="number">10</span>:     &#123;</span><br><span class="line"><span class="number">11</span>:         <span class="keyword">super</span>(source);</span><br><span class="line"><span class="number">12</span>:     &#125;</span><br><span class="line"><span class="number">13</span>:     <span class="keyword">protected</span> void extract(<span class="type">Source</span> source)</span><br><span class="line"><span class="number">14</span>:         <span class="keyword">throws</span> <span class="type">Exception</span></span><br><span class="line"><span class="number">15</span>:     &#123;</span><br><span class="line"><span class="number">16</span>:     &#125;</span><br><span class="line"><span class="number">17</span>: &#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本章将会从前一章的概念设计带你到初级的实现过程。你将先为编译器和解释器构造一个灵活的框架，接着将初级版的编译器解释器组件集成到框架中。最后编写端对端的测试用例检验这些框架和组件。&lt;br&gt;&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="编译器和解释器" scheme="http://suprisemf.github.io/categories/%E7%BC%96%E8%AF%91%E5%99%A8%E5%92%8C%E8%A7%A3%E9%87%8A%E5%99%A8/"/>
    
    
      <category term="Java" scheme="http://suprisemf.github.io/tags/Java/"/>
    
      <category term="编译器" scheme="http://suprisemf.github.io/tags/%E7%BC%96%E8%AF%91%E5%99%A8/"/>
    
      <category term="解释器" scheme="http://suprisemf.github.io/tags/%E8%A7%A3%E9%87%8A%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>（基于Java）编写编译器和解释器-第一章：介绍-Part-2</title>
    <link href="http://suprisemf.github.io/2018/07/18/%E7%BC%96%E8%AF%91%E5%99%A8%E7%AC%AC%E4%B8%80%E7%AB%A0Part2/"/>
    <id>http://suprisemf.github.io/2018/07/18/编译器第一章Part2/</id>
    <published>2018-07-18T11:57:13.000Z</published>
    <updated>2018-07-18T13:06:12.282Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么学习编译器编写技术？"><a href="#为什么学习编译器编写技术？" class="headerlink" title="为什么学习编译器编写技术？"></a>为什么学习编译器编写技术？</h2><p>我们都想当然的认为对编译器和解释器学习了个大概，因为你在开发中需要聚焦在编写和调试程序上，你甚至不需要思考编译器的工作机制。<a id="more"></a><br>你或许仅仅在搞错语法编译器抛出错误信息后才留意到编译器的存在。如果没有语法错误，那么编译将会生成正确的代码无疑。如果你的程序运行失常，你有可能怪罪编译器，但大多时候，你会发现错误在你的程序中。</p><p>以上情形通常会出现在你在使用某个流行编程语言<code>(比如Java或C++)</code>它的编译器、解释器和IDE都给你准备好了的时候。这先聊到这。</p><p>不过最近我们看到很多新编程语言在被开发。驱动力包括www<code>(比如HTML5）</code>和与基于web的应用相适应的新语言（典型比如PHP，纯web）。对程序员生产力的更高要求催生与具体应用领域紧密结合的新语言<code>（这个可以举很多例子，比如为系统管理员的各种Shell语言，为数据库开发的各种SQL/NO SQL语言，为电路板/DSP开发的类VHDL语言等，为工作流开发的各种BPM语言等）</code>。你可能非常期待自己有天能发明个新脚本语言表达算法或控制与你领域相关的流程。如果你要发明新语言，对应的编译器和解释器必不可少。</p><p>编译器和解释器本身很好玩，但你前面注意到了，任何一个都不是个小程序，要开发成功相关的技能，现代软件工程法则和良好的OO设计思想必不可少。除了学习编译器解释器工作机制带来的满足感外，你也要笑着面对编写它们带来的挑战。</p><h2 id="概念设计"><a href="#概念设计" class="headerlink" title="概念设计"></a>概念设计</h2><p>为接下几章做准备，让我们重温编译器和解释器的概念设计</p><blockquote><p><strong>设计笔记</strong>：程序的概念设计是它的软件架构的一个高级视图。概念设计包含程序的主要组件，它们怎么组织，相互之间的交互细节等。它不需要说明组件怎么实现，更确切的说，它可让你先确认和理解组件而无需担心最终怎么去开发它们。</p></blockquote><p>你可将编译器和解释器归为程序语言翻译器。如前面解释的那样，编译器将源程序翻译成机器语言而解释器将之翻译成系列动作(<strong>Action</strong>)。站在最高角度看翻译器，它包含一个前端(<strong>front end</strong>)和一个后端(<strong>back end</strong>)。遵从软件重用法则，你将看到Pascal编译器和Pascal解释器共享前端，但有不同的后端。</p><p>翻译器的前端读入源程序然后执行最初的翻译过程。它的主要组件有parser, scanner<code>(更学院派的说法是Lexer即词法分析器)</code>，token<code>（最小语言单位，最大词法单元)</code>和source<code>（表示源代码)</code></p><p>paser控制前端的翻译过程。它不断的从scanner读入token，根据token串<code>（就是token模式)</code>判定当前正翻译的高阶语言元素，比如算术表达式，赋值语句，过程申明等。parser检验源程序的语法是否正确。paser干的事情称之为解析(<strong>parsing</strong>)，parser分析源程序然后将之转换。<code>（转换成啥？后面会有，一般为抽象语法树之类的中间层）</code></p><p>scanner一个接一个字符读入源程序的内容，然后构造tokens即源语言的低阶元素。例如Pascal tokens包含关键字如BEGIN、END、IF、THEN和ELSE，标识符即变量、过程、函数名称<code>(identifier，又称ID)</code>以及特殊符号如= := + - *和/ 。scanner干的事情称为扫描(<strong>scanning</strong>)。scanner扫描源程序，将之分成一个个token。</p><p>下图展示了编译器和解释器前端的概念设计：</p><p><img src="/2018/07/18/编译器第一章Part2/1-2.png" alt="图1.2"></p><p>此图中，箭头表示一个组件给另外一个发送命令。parser告诉scanner要下一个token。scanner从source中获取字符然后构造新的token。token 也从source中读入字符。<code>(13章会讲到为何scanner和token组件都需要从source中读取字符)</code></p><p>编译器最终将源程序翻译成机器语言目标代码，所以后端的一个重要组件是代码生成器(目标代码生成器 code generator)。解释器执行程序，所以其后端的首要组件是执行器(<strong>executor</strong>)。</p><p>如果你想让编译器和解释器共享前端，那么它们不同的后端需要有个通用接口用来与前端打交道（也就是只需要将前端传入这个接口即可)。记住前端处理最初的翻译过程。前端生成作为公共接口中间层的中间代码(<strong>intermediate code，分析树/语法树，抽象语法树等</strong>)和符号表(<strong>symbol table</strong>)。</p><p>中间码(<strong>intermediate code</strong>)是源程序的预摘要格式<code>(pre-digested，可以理解为在源程序格式和机器语言格式中间的一个摘要格式，一般为分析树parse tree或语法树syntax tree)</code>为方便后端的更有效处理<code>（假设翻译器将塑料翻译成为瓶子，那么源程序为塑料，中间码为瓶盖，瓶身，包装纸，这样后端就能更快的装瓶子)</code>。本书中的中间码是一个驻内存表示源程序语句的树状数据结构<code>(也就是语法树，废话一堆啊)</code>。符号表包含源程序的符号信息(比如标识符)。编译器的后端处理中间码和符号表，生成源程序对应的机器语言。解释器碰到中间码和符号表就直接执行了<code>（通常是树遍历过程)</code>。</p><p>为软件重用，你可将中间码和符号表设计成语言无关的结构。换句话说，你可用同样的结构应用于不同的源语言。因此，后端同样可以语言无关，当它处理这些结构<code>（中间码和符号表）</code>是根本不需要知道具体源语言。</p><p>下图展示了一个更为复杂的编译器和解释器的概念设计。如果你万事安好，仅需前端知道源语言定义且仅需后端知道区分编译器和解释器。</p><p><img src="/2018/07/18/编译器第一章Part2/1-3.png" alt="图1.3"></p><p>第2章开始通过设计一个编译器解释器框架来充实概念设计。第3章讲的是扫描(<strong>scanning</strong>)。第4章构建第一个符号表，第五章生成最初的中间码。第6章开始编写执行器(<strong>executor</strong>)且增量式开发直到14章，其中包含符号调试器和IDE。代码生成直到在15章学了了JVM架构之后的16章才涉及。</p><h2 id="语法和语义-syntax-and-semantics"><a href="#语法和语义-syntax-and-semantics" class="headerlink" title="语法和语义(syntax and semantics)"></a>语法和语义(syntax and semantics)</h2><p>编程语言的语法是一系列规则用来断定用此语言写的语句或表达式是否正确。语言的语义传达语句和表达式的具体意思<code>（赋值谁赋给谁，循环终止条件是什么）</code>。举个例子，Pascal的语法告诉我们 i := j+k 是一个有效的赋值语句。它的语义是说将变量j 和k的当前值加起来，然后将和赋给 i。</p><p>parser基于源语言的语法和语义执行有关动作。扫描源程序抽取tokens是语法动作。查找赋值语句 := 之后的目标变量是语法动作。将标识符(<strong>identifiers</strong>) i、j、k当作变量存入符号表或日后在符号表中查找是语义动作，因为parser必须明白当前表达式和赋值的意思才知道得用到符号表。生成代表此赋值语句的中间码属于语义动作。</p><p>语法动作尽在前端发生，语义动作在前后端都有。在后端执行程序或者生成目标代码需要知道语句的具体意思，所以是语义动作一部分。中间码和符号表存储语义信息。</p><h2 id="词法，语法和语义分析"><a href="#词法，语法和语义分析" class="headerlink" title="词法，语法和语义分析"></a>词法，语法和语义分析</h2><p>词法分析是扫描(<strong>scanning</strong>)的正式说法，所以scanner也称词法分析器(<strong>lexical analyzer</strong>)。语法分析是parsing<code>(解析，parser的主要任务)</code>的正式称谓，语法分析器就是parser。语义分析主要是检查语义规则是否完整。类型检查(<strong>type checking</strong>)就是一例，它确保操作符(<strong>operator</strong>)的操作数(<strong>operand</strong>)类型保持一致。其它的语义分析操作有构造符号表和生成中间码。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;为什么学习编译器编写技术？&quot;&gt;&lt;a href=&quot;#为什么学习编译器编写技术？&quot; class=&quot;headerlink&quot; title=&quot;为什么学习编译器编写技术？&quot;&gt;&lt;/a&gt;为什么学习编译器编写技术？&lt;/h2&gt;&lt;p&gt;我们都想当然的认为对编译器和解释器学习了个大概，因为你在开发中需要聚焦在编写和调试程序上，你甚至不需要思考编译器的工作机制。&lt;/p&gt;
    
    </summary>
    
      <category term="编译器和解释器" scheme="http://suprisemf.github.io/categories/%E7%BC%96%E8%AF%91%E5%99%A8%E5%92%8C%E8%A7%A3%E9%87%8A%E5%99%A8/"/>
    
    
      <category term="Java" scheme="http://suprisemf.github.io/tags/Java/"/>
    
      <category term="编译器" scheme="http://suprisemf.github.io/tags/%E7%BC%96%E8%AF%91%E5%99%A8/"/>
    
      <category term="解释器" scheme="http://suprisemf.github.io/tags/%E8%A7%A3%E9%87%8A%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>（基于Java）编写编译器和解释器-第一章：介绍-Part-1</title>
    <link href="http://suprisemf.github.io/2018/07/18/%E7%BC%96%E8%AF%91%E5%99%A8%E7%AC%AC%E4%B8%80%E7%AB%A0/"/>
    <id>http://suprisemf.github.io/2018/07/18/编译器第一章/</id>
    <published>2018-07-18T10:08:43.000Z</published>
    <updated>2018-07-18T11:52:47.229Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本章描述了本书的目标和用到的方法并鸟瞰编译器和解释器的全貌。</p></blockquote><h2 id="目标和方法"><a href="#目标和方法" class="headerlink" title="目标和方法"></a>目标和方法</h2><p>本书讲授编译器和解释器的基本写法，目标是呈现给你怎样设计和开发它们：</p><a id="more"></a><ul><li>用Java写的编译器，编译Pascal(一个高级的面向过程的编程语言)的一个主要子集。<code>(即包含主要的语言特征，但去掉一些为写编译器方便而去掉的无关大雅的特性。)</code></li><li>用Java写的解释器且包含一个交互式的符号调试器<code>(符号调试器即基于符号表，而不是基于机器的指令集、硬件的调试功能)</code>，解释同样的Pascal语言子集。</li><li>带图形用户界面的集成开发环境(IDE)。这个IDE是你看到的功能全面的开源的Eclipse或者Borland的JBuilder等IDE的一个简化版。不过，它也包含一个源程序编辑器和一个交互界面用来设置断点，单步调试，查看和修改变量值等等其它。</li></ul><p>达成这些个极具野心的目标是个大挑战。好的技能将会帮你如何如把程序编译成为机器语言或解释执行程序。现代软件工程法则和优秀的面向对象设计思想将会给你呈现怎么通过代码实现一个编译器或解释器而最终所有组件能良好协作。编译器和解释器程序大且复杂。开发个小程序仅需要某种技能即可，然NB的程序如编译器或解释器还需要软件工程法则和面向对象设计。因此本书强调必备技能，软件工程法则和面向对象思想。</p><h2 id="什么是编译器和解释器"><a href="#什么是编译器和解释器" class="headerlink" title="什么是编译器和解释器"></a>什么是编译器和解释器</h2><p>编译器和解释器的主要目的是“翻译”由高阶(High-Level)源语言写的源程序。把源程序翻译成什么样是接下几个段落的主题。</p><p>本书中源语言为Pascal的一个大子集，换句话说，你能够编译或解释正规的Pascal程序。因为编译器和解释器是用Java写的，实现语言是Java。</p><p>Pascal编译器将Pascal源程序翻译成为低阶(Low-Level)的某具体机器的机器语言<code>（更准确的讲是CPU的机器语言)</code>。通常源程序是文本格式。如果编译器工作正常，对应的机器语言和最初的Pascal源程序殊路同归<code>（一样的行为，只不过呈现方式不一样。比如你用钥匙而偷车的直接电线打火发动汽车一样）</code>。机器语言是目标语言，编译器生成用机器语言组成目标代码。代码生成之后，编译器任务就算完成。目标代码一般写到文件里<code>（一般是二进制文件）</code>。</p><p>一个程序可包含数个源文件，而编译器为每个文件生成一个目标文件。一个名叫“链接器”(linker)的辅助程序将这些目标文件的内容连同运行时库程序合成到一个计算机能够加载和执行的目标程序<code>(如windows的PE程序)</code>中。库程序一般来自于预先编译好的目标文件。</p><p>因为机器语言不好记，编译器可生成汇编语言作为目标语言，汇编语言离机器语言只有一步之遥。通常每个汇编指令都有机器语言的指令与之对应。如果你掌握了短助记名<code>（比如ADD和MOV等）</code>汇编语言好记多了。汇编器<code>（另一个编译器）</code>将汇编语言翻译成为机器语言。</p><p>下图概括了将一个或多个源程序编译成为目标程序的过程。</p><p><img src="/2018/07/18/编译器第一章/1-1.png" alt="图1"></p><p>上图展示了将一个包含三个源文件sort1.pas、sort2.pas、sort3.pas的Pascal程序翻译成为三个相应机器语言目标文件sort1.obj、sort2.obj、sort3.obj。链接器将三个目标文件<code>（连带相关运行时库)</code> 合成为一个可执行的目标程序sort.exe。图右边展示了编译器将Pascal源文件翻译为汇编语言目标文件sort1.asm、sort2.asm、sort3.asm，接着汇编器将其转化为机器语言目标文件。最后链接器产生目标程序sort.exe。</p><h4 id="那么编译器和解释器到底有和不同？"><a href="#那么编译器和解释器到底有和不同？" class="headerlink" title="那么编译器和解释器到底有和不同？"></a>那么编译器和解释器到底有和不同？</h4><p>解释器不生成任何目标程序，相反它读进源程序就会执行。这好比你被一个Pascal程序把住手，按照它说的某种语句读进顺序去做。你可以在一张草稿纸上记下程序的变量值直到程序结束才输出每条语句的输出结果。本质上你做的正是Pascal解释器干的事情。Pascal解释器读进程序，执行程序。没有任何目标程序需要生成和加载，相反，解释器将程序翻译成为一系列用来执行程序的动作(Action)。</p><h2 id="比较编译器和解释器"><a href="#比较编译器和解释器" class="headerlink" title="比较编译器和解释器"></a>比较编译器和解释器</h2><h4 id="该如何决策何时用编译器和何时用解释器？"><a href="#该如何决策何时用编译器和何时用解释器？" class="headerlink" title="该如何决策何时用编译器和何时用解释器？"></a>该如何决策何时用编译器和何时用解释器？</h4><p>当你把一个源程序交给解释器，解释器接管检查和执行。编译器也检查但生成目标代码。运行完编译器之后还有运行链接器产生目标程序，且还需加载目标程序到内存中去执行它。如果编译器生成汇编语言代码，你还得运行汇编器。所以很显然解释器需要更少步骤。<br>解释器比编译器更常见。你可用Java写个Pascal解释器运行在基于微软Windows的PC上，苹果的MAC或某个Linux主机上，解释器能够在前面提到的平台上执行Pascal程序。而编译器必须为某个具体的机器生成代码<code>（无论直接生成或间接通过汇编器生成)</code>。所以即使你要把原来为PC写的Pascal编译器放到MAC上运行，它生成的代码仍旧是PC的，如果想让它为MAC生成代码，你可能得重写编译器的某些部分。</p><blockquote><p>接下来讨论的编译器将问题的重心放在为Java虚拟机生成代码上，因为虚拟机能够运行在很多平台上。所以为具体机器生成代码先放一边，有兴趣可以将虚拟机替换成为真实PC机上生成x86指令看看。</p></blockquote><h4 id="如果源程序中包含逻辑错误，比如除值为0的变量，直到运行时才发现，那么会发生什么情况？"><a href="#如果源程序中包含逻辑错误，比如除值为0的变量，直到运行时才发现，那么会发生什么情况？" class="headerlink" title="如果源程序中包含逻辑错误，比如除值为0的变量，直到运行时才发现，那么会发生什么情况？"></a>如果源程序中包含逻辑错误，比如除值为0的变量，直到运行时才发现，那么会发生什么情况？</h4><p>因为解释器在执行程序过程中控制一切，它能停下来告诉你出问题的行数和变量名称。它甚至能提示你在继续执行程序之前可以做哪些正确操作比如修改变量值为非零。解释器可包含一个交互式的源级<code>(source-level)</code>调试器，俗称符号调试器<code>(symbolic debugger)</code>。符号调试器意味着你可用程序中的符号，比如变量名。<br>另一方面，由编译器和链接器产生的目标程序通常自我运行<code>（由机器执行，无需第三方）</code>。源程序有关行号和变量名等信息在目标程序中不可见。当运行时抛错，程序简单中断，还可能打印一条包含出问题指令地址的消息。于是找出源程序中相关语句变量除零的问题就交给你了。</p><p>所以通常就调试来说，解释器才是正道。有些编译器在目标代码中添加一些额外的信息，这样当错我发生时，目标程序能打印出相应的问题行数和变量名等。于是你改正错误，重新编译，然后重新运行。生成额外的信息会导致程序执行的比正常要慢<code>（这也是Visual C++为什么有Run/Debug编译模式）</code>。这提示你在认为程序到达最终“产品”版本后，应关掉调试特征重新编译。</p><p>假设你已经成功调试好程序，那重点将是怎样使运行更快。因为机器能够以最快速度执行原生机器语言程序，编译程序能够比解释器快好几个量级。显然就速来来说编译器是胜者，当优化版编译器知道怎么生成具体场景的优化代码的情况下尤其确定。所以是否使用编译器或解释器取决于程序的开发和执行谁更重要。理想情况是一个带符号源级调试器的解释器用在开发过程中，一个生成机器代码的编译器在程序调试OK之后以求更快的执行速度。这些就是本书的目标，因为它编译器，解释器都教。</p><h2 id="情景变得有点模糊"><a href="#情景变得有点模糊" class="headerlink" title="情景变得有点模糊"></a>情景变得有点模糊</h2><p>编译器和解释器的差异很容易说明清楚，但是随着虚拟机的快速流行，情景变得有点模糊。</p><p>虚拟机是一个用来模拟机器<code>（计算机）</code>的程序。此程序能够运行在不同的真实计算机平台上。举个例子，Java 虚拟机(JVM)能够运行在基于微软Windows的PC上，苹果的MAC，Linux系统和其它很多平台上。<code>（比如Sparc，IBM小型机等）</code>。</p><p>虚拟机有自己的虚拟机器语言，而虚拟语言指令被真实宿主机所解释。那么如果你写了一个翻译器将Pascal源程序翻译成为被宿主机解释的虚拟机语言，这个翻译器算编译器还是解释器？</p><p>不斤斤计较了，我们本书约定如果一个翻译器将源程序转化成为机器语言，不管是真实的机器语言还是虚拟机器语言，那么这个翻译器就是编译器。翻译器没有优先生成机器语言去执行程序的就算解释器。</p><blockquote><p>声明：本文转载自博客园Bang老师，为英版原书《Writing Compilers and Interpreters 3rd Edition》译文。转载只为学习。<a href="https://www.cnblogs.com/lifesting/archive/2012/07/11/2585860.html" target="_blank" rel="noopener">博客地址</a><br>至今与Bang老师联系不上，译文阅读量极低，故为扩大该译文的影响力，笔者擅自转载。由于Bang老师只译到第十一章，但最后的九个章节笔者会自己翻译。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本章描述了本书的目标和用到的方法并鸟瞰编译器和解释器的全貌。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;目标和方法&quot;&gt;&lt;a href=&quot;#目标和方法&quot; class=&quot;headerlink&quot; title=&quot;目标和方法&quot;&gt;&lt;/a&gt;目标和方法&lt;/h2&gt;&lt;p&gt;本书讲授编译器和解释器的基本写法，目标是呈现给你怎样设计和开发它们：&lt;/p&gt;
    
    </summary>
    
      <category term="编译器和解释器" scheme="http://suprisemf.github.io/categories/%E7%BC%96%E8%AF%91%E5%99%A8%E5%92%8C%E8%A7%A3%E9%87%8A%E5%99%A8/"/>
    
    
      <category term="Java" scheme="http://suprisemf.github.io/tags/Java/"/>
    
      <category term="编译器" scheme="http://suprisemf.github.io/tags/%E7%BC%96%E8%AF%91%E5%99%A8/"/>
    
      <category term="解释器" scheme="http://suprisemf.github.io/tags/%E8%A7%A3%E9%87%8A%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>（基于Java）编写编译器和解释器：书的组织结构</title>
    <link href="http://suprisemf.github.io/2018/07/09/%E7%AC%AC%E4%B8%80%E7%AB%A0%E7%BB%84%E6%88%90/"/>
    <id>http://suprisemf.github.io/2018/07/09/第一章组成/</id>
    <published>2018-07-09T14:45:50.000Z</published>
    <updated>2018-07-18T10:11:24.103Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>该书共有19章，加上最后的名词索引表部分</p></blockquote><h3 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h3><p>该章是一个总体介绍。<br><a id="more"></a></p><h3 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h3><p>该章描述组织该编译器和解释器的总体框架。它用来设计和测试它的结构化建立端，以便于所有章节的代码都能成功地基于它建立起来。</p><h3 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h3><h3 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h3><p>第三章和第四章来对付处理一些基础的翻译任务，即第三章来扫描源程序，第四章建立一个符号表。</p><blockquote><p>接下来的章节来建立工作的Pascal解释器。为使用逐渐增加的发展方法，本书采用个个章节进行多次迭代的语法分析和解释。</p></blockquote><h3 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h3><p>该章来语法分析表达式和赋值语句。</p><h3 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h3><p>该章将第五章的部分进行解释。</p><h3 id="第七章"><a href="#第七章" class="headerlink" title="第七章"></a>第七章</h3><p>该章语法分析控制语句。</p><h3 id="第八章"><a href="#第八章" class="headerlink" title="第八章"></a>第八章</h3><p>该章来解释第七章的部分。</p><h3 id="第九章"><a href="#第九章" class="headerlink" title="第九章"></a>第九章</h3><p>该章来语法分析声明语句。</p><h3 id="第十章"><a href="#第十章" class="headerlink" title="第十章"></a>第十章</h3><p>该章来处理类型检查。</p><h3 id="第十一章"><a href="#第十一章" class="headerlink" title="第十一章"></a>第十一章</h3><p>该章来语法分析过程语句、方法部分和整个Pascal程序。</p><h3 id="第十二章"><a href="#第十二章" class="headerlink" title="第十二章"></a>第十二章</h3><p>该章完成解释器并执行整个Pascal程序。</p><blockquote><p>接下来的两章会基于工作的解释器来建立。当你是第一次读该书的话，你可以选择跳过接下来的两章节，但是一定要确定来回头好好看一下，毕竟它对你还是很有帮助的。</p></blockquote><h3 id="第十三章"><a href="#第十三章" class="headerlink" title="第十三章"></a>第十三章</h3><p>该章增加了一个交互式的源级别的debugger，通过它你可以通过在命令行敲打命令来跟它进行交流。</p><h3 id="第十四章"><a href="#第十四章" class="headerlink" title="第十四章"></a>第十四章</h3><p>该章为这个基于命令行的debugger包装了一个图形交互页面来建一个集成开发环境IDE。</p><blockquote><p>该书的最后部分通过重用早些章节的代码来形成这个编译器。</p></blockquote><h3 id="第十五章"><a href="#第十五章" class="headerlink" title="第十五章"></a>第十五章</h3><p>该章介绍了Java虚拟机（JVM）和Jasmin的构造结构，其中Jasmin是一个帮助java虚拟机生成汇编语言的工具。</p><h3 id="第十六章"><a href="#第十六章" class="headerlink" title="第十六章"></a>第十六章</h3><p>该章编译程序、赋值语句和表达式。（迭代早些章节的实现）</p><h3 id="第十七章"><a href="#第十七章" class="headerlink" title="第十七章"></a>第十七章</h3><p>该章编译过程部分、方法部分回调，和string的操作。</p><h3 id="第十八章"><a href="#第十八章" class="headerlink" title="第十八章"></a>第十八章</h3><p>该章通过编译控制语句、arrays和记录来完成这个编译器。</p><h3 id="第十九章"><a href="#第十九章" class="headerlink" title="第十九章"></a>第十九章</h3><p>该最后一章是一个对许多对于编写编译器方面但没有在其他章节中提及到简短的介绍，例如代码优化和基于表格驱动的源码扫描器和语法分析器。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;该书共有19章，加上最后的名词索引表部分&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;第一章&quot;&gt;&lt;a href=&quot;#第一章&quot; class=&quot;headerlink&quot; title=&quot;第一章&quot;&gt;&lt;/a&gt;第一章&lt;/h3&gt;&lt;p&gt;该章是一个总体介绍。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="编译器和解释器" scheme="http://suprisemf.github.io/categories/%E7%BC%96%E8%AF%91%E5%99%A8%E5%92%8C%E8%A7%A3%E9%87%8A%E5%99%A8/"/>
    
    
      <category term="Java" scheme="http://suprisemf.github.io/tags/Java/"/>
    
      <category term="编译器" scheme="http://suprisemf.github.io/tags/%E7%BC%96%E8%AF%91%E5%99%A8/"/>
    
      <category term="解释器" scheme="http://suprisemf.github.io/tags/%E8%A7%A3%E9%87%8A%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>（基于Java）编写编译器和解释器-第一章：介绍之前</title>
    <link href="http://suprisemf.github.io/2018/07/09/%E7%AC%AC%E4%B8%80%E7%AB%A0/"/>
    <id>http://suprisemf.github.io/2018/07/09/第一章/</id>
    <published>2018-07-09T14:12:52.000Z</published>
    <updated>2018-07-10T03:08:11.673Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于翻译《Writing-Compilers-and-Interpreters-3rd-Edition》书籍"><a href="#关于翻译《Writing-Compilers-and-Interpreters-3rd-Edition》书籍" class="headerlink" title="关于翻译《Writing Compilers and Interpreters 3rd Edition》书籍"></a>关于翻译《Writing Compilers and Interpreters 3rd Edition》书籍</h2><h3 id="翻译这本书的想法"><a href="#翻译这本书的想法" class="headerlink" title="翻译这本书的想法"></a>翻译这本书的想法</h3><blockquote><p>这学期在学完《编译原理》这门课程之后，我是深深地被编译器的实现迷住了。。。<br><a id="more"></a><br>本学期的《编译原理课程设计》中最后用C++实现了一个小编译器，但是其中很大部分是借用该书的讲解实现，而且是C++语言。在Google、百度之后，千挑万选发现了这本很有名的但是并不为多数人了解的书（大家都不是特别关心编译器的实现）。</p></blockquote><p>相对于号称编译原理界的“三大圣书”：龙书——《编译原理技术和工具》-作者:Alfred V.Aho,Ravi Sethi,Jeffrey D.Ullman 、虎书——《现代编译原理-C语言描述》-作者：Andrew W.Appel,with Jens Palsberg 、鲸书——《高级编译器设计与实现》-作者：Steven S.Muchnick<br>“三大圣书”详情请访问<a href="https://www.cnblogs.com/Amedeo/archive/2017/11/24/7881889.html" target="_blank" rel="noopener">参考链接</a></p><p>但是，这本书是基于java，而且有更加详实完善的代码讲解，该书作者也是大名鼎鼎的Ronald Mak,其前两版讲解编译器的是使用的C/C++，加上目前该书目前没有英文版，故此笔者决定擅自翻译该书。</p><blockquote><p>笔者英语水平目前较差，仅是英语六级水平，但是为了读者理解，并尽量保证翻译质量，笔者会用心做好的。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;关于翻译《Writing-Compilers-and-Interpreters-3rd-Edition》书籍&quot;&gt;&lt;a href=&quot;#关于翻译《Writing-Compilers-and-Interpreters-3rd-Edition》书籍&quot; class=&quot;headerlink&quot; title=&quot;关于翻译《Writing Compilers and Interpreters 3rd Edition》书籍&quot;&gt;&lt;/a&gt;关于翻译《Writing Compilers and Interpreters 3rd Edition》书籍&lt;/h2&gt;&lt;h3 id=&quot;翻译这本书的想法&quot;&gt;&lt;a href=&quot;#翻译这本书的想法&quot; class=&quot;headerlink&quot; title=&quot;翻译这本书的想法&quot;&gt;&lt;/a&gt;翻译这本书的想法&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;这学期在学完《编译原理》这门课程之后，我是深深地被编译器的实现迷住了。。。&lt;br&gt;&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="编译器和解释器" scheme="http://suprisemf.github.io/categories/%E7%BC%96%E8%AF%91%E5%99%A8%E5%92%8C%E8%A7%A3%E9%87%8A%E5%99%A8/"/>
    
    
      <category term="Java" scheme="http://suprisemf.github.io/tags/Java/"/>
    
      <category term="编译器" scheme="http://suprisemf.github.io/tags/%E7%BC%96%E8%AF%91%E5%99%A8/"/>
    
      <category term="解释器" scheme="http://suprisemf.github.io/tags/%E8%A7%A3%E9%87%8A%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>全新博客界面</title>
    <link href="http://suprisemf.github.io/2018/07/08/blogUItry/"/>
    <id>http://suprisemf.github.io/2018/07/08/blogUItry/</id>
    <published>2018-07-08T09:23:10.000Z</published>
    <updated>2018-07-08T12:08:11.378Z</updated>
    
    <content type="html"><![CDATA[<h2 id="博客界面更新换代啦"><a href="#博客界面更新换代啦" class="headerlink" title="博客界面更新换代啦"></a>博客界面更新换代啦</h2><p><img src="/2018/07/08/blogUItry/星球.jpg" alt="ls"></p><blockquote><p>之前的那个界面是使用的jelly之中的一个界面，但是介于个人习惯，我今天还是决定换上大名鼎鼎的NexT，果然现在到底界面更加简洁清晰，加载博客速度也上来了。</p></blockquote><p>欢迎关注我的微信公众号：【星球码】，一起学习分享java、python、操作系统、编译器等知识。</p><p>作者：SupriseMF<br>日期：July,8th,2018</p>]]></content>
    
    <summary type="html">
    
      今天换一个全新的博客界面。
    
    </summary>
    
      <category term="Hexo使用" scheme="http://suprisemf.github.io/categories/Hexo%E4%BD%BF%E7%94%A8/"/>
    
    
      <category term="hello" scheme="http://suprisemf.github.io/tags/hello/"/>
    
      <category term="world" scheme="http://suprisemf.github.io/tags/world/"/>
    
  </entry>
  
  <entry>
    <title>Test2</title>
    <link href="http://suprisemf.github.io/2018/07/06/test2/"/>
    <id>http://suprisemf.github.io/2018/07/06/test2/</id>
    <published>2018-07-06T07:31:55.000Z</published>
    <updated>2018-07-08T11:50:40.990Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2018/07/06/test2/实现.png" alt="ls"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/2018/07/06/test2/实现.png&quot; alt=&quot;ls&quot;&gt;&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="test for picturres in static blog" scheme="http://suprisemf.github.io/tags/test-for-picturres-in-static-blog/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://suprisemf.github.io/2018/07/06/test/"/>
    <id>http://suprisemf.github.io/2018/07/06/test/</id>
    <published>2018-07-06T07:17:21.110Z</published>
    <updated>2018-07-06T07:07:24.802Z</updated>
    
    <content type="html"><![CDATA[<!DOCTYPE html>  <html>    <head>      <title>test</title>      <meta charset="utf-8">      <meta name="viewport" content="width=device-width, initial-scale=1.0">            <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.9.0/katex.min.css">                                                                  <style>       /** * prism.js Github theme based on GitHub's theme. * @author Sam Clarke */code[class*="language-"],pre[class*="language-"] {  color: #333;  background: none;  font-family: Consolas, "Liberation Mono", Menlo, Courier, monospace;  text-align: left;  white-space: pre;  word-spacing: normal;  word-break: normal;  word-wrap: normal;  line-height: 1.4;  -moz-tab-size: 8;  -o-tab-size: 8;  tab-size: 8;  -webkit-hyphens: none;  -moz-hyphens: none;  -ms-hyphens: none;  hyphens: none;}/* Code blocks */pre[class*="language-"] {  padding: .8em;  overflow: auto;  /* border: 1px solid #ddd; */  border-radius: 3px;  /* background: #fff; */  background: #f5f5f5;}/* Inline code */:not(pre) > code[class*="language-"] {  padding: .1em;  border-radius: .3em;  white-space: normal;  background: #f5f5f5;}.token.comment,.token.blockquote {  color: #969896;}.token.cdata {  color: #183691;}.token.doctype,.token.punctuation,.token.variable,.token.macro.property {  color: #333;}.token.operator,.token.important,.token.keyword,.token.rule,.token.builtin {  color: #a71d5d;}.token.string,.token.url,.token.regex,.token.attr-value {  color: #183691;}.token.property,.token.number,.token.boolean,.token.entity,.token.atrule,.token.constant,.token.symbol,.token.command,.token.code {  color: #0086b3;}.token.tag,.token.selector,.token.prolog {  color: #63a35c;}.token.function,.token.namespace,.token.pseudo-element,.token.class,.token.class-name,.token.pseudo-class,.token.id,.token.url-reference .token.variable,.token.attr-name {  color: #795da3;}.token.entity {  cursor: help;}.token.title,.token.title .token.punctuation {  font-weight: bold;  color: #1d3e81;}.token.list {  color: #ed6a43;}.token.inserted {  background-color: #eaffea;  color: #55a532;}.token.deleted {  background-color: #ffecec;  color: #bd2c00;}.token.bold {  font-weight: bold;}.token.italic {  font-style: italic;}/* JSON */.language-json .token.property {  color: #183691;}.language-markup .token.tag .token.punctuation {  color: #333;}/* CSS */code.language-css,.language-css .token.function {  color: #0086b3;}/* YAML */.language-yaml .token.atrule {  color: #63a35c;}code.language-yaml {  color: #183691;}/* Ruby */.language-ruby .token.function {  color: #333;}/* Markdown */.language-markdown .token.url {  color: #795da3;}/* Makefile */.language-makefile .token.symbol {  color: #795da3;}.language-makefile .token.variable {  color: #183691;}.language-makefile .token.builtin {  color: #0086b3;}/* Bash */.language-bash .token.keyword {  color: #0086b3;}html body{font-family:"Helvetica Neue",Helvetica,"Segoe UI",Arial,freesans,sans-serif;font-size:16px;line-height:1.6;color:#333;background-color:#fff;overflow:initial;box-sizing:border-box;word-wrap:break-word}html body>:first-child{margin-top:0}html body h1,html body h2,html body h3,html body h4,html body h5,html body h6{line-height:1.2;margin-top:1em;margin-bottom:16px;color:#000}html body h1{font-size:2.25em;font-weight:300;padding-bottom:.3em}html body h2{font-size:1.75em;font-weight:400;padding-bottom:.3em}html body h3{font-size:1.5em;font-weight:500}html body h4{font-size:1.25em;font-weight:600}html body h5{font-size:1.1em;font-weight:600}html body h6{font-size:1em;font-weight:600}html body h1,html body h2,html body h3,html body h4,html body h5{font-weight:600}html body h5{font-size:1em}html body h6{color:#5c5c5c}html body strong{color:#000}html body del{color:#5c5c5c}html body a:not([href]){color:inherit;text-decoration:none}html body a{color:#08c;text-decoration:none}html body a:hover{color:#00a3f5;text-decoration:none}html body img{max-width:100%}html body>p{margin-top:0;margin-bottom:16px;word-wrap:break-word}html body>ul,html body>ol{margin-bottom:16px}html body ul,html body ol{padding-left:2em}html body ul.no-list,html body ol.no-list{padding:0;list-style-type:none}html body ul ul,html body ul ol,html body ol ol,html body ol ul{margin-top:0;margin-bottom:0}html body li{margin-bottom:0}html body li.task-list-item{list-style:none}html body li>p{margin-top:0;margin-bottom:0}html body .task-list-item-checkbox{margin:0 .2em .25em -1.8em;vertical-align:middle}html body .task-list-item-checkbox:hover{cursor:pointer}html body blockquote{margin:16px 0;font-size:inherit;padding:0 15px;color:#5c5c5c;border-left:4px solid #d6d6d6}html body blockquote>:first-child{margin-top:0}html body blockquote>:last-child{margin-bottom:0}html body hr{height:4px;margin:32px 0;background-color:#d6d6d6;border:0 none}html body table{margin:10px 0 15px 0;border-collapse:collapse;border-spacing:0;display:block;width:100%;overflow:auto;word-break:normal;word-break:keep-all}html body table th{font-weight:bold;color:#000}html body table td,html body table th{border:1px solid #d6d6d6;padding:6px 13px}html body dl{padding:0}html body dl dt{padding:0;margin-top:16px;font-size:1em;font-style:italic;font-weight:bold}html body dl dd{padding:0 16px;margin-bottom:16px}html body code{font-family:Menlo,Monaco,Consolas,'Courier New',monospace;font-size:.85em !important;color:#000;background-color:#f0f0f0;border-radius:3px;padding:.2em 0}html body code::before,html body code::after{letter-spacing:-0.2em;content:"\00a0"}html body pre>code{padding:0;margin:0;font-size:.85em !important;word-break:normal;white-space:pre;background:transparent;border:0}html body .highlight{margin-bottom:16px}html body .highlight pre,html body pre{padding:1em;overflow:auto;font-size:.85em !important;line-height:1.45;border:#d6d6d6;border-radius:3px}html body .highlight pre{margin-bottom:0;word-break:normal}html body pre code,html body pre tt{display:inline;max-width:initial;padding:0;margin:0;overflow:initial;line-height:inherit;word-wrap:normal;background-color:transparent;border:0}html body pre code:before,html body pre tt:before,html body pre code:after,html body pre tt:after{content:normal}html body p,html body blockquote,html body ul,html body ol,html body dl,html body pre{margin-top:0;margin-bottom:16px}html body kbd{color:#000;border:1px solid #d6d6d6;border-bottom:2px solid #c7c7c7;padding:2px 4px;background-color:#f0f0f0;border-radius:3px}@media print{html body{background-color:#fff}html body h1,html body h2,html body h3,html body h4,html body h5,html body h6{color:#000;page-break-after:avoid}html body blockquote{color:#5c5c5c}html body pre{page-break-inside:avoid}html body table{display:table}html body img{display:block;max-width:100%;max-height:100%}html body pre,html body code{word-wrap:break-word;white-space:pre}}.markdown-preview{width:100%;height:100%;box-sizing:border-box}.markdown-preview .pagebreak,.markdown-preview .newpage{page-break-before:always}.markdown-preview pre.line-numbers{position:relative;padding-left:3.8em;counter-reset:linenumber}.markdown-preview pre.line-numbers>code{position:relative}.markdown-preview pre.line-numbers .line-numbers-rows{position:absolute;pointer-events:none;top:1em;font-size:100%;left:0;width:3em;letter-spacing:-1px;border-right:1px solid #999;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.markdown-preview pre.line-numbers .line-numbers-rows>span{pointer-events:none;display:block;counter-increment:linenumber}.markdown-preview pre.line-numbers .line-numbers-rows>span:before{content:counter(linenumber);color:#999;display:block;padding-right:.8em;text-align:right}.markdown-preview .mathjax-exps .MathJax_Display{text-align:center !important}.markdown-preview:not([for="preview"]) .code-chunk .btn-group{display:none}.markdown-preview:not([for="preview"]) .code-chunk .status{display:none}.markdown-preview:not([for="preview"]) .code-chunk .output-div{margin-bottom:16px}.scrollbar-style::-webkit-scrollbar{width:8px}.scrollbar-style::-webkit-scrollbar-track{border-radius:10px;background-color:transparent}.scrollbar-style::-webkit-scrollbar-thumb{border-radius:5px;background-color:rgba(150,150,150,0.66);border:4px solid rgba(150,150,150,0.66);background-clip:content-box}html body[for="html-export"]:not([data-presentation-mode]){position:relative;width:100%;height:100%;top:0;left:0;margin:0;padding:0;overflow:auto}html body[for="html-export"]:not([data-presentation-mode]) .markdown-preview{position:relative;top:0}@media screen and (min-width:914px){html body[for="html-export"]:not([data-presentation-mode]) .markdown-preview{padding:2em calc(50% - 457px)}}@media screen and (max-width:914px){html body[for="html-export"]:not([data-presentation-mode]) .markdown-preview{padding:2em}}@media screen and (max-width:450px){html body[for="html-export"]:not([data-presentation-mode]) .markdown-preview{font-size:14px !important;padding:1em}}@media print{html body[for="html-export"]:not([data-presentation-mode]) #sidebar-toc-btn{display:none}}html body[for="html-export"]:not([data-presentation-mode]) #sidebar-toc-btn{position:fixed;bottom:8px;left:8px;font-size:28px;cursor:pointer;color:inherit;z-index:99;width:32px;text-align:center;opacity:.4}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] #sidebar-toc-btn{opacity:1}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc{position:fixed;top:0;left:0;width:300px;height:100%;padding:32px 0 48px 0;font-size:14px;box-shadow:0 0 4px rgba(150,150,150,0.33);box-sizing:border-box;overflow:auto;background-color:inherit}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar{width:8px}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar-track{border-radius:10px;background-color:transparent}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar-thumb{border-radius:5px;background-color:rgba(150,150,150,0.66);border:4px solid rgba(150,150,150,0.66);background-clip:content-box}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc a{text-decoration:none}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc ul{padding:0 1.6em;margin-top:.8em}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc li{margin-bottom:.8em}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc ul{list-style-type:none}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{left:300px;width:calc(100% -  300px);padding:2em calc(50% - 457px -  150px);margin:0;box-sizing:border-box}@media screen and (max-width:1274px){html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{padding:2em}}@media screen and (max-width:450px){html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{width:100%}}html body[for="html-export"]:not([data-presentation-mode]):not([html-show-sidebar-toc]) .markdown-preview{left:50%;transform:translateX(-50%)}html body[for="html-export"]:not([data-presentation-mode]):not([html-show-sidebar-toc]) .md-sidebar-toc{display:none}/* Please visit the URL below for more information: *//*   https://shd101wyy.github.io/markdown-preview-enhanced/#/customize-css */       </style>    </head>    <body for="html-export">      <div class="mume markdown-preview   ">      <h2 class="mume-header" id="eriaoti">eriaoti</h2><h3 class="mume-header" id="sanbait">sanbait</h3><blockquote><p>hahahah</p></blockquote><p><?xml version="1.0" encoding="UTF-8" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><!-- Generated by graphviz version 2.40.1 (20161225.0304) --><!-- Title: G Pages: 1 --><svg width="135pt" height="332pt" viewbox="0.00 0.00 134.94 332.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 328)"><title>G</title><polygon fill="#ffffff" stroke="transparent" points="-4,4 -4,-328 130.9362,-328 130.9362,4 -4,4"/><!-- 开始 --><g id="node1" class="node"><title>开始</title><ellipse fill="none" stroke="#000000" cx="54" cy="-306" rx="35.3587" ry="18"/><text text-anchor="middle" x="54" y="-301.8" font-family="Times,serif" font-size="14.00" fill="#000000">开始</text></g><!-- A --><g id="node2" class="node"><title>A</title><ellipse fill="none" stroke="#000000" cx="54" cy="-234" rx="27" ry="18"/><text text-anchor="middle" x="54" y="-229.8" font-family="Times,serif" font-size="14.00" fill="#000000">A</text></g><!-- 开始&#45;&gt;A --><g id="edge1" class="edge"><title>开始&#45;&gt;A</title><path fill="none" stroke="#000000" d="M54,-287.8314C54,-280.131 54,-270.9743 54,-262.4166"/><polygon fill="#000000" stroke="#000000" points="57.5001,-262.4132 54,-252.4133 50.5001,-262.4133 57.5001,-262.4132"/></g><!-- B --><g id="node3" class="node"><title>B</title><ellipse fill="none" stroke="#000000" cx="82" cy="-162" rx="27" ry="18"/><text text-anchor="middle" x="82" y="-157.8" font-family="Times,serif" font-size="14.00" fill="#000000">B</text></g><!-- A&#45;&gt;B --><g id="edge2" class="edge"><title>A&#45;&gt;B</title><path fill="none" stroke="#000000" d="M60.778,-216.5708C63.9872,-208.3187 67.8935,-198.2738 71.4758,-189.0623"/><polygon fill="#000000" stroke="#000000" points="74.8248,-190.1069 75.1874,-179.5182 68.3008,-187.5697 74.8248,-190.1069"/></g><!-- D --><g id="node4" class="node"><title>D</title><ellipse fill="none" stroke="#000000" cx="27" cy="-90" rx="27" ry="18"/><text text-anchor="middle" x="27" y="-85.8" font-family="Times,serif" font-size="14.00" fill="#000000">D</text></g><!-- B&#45;&gt;D --><g id="edge3" class="edge"><title>B&#45;&gt;D</title><path fill="none" stroke="#000000" d="M69.5196,-145.6621C62.4876,-136.4564 53.5653,-124.7764 45.7117,-114.4953"/><polygon fill="#000000" stroke="#000000" points="48.2828,-112.0953 39.431,-106.2733 42.72,-116.3446 48.2828,-112.0953"/></g><!-- C --><g id="node5" class="node"><title>C</title><ellipse fill="none" stroke="#000000" cx="99" cy="-90" rx="27" ry="18"/><text text-anchor="middle" x="99" y="-85.8" font-family="Times,serif" font-size="14.00" fill="#000000">C</text></g><!-- B&#45;&gt;C --><g id="edge5" class="edge"><title>B&#45;&gt;C</title><path fill="none" stroke="#000000" d="M86.2022,-144.2022C88.0821,-136.2406 90.3425,-126.6671 92.4371,-117.7957"/><polygon fill="#000000" stroke="#000000" points="95.8955,-118.3792 94.7872,-107.8425 89.0828,-116.7706 95.8955,-118.3792"/></g><!-- D&#45;&gt;A --><g id="edge4" class="edge"><title>D&#45;&gt;A</title><path fill="none" stroke="#000000" d="M30.4074,-108.1727C35.0381,-132.8697 43.3612,-177.2595 48.7816,-206.1684"/><polygon fill="#000000" stroke="#000000" points="45.352,-206.8698 50.635,-216.0535 52.2321,-205.5797 45.352,-206.8698"/></g><!-- 结束 --><g id="node6" class="node"><title>结束</title><ellipse fill="none" stroke="#000000" cx="99" cy="-18" rx="27.8725" ry="18"/><text text-anchor="middle" x="99" y="-13.8" font-family="Times,serif" font-size="14.00" fill="#000000">结束</text></g><!-- C&#45;&gt;结束 --><g id="edge6" class="edge"><title>C&#45;&gt;结束</title><path fill="none" stroke="#000000" d="M99,-71.8314C99,-64.131 99,-54.9743 99,-46.4166"/><polygon fill="#000000" stroke="#000000" points="102.5001,-46.4132 99,-36.4133 95.5001,-46.4133 102.5001,-46.4132"/></g></g></svg></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>e</mi><mi>x</mi></msup><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">e^{x}=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.7143919999999999em;"></span><span class="strut bottom" style="height:0.7143919999999999em;vertical-align:0em;"></span><span class="base"><span class="mord"><span class="mord mathit">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7143919999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight">x</span></span></span></span></span></span></span></span></span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mord">0</span></span></span></span></span></p><p><img src="/2018/07/06/test/%E5%AE%9E%E7%8E%B0.png" alt="ls"></p><h4 class="mume-header" id="table-test">table test</h4><table><thead><tr><th>test</th><th>test</th><th>si</th><th>a</th><th>big</th><th>thing</th></tr></thead><tbody><tr><td>test</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>test2</td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><pre data-role="codeBlock" data-info="" class="language-"><code>public static void main(String[] args){  System.out.println(&quot;Hello world!&quot;);}</code></pre>      </div>                </body>                              </html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!DOCTYPE html&gt;
  &lt;html&gt;
    &lt;head&gt;
      &lt;title&gt;test&lt;/title&gt;
      &lt;meta charset=&quot;utf-8&quot;&gt;
      &lt;meta name=&quot;viewport&quot; content=&quot;width=device
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>UML之类图</title>
    <link href="http://suprisemf.github.io/2018/07/06/UML%E4%B9%8B%E7%B1%BB%E5%9B%BE/"/>
    <id>http://suprisemf.github.io/2018/07/06/UML之类图/</id>
    <published>2018-07-06T05:42:00.725Z</published>
    <updated>2018-07-08T12:08:13.758Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>限于Git空间有限，就不往博客中插入静态图片了，但是我的微信订阅号【星球码】上是有更加完整的文章。欢迎关注~</p></blockquote><h2 id="UML介绍"><a href="#UML介绍" class="headerlink" title="UML介绍"></a>UML介绍</h2><p>统一建模语言（英语：Unified Modeling Language，缩写 UML）是非专利的第三代建模和规约语言。UML是一种开放的方法，用于说明、可视化、构建和编写一个正在开发的、面向对象的、软件密集系统的制品的开放方法。UML展现了一系列最佳工程实践，这些最佳实践在对大规模，复杂系统进行建模方面，特别是在软件架构层次已经被验证有效。（来自维基百科） UML是在（常见但不限于）数据库设计过程中，在E-R图（实体-联系图）设计后的进一步建模。</p><h3 id="UML图"><a href="#UML图" class="headerlink" title="UML图"></a>UML图</h3><p>用例图、类图（今天主角）、对象图、包图、活动图、状态图、序列图（顺序图）、协作图、构件图、部署图（配置图）</p><blockquote><p>笔者在大三第一学期修了UML课程，当时是第一次接触UML，其中的各种图形，线条搞得有些乱套，好在最后课程大作业设计中，小组连战2天最后利用StarUML软件设计出一个图书管理系统，并利用给出一些简单的GUI。</p></blockquote><h2 id="UML类图线条"><a href="#UML类图线条" class="headerlink" title="UML类图线条"></a>UML类图线条</h2><blockquote><p>说明：类图中方法或属性前会出现+、-、#，该符号分表表示其访问权限是public、private、protected。</p><p>推荐大家使用一款免费的在线制作各种流程图的工具——ProcessOn。包括各种价值链图、过程链图、常规流程图、组织结构图、原型设计等，当然也支持熟悉的UML。（一条五毛~）</p></blockquote><p>线条表示类之间的关系，以下按照类之间关系由强到弱说明，即泛化=实现&gt;组合&gt;聚合&gt;关联&gt;依赖</p><blockquote><p>泛化和实现：子类或实现下面的方法表示增加/复写/实现了哪些方法</p></blockquote><h3 id="泛化"><a href="#泛化" class="headerlink" title="泛化"></a>泛化</h3><p>泛化：实线空白箭头，箭头指向父类，表示继承</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>实现：虚线空白箭头，箭头指向接口。</p><h3 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h3><blockquote><p>通过属性的引用形成组合关系，例如属性集合的引用。</p></blockquote><p>组合：是一种部分对整体的关系，实线，箭头指向部分，实心菱形指向整体。</p><h3 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h3><blockquote><p>通过属性引用形成的聚合关系，与关联类似，需要视具体场景。</p></blockquote><p>聚合：是群体对个体的关系，空心菱形指向群体，箭头指向其构成的个体。</p><h3 id="关联"><a href="#关联" class="headerlink" title="关联"></a>关联</h3><blockquote><p>通过属性引用形成的关联关系。</p></blockquote><p>关联：表示拥有关系，即has-a关系，箭头指向拥有者；但是如果是双向关联，两个箭头可以省略，即只有一条实线。</p><h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><blockquote><p>通过方法参数的依赖关系。</p></blockquote><p>依赖：表示一种协助关系，虚线，箭头指向被依赖者。</p><h3 id="欢迎搜索关注微信订阅号：【星球码】"><a href="#欢迎搜索关注微信订阅号：【星球码】" class="headerlink" title="欢迎搜索关注微信订阅号：【星球码】"></a>欢迎搜索关注微信订阅号：【星球码】</h3><p>笔者现在的知识十分有限，文章出现错误在所难免，还请各位能够多多包涵，并不吝指出啊~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;限于Git空间有限，就不往博客中插入静态图片了，但是我的微信订阅号【星球码】上是有更加完整的文章。欢迎关注~&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;UML介绍&quot;&gt;&lt;a href=&quot;#UML介绍&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>SecondBlog,ChangeTheme</title>
    <link href="http://suprisemf.github.io/2018/07/03/SecondBlog-ChangeTheme/"/>
    <id>http://suprisemf.github.io/2018/07/03/SecondBlog-ChangeTheme/</id>
    <published>2018-07-03T13:10:59.000Z</published>
    <updated>2018-07-03T13:15:48.631Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World~"></a>Hello World~</h1><h2 id="Test-again"><a href="#Test-again" class="headerlink" title="Test again."></a>Test again.</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Hello-World&quot;&gt;&lt;a href=&quot;#Hello-World&quot; class=&quot;headerlink&quot; title=&quot;Hello World~&quot;&gt;&lt;/a&gt;Hello World~&lt;/h1&gt;&lt;h2 id=&quot;Test-again&quot;&gt;&lt;a href=&quot;#Test-
      
    
    </summary>
    
    
      <category term="theme hello world" scheme="http://suprisemf.github.io/tags/theme-hello-world/"/>
    
  </entry>
  
  <entry>
    <title>hello,Hexo</title>
    <link href="http://suprisemf.github.io/2018/07/02/hello-Hexo/"/>
    <id>http://suprisemf.github.io/2018/07/02/hello-Hexo/</id>
    <published>2018-07-02T14:53:20.000Z</published>
    <updated>2018-07-02T15:16:40.286Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Title-test"><a href="#Title-test" class="headerlink" title="Title test."></a>Title test.</h1><h2 id="Second-test"><a href="#Second-test" class="headerlink" title="Second test."></a>Second test.</h2><h3 id="Third-test"><a href="#Third-test" class="headerlink" title="Third test."></a>Third test.</h3><p>使用Hexo+Github部署个人博客还算是一个比较简单的事情！小有成就，哈哈哈！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Title-test&quot;&gt;&lt;a href=&quot;#Title-test&quot; class=&quot;headerlink&quot; title=&quot;Title test.&quot;&gt;&lt;/a&gt;Title test.&lt;/h1&gt;&lt;h2 id=&quot;Second-test&quot;&gt;&lt;a href=&quot;#Second-t
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://suprisemf.github.io/2018/07/02/hello-world/"/>
    <id>http://suprisemf.github.io/2018/07/02/hello-world/</id>
    <published>2018-07-02T12:12:12.595Z</published>
    <updated>2018-07-02T12:12:12.595Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>

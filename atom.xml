<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>红宝石星球</title>
  
  <subtitle>凡心所向，素履以往；生如逆旅，一苇以航。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://suprisemf.github.io/"/>
  <updated>2018-08-03T06:28:25.863Z</updated>
  <id>http://suprisemf.github.io/</id>
  
  <author>
    <name>SupriseMF</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>高并发之高可用手段</title>
    <link href="http://suprisemf.github.io/2018/08/03/%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B9%8B%E9%AB%98%E5%8F%AF%E7%94%A8%E6%89%8B%E6%AE%B5/"/>
    <id>http://suprisemf.github.io/2018/08/03/高并发之高可用手段/</id>
    <published>2018-08-03T06:12:54.000Z</published>
    <updated>2018-08-03T06:28:25.863Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>高可用手段其实我只是了解个皮毛~后续一定要完善这部分内容！</p></blockquote><a id="more"></a><ol><li>任务调度系统分布式：elastic-job组件 + zookeeper；</li><li>主备切换：Apache curator + zookeeper分布式锁；</li><li>监控报警机制。详情参看：<a href="https://www.imooc.com/article/20891" target="_blank" rel="noopener">业务相关监控报警系统</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;高可用手段其实我只是了解个皮毛~后续一定要完善这部分内容！&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="高并发解决方案" scheme="http://suprisemf.github.io/categories/%E9%AB%98%E5%B9%B6%E5%8F%91%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    
    
      <category term="Java" scheme="http://suprisemf.github.io/tags/Java/"/>
    
      <category term="线程高并发" scheme="http://suprisemf.github.io/tags/%E7%BA%BF%E7%A8%8B%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>高并发之服务降级与熔断</title>
    <link href="http://suprisemf.github.io/2018/08/03/%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B9%8B%E6%9C%8D%E5%8A%A1%E9%99%8D%E7%BA%A7%E4%B8%8E%E7%86%94%E6%96%AD/"/>
    <id>http://suprisemf.github.io/2018/08/03/高并发之服务降级与熔断/</id>
    <published>2018-08-03T06:03:11.000Z</published>
    <updated>2018-08-03T06:11:27.050Z</updated>
    
    <content type="html"><![CDATA[<h2 id="服务降级"><a href="#服务降级" class="headerlink" title="服务降级"></a>服务降级</h2><p>由于爆炸性的流量冲击，对一些服务进行有策略的放弃，以此缓解系统压力，保证目前主要业务的正常运行。它主要是针对非正常情况下的应急服务措施：当此时一些业务服务无法执行时，给出一个统一的返回结果。<br><a id="more"></a></p><h3 id="降级服务的特征"><a href="#降级服务的特征" class="headerlink" title="降级服务的特征"></a>降级服务的特征</h3><ol><li>原因：整体负荷超出整体负载承受能力。</li><li>目的：保证重要或基本服务正常运行，非重要服务延迟使用或暂停使用</li><li>大小：降低服务粒度，要考虑整体模块粒度的大小，将粒度控制在合适的范围内</li><li>可控性：在服务粒度大小的基础上增加服务的可控性，后台服务开关的功能是一项必要配置（单机可配置文件，其他可领用数据库和缓存），可分为手动控制和自动控制。</li><li>次序：一般从外围延伸服务开始降级，需要有一定的配置项，重要性低的优先降级，比如可以分组设置等级1-10，当服务需要降级到某一个级别时，进行相关配置</li></ol><h3 id="降级方式"><a href="#降级方式" class="headerlink" title="降级方式"></a>降级方式</h3><ol><li>延迟服务：比如发表了评论，重要服务，比如在文章中显示正常，但是延迟给用户增加积分，只是放到一个缓存中，等服务平稳之后再执行。</li><li>在粒度范围内关闭服务（片段降级或服务功能降级）：比如关闭相关文章的推荐，直接关闭推荐区</li><li>页面异步请求降级：比如商品详情页上有推荐信息/配送至等异步加载的请求，如果这些信息响应慢或者后端服务有问题，可以进行降级；</li><li>页面跳转（页面降级）：比如可以有相关文章推荐，但是更多的页面则直接跳转到某一个地址</li><li>写降级：比如秒杀抢购，我们可以只进行Cache的更新，然后异步同步扣减库存到DB，保证最终一致性即可，此时可以将DB降级为Cache。</li><li>读降级：比如多级缓存模式，如果后端服务有问题，可以降级为只读缓存，这种方式适用于对读一致性要求不高的场景。</li></ol><h3 id="降级预案"><a href="#降级预案" class="headerlink" title="降级预案"></a>降级预案</h3><p>在进行降级之前要对系统进行梳理，看看系统是不是可以丢卒保帅；从而梳理出哪些必须誓死保护，哪些可降级；比如可以参考日志级别设置预案：</p><ol><li>一般：比如有些服务偶尔因为网络抖动或者服务正在上线而超时，可以自动降级；</li><li>警告：有些服务在一段时间内成功率有波动（如在95~100%之间），可以自动降级或人工降级，并发送告警；</li><li>错误：比如可用率低于90%，或者数据库连接池被打爆了，或者访问量突然猛增到系统能承受的最大阀值，此时可以根据情况自动降级或者人工降级；</li><li>严重错误：比如因为特殊原因数据错误了，此时需要紧急人工降级。</li></ol><h3 id="服务降级分类"><a href="#服务降级分类" class="headerlink" title="服务降级分类"></a>服务降级分类</h3><ol><li>降级按照是否自动化可分为：自动开关降级（超时、失败次数、故障、限流）和人工开关降级（秒杀、电商大促等）。</li><li>降级按照功能可分为：读服务降级、写服务降级。</li><li>降级按照处于的系统层次可分为：多级降级。</li></ol><h3 id="自动降级分类"><a href="#自动降级分类" class="headerlink" title="自动降级分类"></a>自动降级分类</h3><ol><li>超时降级：主要配置好超时时间和超时重试次数和机制，并使用异步机制探测回复情况</li><li>失败次数降级：主要是一些不稳定的api，当失败调用次数达到一定阀值自动降级，同样要使用异步机制探测回复情况</li><li>故障降级：比如要调用的远程服务挂掉了（网络故障、DNS故障、http服务返回错误的状态码、rpc服务抛出异常），则可以直接降级。降级后的处理方案有：默认值（比如库存服务挂了，返回默认现货）、兜底数据（比如广告挂了，返回提前准备好的一些静态页面）、缓存（之前暂存的一些缓存数据）</li><li>限流降级<br>当我们去秒杀或者抢购一些限购商品时，此时可能会因为访问量太大而导致系统崩溃，此时开发者会使用限流来进行限制访问量，当达到限流阀值，后续请求会被降级；降级后的处理方案可以是：排队页面（将用户导流到排队页面等一会重试）、无货（直接告知用户没货了）、错误页（如活动太火爆了，稍后重试）</li></ol><p><a href="http://www.architecy.com/archives/265" target="_blank" rel="noopener">参考引用文章</a></p><h3 id="服务降级需考虑的问题"><a href="#服务降级需考虑的问题" class="headerlink" title="服务降级需考虑的问题"></a>服务降级需考虑的问题</h3><ol><li>核心服务或非核心服务。</li><li>是否支持降级，及其降级策略。</li><li>业务放通场景，极其策略。</li></ol><h3 id="Hystrix组件"><a href="#Hystrix组件" class="headerlink" title="Hystrix组件"></a>Hystrix组件</h3><h4 id="Hystrix流程"><a href="#Hystrix流程" class="headerlink" title="Hystrix流程"></a>Hystrix流程</h4><p>服务降级通常可以通过使用该组建完成。</p><ul><li>在通过第三方客户端访问（通常通过网络）依赖服务出现高延迟或失败时，为系统提供保护和控制。</li><li>在分布式系统中防止级联失败。</li><li>快速失败（Fail-fast）同时能快速恢复。</li><li>提供失败回退（Fallback）和优雅的服务降级机制。</li></ul><p><img src="/2018/08/03/高并发之服务降级与熔断/Hystrix流程图.png" alt="图示"></p><p>流程说明：</p><ol><li>每次调用创建一个新的HystrixCommand,把依赖调用封装在run()方法中.</li><li>执行execute()/queue做同步或异步调用.</li><li>判断熔断器(circuit-breaker)是否打开,如果打开跳到步骤8,进行降级策略,如果关闭进入步骤.</li><li>判断线程池/队列/信号量是否跑满，如果跑满进入降级步骤8,否则继续后续步骤.</li><li>调用HystrixCommand的run方法.运行依赖逻辑<br>a: 依赖逻辑调用超时,进入步骤8.</li><li>判断逻辑是否调用成功<br>a: 返回成功调用结果<br>b: 调用出错，进入步骤8.</li><li>计算熔断器状态,所有的运行状态(成功, 失败, 拒绝,超时)上报给熔断器，用于统计从而判断熔断器状态.</li><li>getFallback()降级逻辑.以下四种情况将触发getFallback调用：(1):run()方法抛出非HystrixBadRequestException异常;(2):run()方法调用超时;(3):熔断器开启拦截调用;(4):线程池/队列/信号量是否跑满。<br>a: 没有实现getFallback的Command将直接抛出异常<br>b: fallback降级逻辑调用成功直接返回<br>c: 降级逻辑调用失败抛出异常</li><li>返回执行成功结果</li></ol><h5 id="Hystrix测试说明"><a href="#Hystrix测试说明" class="headerlink" title="Hystrix测试说明"></a>Hystrix测试说明</h5><p><img src="/2018/08/03/高并发之服务降级与熔断/36.png" alt="图示"></p><h4 id="Hystrix特性"><a href="#Hystrix特性" class="headerlink" title="Hystrix特性"></a>Hystrix特性</h4><p>　　1. 请求熔断： 当Hystrix Command请求后端服务失败数量超过一定比例(默认50%), 断路器会切换到开路状态(Open). 这时所有请求会直接失败而不会发送到后端服务. 断路器保持在开路状态一段时间后(默认5秒), 自动切换到半开路状态(HALF-OPEN).</p><blockquote><p>这时会判断下一次请求的返回情况, 如果请求成功, 断路器切回闭路状态(CLOSED), 否则重新切换到开路状态(OPEN). Hystrix的断路器就像我们家庭电路中的保险丝, 一旦后端服务不可用, 断路器会直接切断请求链, 避免发送大量无效请求影响系统吞吐量, 并且断路器有自我检测并恢复的能力.</p></blockquote><p>　　2. 服务降级：Fallback相当于是降级操作. 对于查询操作, 我们可以实现一个fallback方法, 当请求后端服务出现异常的时候, 可以使用fallback方法返回的值. fallback方法的返回值一般是设置的默认值或者来自缓存.告知后面的请求服务不可用了，不要再来了。</p><p>　　3. 依赖隔离(采用舱壁模式，Docker就是舱壁模式的一种)：在Hystrix中, 主要通过线程池来实现资源隔离. 通常在使用的时候我们会根据调用的远程服务划分出多个线程池.比如说，一个服务调用两外两个服务，你如果调用两个服务都用一个线程池，那么如果一个服务卡在哪里，资源没被释放</p><blockquote><p>后面的请求又来了，导致后面的请求都卡在哪里等待，导致你依赖的A服务把你卡在哪里，耗尽了资源，也导致了你另外一个B服务也不可用了。这时如果依赖隔离，某一个服务调用A B两个服务，如果这时我有100个线程可用，我给A服务分配50个，给B服务分配50个，这样就算A服务挂了，我的B服务依然可以用。</p></blockquote><p>　　4. 请求缓存：比如一个请求过来请求我userId=1的数据，你后面的请求也过来请求同样的数据，这时我不会继续走原来的那条请求链路了，而是把第一次请求缓存过了，把第一次的请求结果返回给后面的请求。</p><p>　　5. 请求合并：我依赖于某一个服务，我要调用N次，比如说查数据库的时候，我发了N条请求发了N条SQL然后拿到一堆结果，这时候我们可以把多个请求合并成一个请求，发送一个查询多条数据的SQL的请求，这样我们只需查询一次数据库，提升了效率。</p><p><a href="https://www.cnblogs.com/huangjuncong/p/9026949.html" target="_blank" rel="noopener">参考文章</a></p><h3 id="Hystrix如何解决依赖隔离"><a href="#Hystrix如何解决依赖隔离" class="headerlink" title="Hystrix如何解决依赖隔离"></a>Hystrix如何解决依赖隔离</h3><ol><li><p>Hystrix使用命令模式HystrixCommand(Command)包装依赖调用逻辑，每个命令在单独线程中/信号授权下执行。</p></li><li><p>可配置依赖调用超时时间,超时时间一般设为比99.5%平均时间略高即可.当调用超时时，直接返回或执行fallback逻辑。</p></li><li><p>为每个依赖提供一个小的线程池（或信号），如果线程池已满调用将被立即拒绝，默认不采用排队.加速失败判定时间。</p></li><li><p>依赖调用结果分:成功，失败（抛出异常），超时，线程拒绝，短路。 请求失败(异常，拒绝，超时，短路)时执行fallback(降级)逻辑。</p></li><li><p>提供熔断器组件,可以自动运行或手动调用,停止当前依赖一段时间(10秒)，熔断器默认错误率阈值为50%,超过将自动运行。</p></li><li><p>提供近实时依赖的统计和监控</p></li></ol><p><a href="https://blog.csdn.net/u013851082/article/details/67634570" target="_blank" rel="noopener">推荐文章</a></p><h2 id="服务熔断"><a href="#服务熔断" class="headerlink" title="服务熔断"></a>服务熔断</h2><p>服务熔断也被称为服务过载保护。<br>如下图所示：</p><p><img src="/2018/08/03/高并发之服务降级与熔断/服务熔断.png" alt="图示"></p><p>其实可以认为：服务熔断是服务降级的措施。</p><h3 id="服务熔断与服务降级比较"><a href="#服务熔断与服务降级比较" class="headerlink" title="服务熔断与服务降级比较"></a>服务熔断与服务降级比较</h3><ol><li>服务熔断对服务提供了proxy，防止服务不可能时，出现串联故障（cascading failure），导致雪崩效应。</li><li>服务熔断一般是某个服务（下游服务）故障引起，而服务降级一般是从整体负荷考虑。</li><li>共性：</li></ol><ul><li>目的 -&gt; 都是从可用性、可靠性出发，提高系统的容错能力。</li><li>最终表现-&gt;使某一些应用不可达或不可用，来保证整体系统稳定。</li><li>粒度 -&gt; 一般都是服务级别，但也有细粒度的层面：如做到数据持久层、只许查询不许增删改等。</li><li>自治 -&gt; 对其自治性要求很高。都要求具有较高的自动处理机制。</li></ul><ol start="4"><li>区别：</li></ol><ul><li>触发原因 -&gt; 服务熔断通常是下级服务故障引起；服务降级通常为整体系统而考虑。</li><li>管理目标 -&gt; 熔断是每个微服务都需要的，是一个框架级的处理；而服务降级一般是关注业务，对业务进行考虑，抓住业务的层级，从而决定在哪一层上进行处理：比如在IO层，业务逻辑层，还是在外围进行处理。</li><li>实现方式 -&gt; 代码实现中的差异。</li></ul><h3 id="服务熔断中需考虑的设计："><a href="#服务熔断中需考虑的设计：" class="headerlink" title="服务熔断中需考虑的设计："></a>服务熔断中需考虑的设计：</h3><p>源自博主张善友的观点：</p><ol><li>异常处理：调用受熔断器保护的服务的时候，我们必须要处理当服务不可用时的异常情况。这些异常处理通常需要视具体的业务情况而定。比如，如果应用程序只是暂时的功能降级，可能需要切换到其它的可替换的服务上来执行相同的任务或者获取相同的数据，或者给用户报告错误然后提示他们稍后重试。</li><li>异常的类型：请求失败的原因可能有很多种。一些原因可能会比其它原因更严重。比如，请求会失败可能是由于远程的服务崩溃，这可能需要花费数分钟来恢复；也可能是由于服务器暂时负载过重导致超时。熔断器应该能够检查错误的类型，从而根据具体的错误情况来调整策略。比如，可能需要很多次超时异常才可以断定需要切换到断开状态，而只需要几次错误提示就可以判断服务不可用而快速切换到断开状态。</li><li>日志：熔断器应该能够记录所有失败的请求，以及一些可能会尝试成功的请求，使得的管理员能够监控使用熔断器保护的服务的执行情况。</li><li>测试服务是否可用：在断开状态下，熔断器可以采用定期的ping远程的服务或者资源，来判断是否服务是否恢复，而不是使用计时器来自动切换到半断开状态。这种ping操作可以模拟之前那些失败的请求，或者可以使用通过调用远程服务提供的检查服务是否可用的方法来判断。</li><li>手动重置：在系统中对于失败操作的恢复时间是很难确定的，提供一个手动重置功能能够使得管理员可以手动的强制将熔断器切换到闭合状态。同样的，如果受熔断器保护的服务暂时不可用的话，管理员能够强制的将熔断器设置为断开状态。</li><li>并发问题：相同的熔断器有可能被大量并发请求同时访问。熔断器的实现不应该阻塞并发的请求或者增加每次请求调用的负担。</li><li>资源的差异性：使用单个熔断器时，一个资源如果​​有分布在多个地方就需要小心。比如，一个数据可能存储在多个磁盘分区上(shard)，某个分区可以正常访问，而另一个可能存在暂时性的问题。在这种情况下，不同的错误响应如果混为一谈，那么应用程序访问的这些存在问题的分区的失败的可能性就会高，而那些被认为是正常的分区，就有可能被阻塞。</li><li>加快熔断器的熔断操作:有时候，服务返回的错误信息足够让熔断器立即执行熔断操作并且保持一段时间。比如，如果从一个分布式资源返回的响应提示负载超重，那么应该等待几分钟后再重试。（HTTP协议定义了”HTTP 503 Service Unavailable”来表示请求的服务当前不可用，他可以包含其他信息比如，超时等）</li><li>重复失败请求：当熔断器在断开状态的时候，熔断器可以记录每一次请求的细节，而不是仅仅返回失败信息，这样当远程服务恢复的时候，可以将这些失败的请求再重新请求一次。</li></ol><h4 id="服务熔断恢复需注意的问题"><a href="#服务熔断恢复需注意的问题" class="headerlink" title="服务熔断恢复需注意的问题"></a>服务熔断恢复需注意的问题</h4><p>如果服务是幂等性的，则恢复重试不会有问题；而如果服务是非幂等性的，则重试会导致数据出现问题。</p><p><a href="https://blog.csdn.net/whereismatrix/article/details/53465722" target="_blank" rel="noopener">参考文章</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;服务降级&quot;&gt;&lt;a href=&quot;#服务降级&quot; class=&quot;headerlink&quot; title=&quot;服务降级&quot;&gt;&lt;/a&gt;服务降级&lt;/h2&gt;&lt;p&gt;由于爆炸性的流量冲击，对一些服务进行有策略的放弃，以此缓解系统压力，保证目前主要业务的正常运行。它主要是针对非正常情况下的应急服务措施：当此时一些业务服务无法执行时，给出一个统一的返回结果。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="高并发解决方案" scheme="http://suprisemf.github.io/categories/%E9%AB%98%E5%B9%B6%E5%8F%91%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    
    
      <category term="Java" scheme="http://suprisemf.github.io/tags/Java/"/>
    
      <category term="线程高并发" scheme="http://suprisemf.github.io/tags/%E7%BA%BF%E7%A8%8B%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>高并发之初识限流</title>
    <link href="http://suprisemf.github.io/2018/08/03/%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B9%8B%E5%88%9D%E8%AF%86%E9%99%90%E6%B5%81/"/>
    <id>http://suprisemf.github.io/2018/08/03/高并发之初识限流/</id>
    <published>2018-08-03T05:54:15.000Z</published>
    <updated>2018-08-03T05:59:53.043Z</updated>
    
    <content type="html"><![CDATA[<h2 id="高并发之初识限流"><a href="#高并发之初识限流" class="headerlink" title="高并发之初识限流"></a>高并发之初识限流</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>高并发场景下，爆炸性大量的对数据库的请求操作不仅会占用十分高比例的网络带宽，导致其他应用对数据库的请求受阻，还会导致从库与主库的延迟大大增加，降低了从库数据的不准确率，也降低了缓存的命中率。<br><a id="more"></a><br>如下图：</p><p><img src="/2018/08/03/高并发之初识限流/31.png" alt="图示"></p><hr><h3 id="限流方式"><a href="#限流方式" class="headerlink" title="限流方式"></a>限流方式</h3><p>一般开发高并发系统常见的限流有：限制总并发数、限制瞬时并发数、限制时间窗口内的平均速率；其他还有如限制远程接口调用速率、限制MQ的消费速率。另外还可以根据网络连接数、网络流量、CPU或内存负载等来限流。以减少高并发对系统的影响，最终做到有损服务而不是不服务；限流需要评估好，不可乱用，否则会正常流量出现一些奇怪的问题而导致用户抱怨。 <a href="https://blog.csdn.net/g_hongjin/article/details/51649246" target="_blank" rel="noopener">参考文章</a></p><blockquote><p>其中限制总并发数：如数据库连接池、线程池；<br>限制瞬时并发数：如nginx的limit_conn模块，用来限制瞬时并发连接数；<br>限制时间窗口内的平均速率：如Guava的RateLimiter、nginx的limit_req模块，限制每秒的平均速率；</p></blockquote><hr><h3 id="限流算法"><a href="#限流算法" class="headerlink" title="限流算法"></a>限流算法</h3><ol><li>计数器法</li><li>滑动窗口</li><li>漏桶算法</li><li>令牌桶算法</li></ol><h4 id="gt-计数器法"><a href="#gt-计数器法" class="headerlink" title="&gt;计数器法"></a>&gt;计数器法</h4><p>计数器法是最简单、最易实现的限流算法。通过重复设置计数器，对接口一定时间段内的访问频率进行限制。</p><p><strong>弊端</strong>：存在临界问题。<br>如下图所示：</p><p><img src="/2018/08/03/高并发之初识限流/计数器法.png" alt="图示"></p><p>如上图所示，在临界的小时间段内，发送了200个请求，导致限流的不成功，可能会导致应用的崩溃。</p><h4 id="gt-滑动窗口"><a href="#gt-滑动窗口" class="headerlink" title="&gt;滑动窗口"></a>&gt;滑动窗口</h4><p>滑动窗口可以被看做是一个高精度的计数器算法。其中小窗口的个数越多，对限流中请求的统计会越精确，但占用的系统资源会多。<br>如下图所示：</p><p><img src="/2018/08/03/高并发之初识限流/滑动窗口.png" alt="图示"></p><p>其中，虚线包括了6个小窗口，这该6个小窗口组成了一个滑动窗口，滑动窗口对请求数量进行限定；每个小窗口都有一个计数器，都限定了相同的一定时间。每经过该小窗口的时间，滑动窗口就向右侧移动一格，如上图的所示，从而避免了计数器法中的弊端。</p><h4 id="gt-漏桶算法"><a href="#gt-漏桶算法" class="headerlink" title="&gt;漏桶算法"></a>&gt;漏桶算法</h4><p>漏桶算法（Leaky Bucket）作为计量工具（The Leaky Bucket Algorithm as a Meter）时，可以用于流量整形（Traffic Shaping）和流量控制（TrafficPolicing）。<br>其算法示意图如下：</p><p><img src="/2018/08/03/高并发之初识限流/漏铜算法.png" alt="图示"></p><p>漏桶算法构建一个容量固定的漏桶，请求数会先放入漏桶，以可控的一定速率流出来，当漏桶满了时，多余的请求会被丢弃。</p><h4 id="gt-令牌桶算法"><a href="#gt-令牌桶算法" class="headerlink" title="&gt;令牌桶算法"></a>&gt;令牌桶算法</h4><p>令牌桶算法可以看做是漏桶算法和滑动窗口思想的结合体，构造一个存放固定容量令牌的桶，按照可控的固定速率往桶里添加令牌。<br>如下图所示：</p><p><img src="/2018/08/03/高并发之初识限流/令牌算法.png" alt="图示"></p><p>当桶满了时，新添加的令牌会被丢弃或拒绝。当一个请求过来时，该桶就移除一个令牌；当桶中没了令牌时，请求也就无法通过。其中移除令牌是没有延迟时间的，若当设置该延迟时间后，就十分近似漏桶算法了。它通过将桶总量划分为多个令牌的容量，不会造成大量请求的突发，可以很好地解决临界问题。</p><h4 id="令牌桶算法与漏桶算法的比较"><a href="#令牌桶算法与漏桶算法的比较" class="headerlink" title="令牌桶算法与漏桶算法的比较"></a>令牌桶算法与漏桶算法的比较</h4><ul><li>令牌桶是按照固定速率往桶中添加令牌，请求是否被处理需要看桶中令牌是否足够，当令牌数减为零时则拒绝新的请求；</li><li>漏桶则是按照常量固定速率流出请求，流入请求速率任意，当流入的请求数累积到漏桶容量时，则新流入的请求被拒绝；</li><li>令牌桶限制的是平均流入速率（允许突发请求，只要有令牌就可以处理，支持一次拿3个令牌，4个令牌），并允许一定程度突发流量；</li><li>漏桶限制的是常量流出速率（即流出速率是一个固定常量值，比如都是1的速率流出，而不能一次是1，下次又是2），从而平滑突发流入速率；</li><li>令牌桶允许一定程度的突发，而漏桶主要目的是平滑流入速率；</li><li>两个算法实现可以一样，但是方向是相反的，对于相同的参数得到的限流效果是一样的。</li></ul><p><a href="https://blog.csdn.net/g_hongjin/article/details/51649246" target="_blank" rel="noopener">推荐阅读</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;高并发之初识限流&quot;&gt;&lt;a href=&quot;#高并发之初识限流&quot; class=&quot;headerlink&quot; title=&quot;高并发之初识限流&quot;&gt;&lt;/a&gt;高并发之初识限流&lt;/h2&gt;&lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;高并发场景下，爆炸性大量的对数据库的请求操作不仅会占用十分高比例的网络带宽，导致其他应用对数据库的请求受阻，还会导致从库与主库的延迟大大增加，降低了从库数据的不准确率，也降低了缓存的命中率。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="高并发解决方案" scheme="http://suprisemf.github.io/categories/%E9%AB%98%E5%B9%B6%E5%8F%91%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    
    
      <category term="Java" scheme="http://suprisemf.github.io/tags/Java/"/>
    
      <category term="线程高并发" scheme="http://suprisemf.github.io/tags/%E7%BA%BF%E7%A8%8B%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>高并发之应用拆分</title>
    <link href="http://suprisemf.github.io/2018/08/03/%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B9%8B%E5%BA%94%E7%94%A8%E6%8B%86%E5%88%86/"/>
    <id>http://suprisemf.github.io/2018/08/03/高并发之应用拆分/</id>
    <published>2018-08-03T05:45:38.000Z</published>
    <updated>2018-08-03T05:49:31.648Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>一个服务器再怎么优化，其处理能力都是有限的。之前介绍过过扩容、缓存机制、消息队列等优化方案，都是十分有效的。根据项目情况，将一个整体应用拆分为多个应用也不失为一个方案。比如按功能模块及功能模块使用频率拆分。<br><a id="more"></a><br>例子如下：</p><p><img src="/2018/08/03/高并发之应用拆分/应用拆分例子.png" alt="图示"></p><h4 id="应用拆分的好处"><a href="#应用拆分的好处" class="headerlink" title="应用拆分的好处"></a>应用拆分的好处</h4><ol><li>减轻并优化了整个统一的应用的压力。</li><li>拆分后的应用可以被更精准的监控。</li><li>不同子应用会更容易管理及局部优化。</li><li>更利于功能模块内部的团队协作。</li></ol><h4 id="应用拆分的弊端"><a href="#应用拆分的弊端" class="headerlink" title="应用拆分的弊端"></a>应用拆分的弊端</h4><ol><li>管理的复杂度上升。</li><li>代价昂贵。使用资源的成本增加。</li><li>网络开销增加，带宽要求增加。</li></ol><h4 id="应用拆分的基本原则"><a href="#应用拆分的基本原则" class="headerlink" title="应用拆分的基本原则"></a>应用拆分的基本原则</h4><ol><li>业务优先。优先按照业务的功能拆分为小应用。</li><li>循序渐进，迭代拆分并进行测试。</li><li>兼顾技术：重构、分层。</li><li>可靠测试。减少或避免累积错误的出现。</li></ol><h4 id="应用拆分的思考"><a href="#应用拆分的思考" class="headerlink" title="应用拆分的思考"></a>应用拆分的思考</h4><ol><li>应用之间通信：RPC（dubbo等）或消息队列（适用于传输数据包小，但传输量大，对数据的实时性要求不高的场景）。</li><li>应用之间的数据库设计：每个应用都应有自己的数据库，其中一些共同的信息可以另建一个公共数据库来存放。</li><li>避免事务操作跨应用，降低耦合度。</li></ol><hr><h4 id="服务化的Dubbo"><a href="#服务化的Dubbo" class="headerlink" title="服务化的Dubbo"></a>服务化的Dubbo</h4><p>Dubbo也是一种分布式的服务框架，可实现软负载均衡。<br>但Dubbo Service不是分布式的服务框架，但可以结合其他组件实现负载均衡。<br>Dubbo还提供了监控中心（可选，需要单独配置）和调用中心。</p><p>其处理流程原理图如下：</p><p><img src="/2018/08/03/高并发之应用拆分/dubbo.png" alt="图示"></p><p>其中的Registey模块选择zookeeper；<br>服务端Provider通常会声明一个Java接口类来代表自己提供的服务。当消费端Consumer获得接口并<strong>配置完相应的内容后</strong>，会<strong>调用相应的接口方法</strong>，底层实际就对应着invoke()方法调用服务，并将结果封装为接口定义的类型返回。</p><hr><h4 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h4><p>微服务是一个架构概念。通过功能分解，对解决方案解耦，并提供更加灵活的服务支持。它可扩展单个组件，而不是整个应用程序堆栈，从而满足服务等级协议。它围绕着业务领域来创建应用，该应用可独立地进行开发、管理、迭代。在分散的组件中，使用云架构和平台式管理、部署和服务功能，使产品交付更加简单。它的本质是通过使用功能明确、业务精炼的服务，去解决更大更实际的问题。</p><p>微服务处理流程图如下：</p><p><img src="/2018/08/03/高并发之应用拆分/微服务.png" alt="图示"></p><h4 id="微服务特点"><a href="#微服务特点" class="headerlink" title="微服务特点"></a>微服务特点</h4><ol><li>每个微服务独立地组成整个大服务。</li><li>单独部署。</li><li>分布式地进行管理。</li><li>强调隔离性。<blockquote><p>实现隔离化的标准：<br>（1）是由分布式服务组成的系统；<br>（2）按照业务划分组织；<br>（3）其为有生命的产品；<br>（4）强服务个体，弱通信；<br>（5）自动化运维；<br>（6）具有高度的容错性；<br>（7）可快速演化迭代；</p></blockquote></li></ol><h4 id="应用微服务需解决的问题"><a href="#应用微服务需解决的问题" class="headerlink" title="应用微服务需解决的问题"></a>应用微服务需解决的问题</h4><ol><li><strong>客户端如何访问这些服务？</strong><br>通过客户端与产品服务之间的一个访问代理：API Gateway，提供统一的服务入口，让微服务对前台透明；同时可以聚合后台的产品服务，节省流量，提升性能；提供安全、过滤、流控等API的管理功能。</li><li><strong>每个服务之间是如何通信的？</strong><br>若采用异步方式，则使用消息队列实现，如Kafka；<br>若采用同步方式，则包括：REST和RPC。其中REST可通过SpringBoot或JAX-RS；RPC通常使用Dubbo；<br>同步方式与异步方式的区别：<ul><li>同步调用较为简单，一致性强；但当调用层次深时，易出现调用问题；REST是基于http协议，可跨客户端，更易实现，更加灵活（无语言限制）；RPC优点：传输协议更高效，安全更可控。</li><li>异步消息方式在分布式系统中有更加广泛的应用，既能减少调用之间的耦合，又能成为调用之间的缓存，确保消息积压不会冲垮被调用方；同时仍可保证调用方的体验，并继续自己的任务而不至于被后台的性能拖慢。但它的一致性较弱，需要接受数据的最终一致性，并由后台服务实现幂等性。需独立引入一个Broker。</li></ul></li><li><strong>如此多的服务是如何实现的？</strong><br>在微服务架构中，都是有多个拷贝以实现负载均衡。一个服务随时可能下线，也可能因应对访问压力，随时增加新的服务节点。<br>通过Zookeeper或其他类似功能实现服务之间的发现功能，做服务注册等信息的分布式管理。当服务上线时，服务启用者将将自己的服务信息注册至Zookeeper，并通过心跳维持长连接，并实时更新连接信息；服务调用者通过Zookeeper来寻找地址，根据可定制的算法，找到一个服务，还可以将服务信息缓存至本地，提高性能。当服务上线后，Zookeeper会通知给服务的客户端。</li><li>若一个服务崩溃了该如何解决？<br>由于分布式最大的特性就是网络是非可靠的。通过微服务拆分，它可以降低网络不可靠带来的风险，但仍需要一定的安全保障。采取相应的手段降低服务调用链中的连环失效：重试机制、应用的限流、熔断机制、负载均衡、系统降级等。（后续会对其做更详细的手记。）</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;一个服务器再怎么优化，其处理能力都是有限的。之前介绍过过扩容、缓存机制、消息队列等优化方案，都是十分有效的。根据项目情况，将一个整体应用拆分为多个应用也不失为一个方案。比如按功能模块及功能模块使用频率拆分。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="高并发解决方案" scheme="http://suprisemf.github.io/categories/%E9%AB%98%E5%B9%B6%E5%8F%91%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    
    
      <category term="Java" scheme="http://suprisemf.github.io/tags/Java/"/>
    
      <category term="线程高并发" scheme="http://suprisemf.github.io/tags/%E7%BA%BF%E7%A8%8B%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>消息队列</title>
    <link href="http://suprisemf.github.io/2018/08/03/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    <id>http://suprisemf.github.io/2018/08/03/消息队列/</id>
    <published>2018-08-03T05:37:59.000Z</published>
    <updated>2018-08-03T05:42:47.492Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>消息队列已经逐步成为企业系统内部通信的核心手段。</p><a id="more"></a><p>简单的消息队列模型：</p><p><img src="/2018/08/03/消息队列/消息队列简单模型.png" alt="图示"></p><p>举例购物网站购物后，需要发送短信通知。其中图中的流程A就是发短信的业务，将其封装为一条消息A1，并放到消息队列，消息队列按照一定处理顺序处理消息，若成功则消息A1被处理；如果因短信调用端接口出现问题，短信发送超时或短时间内达到上限，则导致失败，可以重新将消息放入消息队列。<br>其中的一些待处理的细节：</p><ol><li>在消息中指定最小的执行时间。可减少重新尝试的次数。</li><li>需对消息队列对消息的处理速度，即短时间内短信发送的上限。</li></ol><p>该例使用消息队列的好处：</p><ol><li>实现网站主业务与短信通知业务的异步解耦。</li><li>简化设计。短信通知业务交由消息队列处理。</li><li>通过消息保持了事务最终一致性。即使失败也会重新尝试，保证短信业务的执行完成。</li><li>若还需要邮件通知业务，可以与短信通知业务并行处理；而不必同步等待，，增强系统的异步处理能力，减少甚至消灭并发现象。</li></ol><h3 id="消息队列使用场景"><a href="#消息队列使用场景" class="headerlink" title="消息队列使用场景"></a>消息队列使用场景</h3><ol><li>异步处理：如用户注册后，需要发注册邮件和注册短信。传统的做法有两种 1.串行的方式；2.并行方式</li><li>应用解耦：如用户下单后，订单系统需要通知库存系统。传统的做法是，订单系统调用库存系统的接口。</li><li>流量销锋：如秒杀活动，一般会因为流量过大，导致流量暴增，应用挂掉。为解决这个问题，一般需要在应用前端加入消息队列。</li><li>日志系统：如Kafka的应用，解决大量日志传输的问题。</li><li>信息通讯：如实现点对点消息队列，或者聊天室等。</li><li>实现最终一致性：可按批次进行消息处理，并保证最终一致性。支持最终一致性的MQ可以用来处理对延迟非敏感的分布式事务场景。相对于较笨重的分布式事务，其不失为较优的处理方式。</li><li>广播：消息队列的基础功能。</li><li>错峰与流控：通过中间件系统实现。</li></ol><p><a href="https://blog.csdn.net/cws1214/article/details/52922267" target="_blank" rel="noopener">文章参考</a></p><blockquote><p>消息队列并不是万能的：<br>对于需要强事务保证，而且对延迟敏感事务，RPC是由于消息队列MQ的。</p></blockquote><h3 id="消息队列特性"><a href="#消息队列特性" class="headerlink" title="消息队列特性"></a>消息队列特性</h3><ol><li>业务无关：只做消息分发；</li><li>FIFO：与缓存区Buffer的本质区别，即先投递先到达；</li><li>容灾：结点的动态增删和消息的持久化</li><li>性能：吞吐量提升，系统内部通信效率提高。</li></ol><h3 id="消息队列举例"><a href="#消息队列举例" class="headerlink" title="消息队列举例"></a>消息队列举例</h3><p>Kafka<br>RabbitMQ<br>ActiveMQ<br>RocketMQ<br>等</p><hr><h4 id="初识Kafka"><a href="#初识Kafka" class="headerlink" title="初识Kafka"></a>初识Kafka</h4><p>Kafka是Apache基金会下的一个开源项目。<br>是一个高性能跨语言的分布式发布订阅（PUB/SUB）的消息队列系统。<br>其处理流程图为;</p><p><img src="/2018/08/03/消息队列/队列-Kafka.png" alt="图示"></p><h4 id="Kafka特性"><a href="#Kafka特性" class="headerlink" title="Kafka特性"></a>Kafka特性</h4><ol><li>可快速持久化。通过O(1)的磁盘数据结构提供消息的持久化，这种结构对于即使数以TB的消息存储也能够保持长时间的稳定性能。</li><li>高吞吐量。即使是非常普通的硬件Kafka也可以支持每秒数百万的消息。</li><li>完全的分布式系统。它的Broker、Producer、Consumer都原生地支持分布式，自动支持负载均衡。</li><li>支持Hadoop的数据并行加载。可通过hadoop的并行加载机制统一处理在线、离线的消息。</li><li>支持通过Kafka服务器和消费机集群来分区消息。</li></ol><h4 id="Kafka相关术语"><a href="#Kafka相关术语" class="headerlink" title="Kafka相关术语"></a>Kafka相关术语</h4><p>对应于上图：</p><ul><li>Broker<br>Kafka集群包含一个或多个服务器，这种服务器被称为broker。</li><li>Topic<br>每条发布到Kafka集群的消息都有一个类别，这个类别被称为Topic。（物理上不同Topic的消息分开存储，逻辑上一个Topic的消息虽然保存于一个或多个broker上但用户只需指定消息的Topic即可生产或消费数据而不必关心数据存于何处）</li><li>Partition<br>Partition是物理上的概念，每个Topic包含一个或多个Partition.</li><li>Producer<br>负责发布消息到Kafka broker</li><li>Consumer<br>消息消费者，向Kafka broker读取消息的客户端。</li><li>Consumer Group<br>每个Consumer属于一个特定的Consumer Group（可为每个Consumer指定group name，若不指定group name则属于默认的group）。<br><a href="https://baike.baidu.com/item/Kafka/17930165?fr=aladdin" target="_blank" rel="noopener">参考自百度百科</a></li></ul><hr><h4 id="初识RabbitMQ"><a href="#初识RabbitMQ" class="headerlink" title="初识RabbitMQ"></a>初识RabbitMQ</h4><p>相对于其他消息队列，RabbitMQ有自己的服务器的管理界面。<br>处理流程图如下：</p><p><img src="/2018/08/03/消息队列/RabbitMQ处理流程.png" alt="图示"></p><p><strong>其中的概念说明：</strong></p><ul><li>Broker：简单来说就是消息队列服务器实体。</li><li>Exchange：消息交换机，它指定消息按什么规则，路由到哪个队列。</li><li>Queue：消息队列载体，每个消息都会被投入到一个或多个队列。</li><li>Binding：绑定，它的作用就是把exchange和queue按照路由规则绑定起来。</li><li>Routing Key：路由关键字，exchange根据这个关键字进行消息投递。</li><li>vhost：虚拟主机，一个broker里可以开设多个vhost，用作不同用户的权限分离。</li><li>producer：消息生产者，就是投递消息的程序。</li><li>consumer：消息消费者，就是接受消息的程序。</li><li>channel：消息通道，在客户端的每个连接里，可建立多个channel，每个channel代表一个会话任务。</li><li>ExchangeType（关键）：交换策略。指定exchange分发消息到哪一个或多个队列中。其有四种类型：Direct ， Fanout ， Topic ， Handers。</li></ul><p><strong>其处理流程为：</strong></p><ol><li>客户端连接到消息队列服务器，打开一个channel。</li><li>客户端声明一个exchange，并设置相关属性。</li><li>客户端声明一个queue，并设置相关属性。</li><li>客户端使用RoutingKey，在exchange和queue之间建立好绑定关系。</li><li>客户端投递消息到exchange。</li><li>exchange接收到消息后，就根据消息的key和已经设置的binding，进行消息路由，将消息投递到一个或多个队列里。</li><li>客户端只需要负责处理消息。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;消息队列已经逐步成为企业系统内部通信的核心手段。&lt;/p&gt;
    
    </summary>
    
      <category term="高并发解决方案" scheme="http://suprisemf.github.io/categories/%E9%AB%98%E5%B9%B6%E5%8F%91%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    
    
      <category term="Java" scheme="http://suprisemf.github.io/tags/Java/"/>
    
      <category term="线程高并发" scheme="http://suprisemf.github.io/tags/%E7%BA%BF%E7%A8%8B%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>高并发下缓存的常见问题</title>
    <link href="http://suprisemf.github.io/2018/08/03/%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8B%E7%BC%93%E5%AD%98%E7%9A%84%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    <id>http://suprisemf.github.io/2018/08/03/高并发下缓存的常见问题/</id>
    <published>2018-08-03T05:32:24.000Z</published>
    <updated>2018-08-03T06:18:34.232Z</updated>
    
    <content type="html"><![CDATA[<h4 id="缓存一致性"><a href="#缓存一致性" class="headerlink" title="缓存一致性"></a>缓存一致性</h4><p>当对缓存中的数据失效要求较高时，需要要求缓存中的数据与数据库中的数据保持一致，其中包括缓存结点与其副本中的数据保持一致。<br>缓存的一致性依赖于缓存的过期和更新策略。<br><a id="more"></a><br>如下图所示：</p><p><img src="/2018/08/03/高并发下缓存的常见问题/缓存一致性问题.png" alt="图示"></p><p>导致缓存一致性出现问题的情况：</p><ol><li>更新数据库成功，但更新缓存时失败。</li><li>更新缓存成功，但更新数据库时失败。</li><li>当更新数据库成功后，淘汰缓存出现失败，也会导致数据的不一致。</li><li>淘汰缓存成功，但更新数据库时出现失败，导致查询缓存时出现miss情况。</li></ol><h4 id="缓存并发问题"><a href="#缓存并发问题" class="headerlink" title="缓存并发问题"></a>缓存并发问题</h4><p>如下图示：</p><p><img src="/2018/08/03/高并发下缓存的常见问题/25.png" alt="图示"></p><p>当出现缓存不一致情况或某个缓存中数据的key更新后，线程会向数据库请求并查询数据。但发生在多并发情形下，该并发问题会对数据库造成巨大的冲击，甚至会导致缓存雪崩。<br>如图中所示，为解决缓存并发中的问题，需要对线程访问数据库时加锁：查询数据库前加锁，在重建缓存后解锁。</p><h4 id="缓存穿透问题"><a href="#缓存穿透问题" class="headerlink" title="缓存穿透问题"></a>缓存穿透问题</h4><p>如下图示：</p><p><img src="/2018/08/03/高并发下缓存的常见问题/26.png" alt="图示"></p><p>在高并发场景下，某一个缓存的key的多线程并发访问中未被命中，由于缓存架构存在访问的容错性，会允许线程从后端获取数据，从而对数据库造成巨大冲击。<br>当缓存中的key对应的数据为空时，导致大量的无效查询操作，且对数据库造成巨大压力。<br>避免缓存穿透的解决方案：</p><ol><li>对查询结果为空的对象也进行缓存：如果查询的集合数据类型为null，要转换为空的集合；如果缓存时单个对象的null，需要通过字段标识进行区分，避免null的出现。同时需要保持缓存的时效性。实现简单，适用于命中率不高但更新频繁的场景。</li><li>单独过滤处理：对所有可能数据为空的key划分统一的区域存放，并在请求前进行拦截。实现较复杂，适用于命中率不高且更新不频繁的场景。</li></ol><h4 id="缓存雪崩现象"><a href="#缓存雪崩现象" class="headerlink" title="缓存雪崩现象"></a>缓存雪崩现象</h4><blockquote><p>缓存的颠簸（抖动）问题：是一种轻微的缓存雪崩现象，但仍会降低系统性能，并对系统稳定造成巨大的影响。一般是由缓存结点的故障导致。也需要一致性hash算法解决。</p></blockquote><p>由于缓存的问题，导致大量的请求到达后端的数据库，从而导致数据库崩溃，甚至整个系统崩溃。<br>导致缓存雪崩的情况有：缓存并发问题、缓存穿透、缓存抖动等。如：一个时间点内，缓存中的数据周期性地集中失效，也可能导致雪崩。其中可随机性地设置缓存的失效过期时间，避免集中失效。</p><h4 id="推荐文章"><a href="#推荐文章" class="headerlink" title="推荐文章"></a>推荐文章</h4><p><a href="https://www.imooc.com/article/20918" target="_blank" rel="noopener">Redis在股票分时K线图计算的实践</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;缓存一致性&quot;&gt;&lt;a href=&quot;#缓存一致性&quot; class=&quot;headerlink&quot; title=&quot;缓存一致性&quot;&gt;&lt;/a&gt;缓存一致性&lt;/h4&gt;&lt;p&gt;当对缓存中的数据失效要求较高时，需要要求缓存中的数据与数据库中的数据保持一致，其中包括缓存结点与其副本中的数据保持一致。&lt;br&gt;缓存的一致性依赖于缓存的过期和更新策略。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="高并发解决方案" scheme="http://suprisemf.github.io/categories/%E9%AB%98%E5%B9%B6%E5%8F%91%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    
    
      <category term="Java" scheme="http://suprisemf.github.io/tags/Java/"/>
    
      <category term="线程高并发" scheme="http://suprisemf.github.io/tags/%E7%BA%BF%E7%A8%8B%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>缓存之初识Redis</title>
    <link href="http://suprisemf.github.io/2018/08/03/%E7%BC%93%E5%AD%98%E4%B9%8B%E5%88%9D%E8%AF%86Redis/"/>
    <id>http://suprisemf.github.io/2018/08/03/缓存之初识Redis/</id>
    <published>2018-08-03T05:25:16.000Z</published>
    <updated>2018-08-03T05:26:45.438Z</updated>
    
    <content type="html"><![CDATA[<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>Redis即<strong>Re</strong>mote <strong>Di</strong>ctionary <strong>S</strong>ervice的简称，即远程字典服务。<br>它是一个远程的非关系型内存数据库。性能强劲。具有复制特性，以及为解决数据而生的独一无二的数据模型：可以存储键值对、以及五种不同类型的值之间的映射。并提供将内存中数据持久化到硬盘功能。可以使用复制特性扩展读性能；可以使用客户端分片扩展写性能。<br><a id="more"></a><br>如下图所示：</p><p><img src="/2018/08/03/缓存之初识Redis/Redis.png" alt="图示"></p><h4 id="Redis特点"><a href="#Redis特点" class="headerlink" title="Redis特点"></a>Redis特点</h4><ol><li>支持数据的持久化，将内存中数据持久化到硬盘，重启后可以再次加载至内存。</li><li>支持上图中string、hash、list、set、sorted set等数据类型。</li><li>支持数据的备份，即master-slave主从数据备份。</li><li>功能强大：</li></ol><ul><li>性能极高：读取速度高达11W/s，写速度高达8.1W/s（官方数据）。</li><li>支持丰富的数据类型。</li><li>其操作均具有原子性，包括多个操作后另外操作的原子性。</li><li>支持publish、subscribe、通知、key过期等等功能。</li></ul><h4 id="Redis适用场景"><a href="#Redis适用场景" class="headerlink" title="Redis适用场景"></a>Redis适用场景</h4><ol><li>当需要取出n个最新数据的操作时。</li><li>当需要实现排行榜类似的应用时。</li><li>当需要精准设定过期时间的应用时。</li><li>当需要使用计数器的应用时。</li><li>当需要做唯一性检查时。</li><li>当需要获取某一时间段内所有数据排头的数据时。</li><li>实时系统。</li><li>垃圾系统。</li><li>使用pub、sub构建消息系统。</li><li>构建队列系统。</li><li>实现最基础的缓存功能时。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h4&gt;&lt;p&gt;Redis即&lt;strong&gt;Re&lt;/strong&gt;mote &lt;strong&gt;Di&lt;/strong&gt;ctionary &lt;strong&gt;S&lt;/strong&gt;ervice的简称，即远程字典服务。&lt;br&gt;它是一个远程的非关系型内存数据库。性能强劲。具有复制特性，以及为解决数据而生的独一无二的数据模型：可以存储键值对、以及五种不同类型的值之间的映射。并提供将内存中数据持久化到硬盘功能。可以使用复制特性扩展读性能；可以使用客户端分片扩展写性能。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="高并发解决方案" scheme="http://suprisemf.github.io/categories/%E9%AB%98%E5%B9%B6%E5%8F%91%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    
    
      <category term="Java" scheme="http://suprisemf.github.io/tags/Java/"/>
    
      <category term="线程高并发" scheme="http://suprisemf.github.io/tags/%E7%BA%BF%E7%A8%8B%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>缓存之特征、场景和组件介绍</title>
    <link href="http://suprisemf.github.io/2018/08/03/%E7%BC%93%E5%AD%98%E4%B9%8B%E7%89%B9%E5%BE%81%E3%80%81%E5%9C%BA%E6%99%AF%E5%92%8C%E7%BB%84%E4%BB%B6%E4%BB%8B%E7%BB%8Da/"/>
    <id>http://suprisemf.github.io/2018/08/03/缓存之特征、场景和组件介绍a/</id>
    <published>2018-08-03T03:30:39.000Z</published>
    <updated>2018-08-03T05:18:15.952Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>此处的缓存非彼之计算机缓存。该缓存主要是降低高并发对数据库冲击，提高数据访问速度、查询命中的数据库缓存。当然也有静态缓存、动态缓存。(这些我只知其名)<br><a id="more"></a></p><p><img src="/2018/08/03/缓存之特征、场景和组件介绍a/19.png" alt="图示"></p><h3 id="缓存的特征"><a href="#缓存的特征" class="headerlink" title="缓存的特征"></a>缓存的特征</h3><ol><li>命中率（高并发中的重要指标）：简单表示为：命中数/(命中数+未命中数)；未命中即未通过缓存获取到想要的数据，可能数据不存在或缓存已过期。</li><li>最大元素（或最大空间）：缓存中可以存放的元素数量。一旦缓存中的数据数量超过该值，会触发缓存的清除策略。</li><li>清空策略：FIFO、LFU（使用频率最小策略）、LRU（最近最少被使用策略）、过期时间、随机清除等。<blockquote><ul><li>FIFO是first in first out，在缓存中最先被创建的数据再被清除时会被优先考虑清除。适用于对数据的实时性要求较高的场景，保证最新的数据可用。</li><li>LFU是无理数据是否过期，通过比较各数据的命中率，优先清除命中率最低的数据。</li><li>LRU是无论数据是否过期，通过比较数据最近一次被使用（即调用get()）的时间戳，优先清除距今最久的数据，以保证热点数据的可用性。（多数缓存框架都采用LRU策略）</li><li>过期时间策略是，通过比较过期时间清除过期时间最长的数据，或通过过期时间，清除最近要过期的数据。</li></ul></blockquote></li></ol><hr><h3 id="缓存命中率的影响因素"><a href="#缓存命中率的影响因素" class="headerlink" title="缓存命中率的影响因素"></a>缓存命中率的影响因素</h3><ol><li>业务场景和业务需求：显然，缓存是为了减轻读数据操作的缓冲方式。</li></ol><ul><li>适用于读多写少的场景。</li><li>对数据的实时性要求不高。因为数据缓存的时间越长，数据的命中率越高。</li></ul><ol start="2"><li>缓存的设计：粒度和策略</li></ol><ul><li>缓存的粒度越小，灵活度高，命中率越高；粒度越小，越不易被其他操作（修改）涉及到，保存在缓存中的时间越久，越易被命中。</li><li>当缓存中的数据变化时，直接更新缓存中的相应数据（虽然一定程度上会提高系统复杂度），而不是移除或设置数据过期，会提高缓存的命中率。</li></ul><ol start="3"><li>缓存容量和基础设施。</li></ol><ul><li>当然，缓存容量越大，缓存命中率越高。</li><li>缓存的技术选型：采用应用内置的内地缓存容易造成单机瓶颈，而采用分布式缓存则具有更好的拓展性，伸缩性。</li></ul><ol start="4"><li>不同的缓存框架中的缓存命中率也不尽相同。</li><li>当缓存结点发生故障，需要避免缓存失效并最大程度地减少影响。可通过一致性hash算法或结点冗余方式避免结点故障。</li><li>多线程并发越高，缓存的效益越高，即收益越高，即使缓存时间很短。</li></ol><hr><h3 id="提高缓存命中率的方法"><a href="#提高缓存命中率的方法" class="headerlink" title="提高缓存命中率的方法"></a>提高缓存命中率的方法</h3><ol><li>要求应用尽可能地通过缓存访问数据，避免缓存失效。</li><li>结合上面介绍的命中率影响因素：缓存粒度、策略、容量、技术选型等结合考虑。</li></ol><hr><h3 id="缓存的分类"><a href="#缓存的分类" class="headerlink" title="缓存的分类"></a>缓存的分类</h3><p>根据缓存和应用的耦合度进行分类：</p><ol><li>本地缓存：</li></ol><ul><li>指应用中的缓存组件，主要通过编程实现（使用成员变量、局部变量、静态变量）或使用现成的Guava Cache框架。</li><li>优点：应用和cache都在同一个进程内部。请求缓存速度快，无网络开销。单机应用中，不需要集群支持时，或集群情况下，各结点不需要互相通知时，适合使用本地缓存。</li><li>缺点：应用和cache的耦合度高，各应用间无法共享缓存，导致各结点或单机应用需要维护自己的缓存，可能会造成内存浪费。</li></ul><ol start="2"><li>分布式缓存：</li></ol><ul><li>指的是应用分离的缓存组件或服务，主要现在流行的有：Memcache、Redis。</li><li>优点：自己本身就是一个独立的服务，与本地应用是隔离的，多个应用可以共享缓存；</li></ul><hr><h4 id="Guava-Cache介绍"><a href="#Guava-Cache介绍" class="headerlink" title="Guava Cache介绍"></a>Guava Cache介绍</h4><p>它是本地缓存的实现框架。<br>原理图如下：</p><p><img src="/2018/08/03/缓存之特征、场景和组件介绍a/20.png" alt="图示"></p><p>可以看出来，它的实现原理类似ConcurrentHashMap，使用多个segment细粒度锁，既保证了线程安全，又支持高并发场景需求。该类Cache类似于一个Map，也是存储键值对的集合，但它还需要处理缓存过期、动态加载等算法逻辑；根据面向对象的思想，它还需要做方法与数据关联性的封装。<br>Guava Cache实现的主要功能有：自动将结点加入到缓存结构中；当缓存中结点超过设置的最大元素值时，使用LRU算法实现缓存清除；它缓存的key封装在weakReference（弱引用）中，它缓存的value缓存在weakReference（弱引用）或softReference（软引用）中；它可以统计缓存中各数据的命中率、异常率、未命中率等数据；</p><hr><h4 id="Memcache"><a href="#Memcache" class="headerlink" title="Memcache"></a>Memcache</h4><p>它是一个高效的分布式内存cache，是众多广泛应用的开源分布式缓存的框架之一。</p><p>内存结构图如下：</p><p><img src="/2018/08/03/缓存之特征、场景和组件介绍a/memcache结构.png" alt="图示"></p><p>其中涉及到四个部分：按部分作用区域由大到小分别为</p><ol><li>slab_class：板层类。</li><li>slab：板层。</li><li>page：页。</li><li>chunk：块。是真正存放数据的地方。</li></ol><ul><li>同一个slab内的chunk的大小是固定的。而具有相同chunk的slab被分组为chunk_slab。</li><li>Memcache的内存的分配器成为allocator。其中slab的数量有限，与启动参数的配置有关。</li><li>其中的value总是会被存放到与value占用空间大小最接近的chunk的slab中，以在不降低系统性能情况下节约内存空间。</li><li>在创建slab时，首先申请内存；其中是以page为单位分配给slab空间，其中，一般page为1M大小；page按照该slab的chunk大小进行切分并形成数组。</li></ul><p>Memcache处理原理图如下：</p><p><img src="/2018/08/03/缓存之特征、场景和组件介绍a/Memcache原理图1.png" alt="图示"></p><p>它本身不提供分布式的解决方案。在服务端，Memcache的集群环境实际上就是一个个Memcache服务器的堆积。它cache的分布式机制是在客户端实现。通过客户端的路由来处理，以达到分布式解决方案的目的。</p><p>客户端做路由的原理：</p><ul><li>客户端采用hash一致性算法，上图中右侧即是其路由的计算方法。</li><li>相对于一般的hash算法，如取模方式，它除了计算key的hash外，还计算每一个server的hash值，最后将这些hash值映射到一个指定域上，如图中的0-2^32。</li><li>通过寻找大于key的hash值的最小server作为存储该key的目标server,如果未找到则直接将具有最小hash值的server作为目标server。</li><li>该机制一定程度上解决了扩容问题。增加或删除某个结点对于该集群来说不会有大影响。</li><li>最近版本中，Memcache又增加了虚拟结点的设计，进一步提高系统可用性</li></ul><h5 id="Memcache的内存分配和回收算法"><a href="#Memcache的内存分配和回收算法" class="headerlink" title="Memcache的内存分配和回收算法"></a>Memcache的内存分配和回收算法</h5><ol><li>在Memcache的内存分配中，chunk空间并不会被value完全占用，总会有内存浪费；</li><li>Memcache的LRU回收算法不是针对全局的，而是slab的。</li><li>Memcache中对允许存放的value占用空间大小有限制。因为内存空间分配是slab以page为单位被分配空间，而page大小规定最大为1M。</li></ol><h5 id="Memcache的限制和特性"><a href="#Memcache的限制和特性" class="headerlink" title="Memcache的限制和特性"></a>Memcache的限制和特性</h5><ol><li>Memcache对存储的item数量没有限制；</li><li>Memcache单进程在32位机器上限制的内存大小为2G，即2的32次方的bit。而64位机器则没有内存大小限制。</li><li>Memcache的key最大为250个字节；若超过则无法存储。其可存储的value最大为1M，即page最大可分配的大小，此时page中只分配了（形成）一个chunk。</li><li>Memcache的服务器端是非安全的。当已知一个Memcache结点，外部进入后可通过flushAll命令，使已经存在的键值对立即失效。</li><li>Memcache不能遍历其中存储的所有item。因为该操作会使其他的访问、创建等操作阻塞，且该进程十分缓慢。</li><li>Memcache的高性能来源于两个阶段的hash结构：第一个是客户端（该hash算法根据key值算出一个结点）；第二个是服务端（通过一个内部的hash算法，查找真正的item并返回给客户端）。</li><li>Memcache是一个非阻塞的基于事件的服务程序。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;此处的缓存非彼之计算机缓存。该缓存主要是降低高并发对数据库冲击，提高数据访问速度、查询命中的数据库缓存。当然也有静态缓存、动态缓存。(这些我只知其名)&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="高并发解决方案" scheme="http://suprisemf.github.io/categories/%E9%AB%98%E5%B9%B6%E5%8F%91%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    
    
      <category term="Java" scheme="http://suprisemf.github.io/tags/Java/"/>
    
      <category term="线程高并发" scheme="http://suprisemf.github.io/tags/%E7%BA%BF%E7%A8%8B%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>高并发之扩容思路</title>
    <link href="http://suprisemf.github.io/2018/08/03/%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B9%8B%E6%89%A9%E5%AE%B9%E6%80%9D%E8%B7%AF/"/>
    <id>http://suprisemf.github.io/2018/08/03/高并发之扩容思路/</id>
    <published>2018-08-03T02:59:18.000Z</published>
    <updated>2018-08-03T03:00:17.381Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>了解Java 内存结构的伙伴应该都知道 , 每个线程都有自己的工作内存, 占用内存大小取决于工作内存里变量的多少与大小 , 单个线程占用内存通常不会很大, 但是随着并发的线程不断的增加 , 从成百上千, 甚至几十万 , 占用的内存就会越来越多.这时候可能就要考虑给系统扩容了 , 简单点的 升级内存, 复杂点的 , 增加服务器 , 分担压力。<br><a id="more"></a></p><h3 id="扩容方向"><a href="#扩容方向" class="headerlink" title="扩容方向"></a>扩容方向</h3><ol><li>垂直扩容：也叫纵向扩容，提高系统部件处理能力；</li><li>水平扩容：也叫横向扩容，增加系统内部成员数量。</li></ol><h4 id="数据库扩容"><a href="#数据库扩容" class="headerlink" title="数据库扩容"></a>数据库扩容</h4><ol><li>读操作扩展：增加memcache、Redis、CDN等缓存，或使用关系型数据库。<blockquote><p>假如网站是读操作比较多，比如博客这类。通过通过mysql进行垂直扩展是个不错的选择，并且结合memcache、redis、CDN等构建一个健壮的缓存系统。如果系统超负荷运行，将更多的数据放在缓存中来缓解系统的读压力。采用水平扩容没有太大的意义，因为性能的瓶颈不在写操作，所以不需要实时去完成，用更多的服务器来分担压力性价比太低。所以针对单个系统去强化它的读性能就可以了</p></blockquote></li><li>写操作扩展：Cassandra、Hbase等<blockquote><p>假如写操作比较多，比如大型网站的交易系统，可考虑可水平扩展的数据存储方式，比如Cassandra、Hbase等。和大多数的关系型数据库不同，这种数据存储会随着增长增加更多的节点。也可以考虑垂直扩容提升单个数据库的性能，但会发现资金与硬盘的IO能力是有限的，所以需要增加更多数据库来分担写的压力。</p></blockquote></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;了解Java 内存结构的伙伴应该都知道 , 每个线程都有自己的工作内存, 占用内存大小取决于工作内存里变量的多少与大小 , 单个线程占用内存通常不会很大, 但是随着并发的线程不断的增加 , 从成百上千, 甚至几十万 , 占用的内存就会越来越多.这时候可能就要考虑给系统扩容了 , 简单点的 升级内存, 复杂点的 , 增加服务器 , 分担压力。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="高并发解决方案" scheme="http://suprisemf.github.io/categories/%E9%AB%98%E5%B9%B6%E5%8F%91%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    
    
      <category term="Java" scheme="http://suprisemf.github.io/tags/Java/"/>
    
      <category term="线程高并发" scheme="http://suprisemf.github.io/tags/%E7%BA%BF%E7%A8%8B%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>HashMap源码分析</title>
    <link href="http://suprisemf.github.io/2018/08/03/HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://suprisemf.github.io/2018/08/03/HashMap源码分析/</id>
    <published>2018-08-03T02:52:32.000Z</published>
    <updated>2018-08-03T02:52:57.949Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>关于HashMap的解析我有在我的开源中国博客里介绍过，<br>☞ <a href="https://my.oschina.net/u/3805464/blog/1825492" target="_blank" rel="noopener">传送门</a></p></blockquote><p>文章转过来挺麻烦的，而且自认为做的也不够好。以后等完善了解更多的HashMap知识后会再更的~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;关于HashMap的解析我有在我的开源中国博客里介绍过，&lt;br&gt;☞ &lt;a href=&quot;https://my.oschina.net/u/3805464/blog/1825492&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;传送门
      
    
    </summary>
    
      <category term="Java之并发编程" scheme="http://suprisemf.github.io/categories/Java%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java" scheme="http://suprisemf.github.io/tags/Java/"/>
    
      <category term="并发编程" scheme="http://suprisemf.github.io/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>ConcurrentHashMap</title>
    <link href="http://suprisemf.github.io/2018/08/03/ConcurrentHashMap/"/>
    <id>http://suprisemf.github.io/2018/08/03/ConcurrentHashMap/</id>
    <published>2018-08-03T02:40:48.000Z</published>
    <updated>2018-08-03T02:42:29.493Z</updated>
    
    <content type="html"><![CDATA[<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><h4 id="JDK-1-7中的ConcurrentHashMap"><a href="#JDK-1-7中的ConcurrentHashMap" class="headerlink" title="JDK 1.7中的ConcurrentHashMap"></a>JDK 1.7中的ConcurrentHashMap</h4><h4 id="JDK-1-8中的ConcurrentHashMap"><a href="#JDK-1-8中的ConcurrentHashMap" class="headerlink" title="JDK 1.8中的ConcurrentHashMap"></a>JDK 1.8中的ConcurrentHashMap</h4><h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><p>妈耶~ 这个部分内容真的很多~ 先挖个坑，这个文章全部写完后再补上~~</p><p><a href="https://javadoop.com/post/hashmap" target="_blank" rel="noopener">强力推荐阅读</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h4&gt;&lt;h4 id=&quot;JDK-1-7中的ConcurrentHashMap&quot;&gt;&lt;a href=&quot;#JDK-1-7中的ConcurrentHashMap&quot;
      
    
    </summary>
    
      <category term="Java之并发编程" scheme="http://suprisemf.github.io/categories/Java%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java" scheme="http://suprisemf.github.io/tags/Java/"/>
    
      <category term="并发编程" scheme="http://suprisemf.github.io/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>简浅说之Spring与线程安全</title>
    <link href="http://suprisemf.github.io/2018/08/03/%E7%AE%80%E6%B5%85%E8%AF%B4%E4%B9%8BSpring%E4%B8%8E%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/"/>
    <id>http://suprisemf.github.io/2018/08/03/简浅说之Spring与线程安全/</id>
    <published>2018-08-03T02:34:44.000Z</published>
    <updated>2018-08-03T02:35:18.458Z</updated>
    
    <content type="html"><![CDATA[<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>Spring作为一个IoC容器，管理了Spring中所有的bean，但它并不保证其bean的线程安全，需要开发者自己实现线程安全。<br><a id="more"></a></p><h4 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h4><p>Spring为每个Bean提供了scope属性用来表示该Bean的作用域，指定该Bean的生命周期   ：singleton或prototype。</p><ol><li>当scope为singleton（默认值）时，该Bean第一次被创建时，被注入到IoC容器中，并一直作用到应用结束，即与IoC容器的生命周期一致。</li><li>当scope为prototype时，该Bean每一次被创建时，都会被注入到IoC容器中。</li></ol><p>Spring中的对象都是无状态对象：不会因为多线程间调用而发生状态改变，即线程安全。其非常适合Spring的默认scope：singleton单例。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h4&gt;&lt;p&gt;Spring作为一个IoC容器，管理了Spring中所有的bean，但它并不保证其bean的线程安全，需要开发者自己实现线程安全。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java之并发编程" scheme="http://suprisemf.github.io/categories/Java%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java" scheme="http://suprisemf.github.io/tags/Java/"/>
    
      <category term="并发编程" scheme="http://suprisemf.github.io/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>多线程并发的最佳实践总结</title>
    <link href="http://suprisemf.github.io/2018/08/03/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93/"/>
    <id>http://suprisemf.github.io/2018/08/03/多线程并发的最佳实践总结/</id>
    <published>2018-08-03T01:53:38.000Z</published>
    <updated>2018-08-03T02:34:12.868Z</updated>
    
    <content type="html"><![CDATA[<h4 id="使用本地变量"><a href="#使用本地变量" class="headerlink" title="使用本地变量"></a>使用本地变量</h4><ol><li>优先考虑使用本地变量，避免创建一个类或实例的变量；</li><li>这样可以节省内存，并进行复用；<h4 id="使用不可变类"><a href="#使用不可变类" class="headerlink" title="使用不可变类"></a>使用不可变类</h4>降低代码中需要的同步变量，充分利用JVM提供的功能。</li></ol><a id="more"></a><h4 id="最小化锁的作用域范围"><a href="#最小化锁的作用域范围" class="headerlink" title="最小化锁的作用域范围"></a>最小化锁的作用域范围</h4><p>大名鼎鼎的阿姆达尔定律，表达式为：</p><p>S=1/(1-a+a/n)</p><p>其中：<br>a是并行计算部分所占的比例，<br>n是并行计算所处理的结点个数，<br>S是最终的加速比。</p><blockquote><p>当1-a=0时，(即没有串行，只有并行)最大加速比s=n；当a=0时（即只有串行，没有并行），最小加速比s=1；当n→∞时，极限加速比s→ 1/（1-a），这也就是加速比的上限。例如，若串行代码占整个代码的25%，则并行处理的总体性能不可能超过4。</p></blockquote><h4 id="使用线程池的Executor"><a href="#使用线程池的Executor" class="headerlink" title="使用线程池的Executor"></a>使用线程池的Executor</h4><p>避免new Thread创建线程。通过线程池的管理，尅提高线程的复用性（避免新建线程的昂贵的资源消耗），简化线程生命周期的管理。</p><h4 id="避免使用线程的wait-和notify"><a href="#避免使用线程的wait-和notify" class="headerlink" title="避免使用线程的wait()和notify()"></a>避免使用线程的wait()和notify()</h4><p>优先考虑使用线程的辅助工具类，宁可使用同步也不使用线程的wait()和notify()方法。因为线程间的通讯会消耗较多的系统资源。</p><h4 id="使用BlockingQueue实现生产者-消费者模式"><a href="#使用BlockingQueue实现生产者-消费者模式" class="headerlink" title="使用BlockingQueue实现生产者-消费者模式"></a>使用BlockingQueue实现生产者-消费者模式</h4><p>阻塞队列是生产者-消费者模式的最好的实现方式，不仅包括单个生产者单个消费者，还支持多个生产者多个消费者情况。</p><h4 id="优先使用并发集合"><a href="#优先使用并发集合" class="headerlink" title="优先使用并发集合"></a>优先使用并发集合</h4><p>JDK提供了ConcurrentHashMap、CopyOnWriteArrayList、CopyOnWriteArraySet、BlockingQueue中的Deque和BlockingDeque五大并发集合，他们有着较好性能；宁使用该并发集合，而避免使用synchronizedXXX的锁同步集合。</p><h4 id="使用Semaphore创建有界的访问"><a href="#使用Semaphore创建有界的访问" class="headerlink" title="使用Semaphore创建有界的访问"></a>使用Semaphore创建有界的访问</h4><p>为了建立可靠稳定的系统，对数据库、文件系统、SOCKET的访问需进行有界的控制。</p><h4 id="尽量减少同步方法使用"><a href="#尽量减少同步方法使用" class="headerlink" title="尽量减少同步方法使用"></a>尽量减少同步方法使用</h4><ol><li>宁可使用同步代码块，也要尽量减少同步方法使用。</li><li>其中synchronized关键字标识方法时，所有调用到该方法的域都会被JVM进行锁定监督.</li><li>使用synchronized 同步代码块只会锁定一个对象，而不会将当前整个方法锁定；如果更改共同的变量或类的字段，优先选择原子性变量，其次使用volatile。如果你需要互斥锁，可以考虑使用ReentrantLock。</li></ol><h4 id="避免使用静态变量"><a href="#避免使用静态变量" class="headerlink" title="避免使用静态变量"></a>避免使用静态变量</h4><p>静态变量在多线程并发环境中会造成较多的问题。当使用静态变量时，优先将其指定为final变量，若用其来保存集合Collection变量，则考虑使用只读集合。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;使用本地变量&quot;&gt;&lt;a href=&quot;#使用本地变量&quot; class=&quot;headerlink&quot; title=&quot;使用本地变量&quot;&gt;&lt;/a&gt;使用本地变量&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;优先考虑使用本地变量，避免创建一个类或实例的变量；&lt;/li&gt;
&lt;li&gt;这样可以节省内存，并进行复用；&lt;h4 id=&quot;使用不可变类&quot;&gt;&lt;a href=&quot;#使用不可变类&quot; class=&quot;headerlink&quot; title=&quot;使用不可变类&quot;&gt;&lt;/a&gt;使用不可变类&lt;/h4&gt;降低代码中需要的同步变量，充分利用JVM提供的功能。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Java之并发编程" scheme="http://suprisemf.github.io/categories/Java%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java" scheme="http://suprisemf.github.io/tags/Java/"/>
    
      <category term="并发编程" scheme="http://suprisemf.github.io/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>死锁</title>
    <link href="http://suprisemf.github.io/2018/08/03/%E6%AD%BB%E9%94%81/"/>
    <id>http://suprisemf.github.io/2018/08/03/死锁/</id>
    <published>2018-08-03T01:31:43.000Z</published>
    <updated>2018-08-03T01:34:05.535Z</updated>
    
    <content type="html"><![CDATA[<h4 id="死锁概述"><a href="#死锁概述" class="headerlink" title="死锁概述"></a>死锁概述</h4><p>死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。</p><a id="more"></a><h4 id="死锁发生须具备的条件"><a href="#死锁发生须具备的条件" class="headerlink" title="死锁发生须具备的条件"></a>死锁发生须具备的条件</h4><ol><li>互斥条件：进程间的锁具有排他性。</li><li>请求和保持条件：一个进程已经持有一个资源，但仍然提出对另一个资源的请求。</li><li>不剥夺条件：一个进程所持有的资源不能在自己使用完之前被系统剥夺，需自己释放。</li><li>环路等待条件：由于第2条件，多个进程间的请求形成环路。</li></ol><h4 id="演示例子"><a href="#演示例子" class="headerlink" title="演示例子"></a>演示例子</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLock</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//静态对象是类的所有对象共享的</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object o1 = <span class="keyword">new</span> Object(), o2 = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"flag:&#123;&#125;"</span>, flag);</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (o1) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (o2) &#123;</span><br><span class="line">                    log.info(<span class="string">"1"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (o2) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (o1) &#123;</span><br><span class="line">                    log.info(<span class="string">"0"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DeadLock td1 = <span class="keyword">new</span> DeadLock();</span><br><span class="line">        DeadLock td2 = <span class="keyword">new</span> DeadLock();</span><br><span class="line">        td1.flag = <span class="number">1</span>;</span><br><span class="line">        td2.flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">new</span> Thread(td1).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(td2).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h5><p><img src="/2018/08/03/死锁/死锁运行结果.png" alt="图示"></p><p>其中出现了死锁，需要手动停止任务的执行，此时任务结束状态为：<code>Process finished with exit code -1</code></p><h5 id="例子说明"><a href="#例子说明" class="headerlink" title="例子说明"></a>例子说明</h5><blockquote><p>一个简单的死锁类：<br>当DeadLock类的对象<code>flag == 1</code>时（td1），先锁定o1,睡眠500毫秒<br>而td1在睡眠的时候另一个<code>flag == 0</code>的对象（td2）线程启动，先锁定o2,睡眠500毫秒<br>td1睡眠结束后需要锁定o2才能继续执行，而此时o2已被td2锁定；<br>td2睡眠结束后需要锁定o1才能继续执行，而此时o1已被td1锁定；<br>td1、td2相互等待，都需要得到对方锁定的资源才能继续执行，从而死锁。</p></blockquote><ol><li>构造了两个死锁实例；该实例实现了Runnable接口。</li><li>分别声明两个线程，分别在两个状态时请求另一个线程中的对象。</li><li>其中锁定线程休眠500毫秒：可以为另一个线程提供充足的时间来对该线程中的对象进行请求。</li><li>当在main函数中创建两个死锁实例td1,td2，并给定flag状态后：td1,td2都处于可执行状态，但JVM线程调度先执行哪个线程是不确定的。（对应于前后例子运行结果中flag-0或1的顺序）</li><li>死锁的实现：使用两层synchronized锁进行对象资源锁定，其中当两个线程分别获得第一层锁，在分别获取两一个线程的第二层锁时出现死锁。</li><li>当将类中的两个休眠时间<strong>都</strong>去掉后，出现正常的执行结束：<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">09<span class="selector-pseudo">:40</span><span class="selector-pseudo">:45.688</span> <span class="selector-attr">[Thread-1]</span> <span class="selector-tag">INFO</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.deadLock</span><span class="selector-class">.DeadLock</span> <span class="selector-tag">-</span> <span class="selector-tag">flag</span><span class="selector-pseudo">:0</span></span><br><span class="line">09<span class="selector-pseudo">:40</span><span class="selector-pseudo">:45.688</span> <span class="selector-attr">[Thread-0]</span> <span class="selector-tag">INFO</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.deadLock</span><span class="selector-class">.DeadLock</span> <span class="selector-tag">-</span> <span class="selector-tag">flag</span><span class="selector-pseudo">:1</span></span><br><span class="line">09<span class="selector-pseudo">:40</span><span class="selector-pseudo">:45.696</span> <span class="selector-attr">[Thread-1]</span> <span class="selector-tag">INFO</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.deadLock</span><span class="selector-class">.DeadLock</span> <span class="selector-tag">-</span> 0</span><br><span class="line">09<span class="selector-pseudo">:40</span><span class="selector-pseudo">:45.696</span> <span class="selector-attr">[Thread-0]</span> <span class="selector-tag">INFO</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.deadLock</span><span class="selector-class">.DeadLock</span> <span class="selector-tag">-</span> 1</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">Process</span> <span class="selector-tag">finished</span> <span class="selector-tag">with</span> <span class="selector-tag">exit</span> <span class="selector-tag">code</span> 0</span><br></pre></td></tr></table></figure></li></ol><h4 id="死锁的避免策略"><a href="#死锁的避免策略" class="headerlink" title="死锁的避免策略"></a>死锁的避免策略</h4><ol><li>调整加锁顺序；避免交叉地对对象加锁，而应按序加锁。</li><li>加锁时限：将synchronized锁换成类似重入锁Reentrant具有锁定时间的锁机制。</li><li>死锁检测：是一种较好的死锁预防机制，但是实现较困难。<blockquote><p>当为对象加锁不可避免地会出现交叉，且锁超时也不可行时，使用死锁检测机制。</p></blockquote></li></ol><ul><li>每当一个线程获得了锁，会在线程和锁相关的数据结构中将其作为标记记下来；每当有其他线程请求该锁时也要记下相应标记；当一个线程请求锁失败时，该线程应根据锁之间的关系判断是否有死锁发生，并响应出对应的处理。</li></ul><h5 id="死锁发生时，线程该做哪些事？"><a href="#死锁发生时，线程该做哪些事？" class="headerlink" title="死锁发生时，线程该做哪些事？"></a>死锁发生时，线程该做哪些事？</h5><ol><li>当死锁发生时，释放所有的锁，并回退；并等待一个随机的时间后，进行重试（即回退等待）。但重试中仍有可能会发生死锁。</li><li>上述第一条，在重试中仍发生死锁，还可以提前为线程设定优先级：使回退等待中的一部分（非全部）释放锁并回退，其他的线程继续持有锁。</li><li>为了避免上述第二条中因线程拥有固定不变的优先级可能导致的线程饥饿等情况，应采取一定的策略，设置随机的（或其他更好的方式）线程优先级。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;死锁概述&quot;&gt;&lt;a href=&quot;#死锁概述&quot; class=&quot;headerlink&quot; title=&quot;死锁概述&quot;&gt;&lt;/a&gt;死锁概述&lt;/h4&gt;&lt;p&gt;死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。&lt;/p&gt;
    
    </summary>
    
      <category term="Java之并发编程" scheme="http://suprisemf.github.io/categories/Java%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java" scheme="http://suprisemf.github.io/tags/Java/"/>
    
      <category term="并发编程" scheme="http://suprisemf.github.io/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>线程池</title>
    <link href="http://suprisemf.github.io/2018/08/03/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>http://suprisemf.github.io/2018/08/03/线程池/</id>
    <published>2018-08-03T01:14:11.000Z</published>
    <updated>2018-08-03T01:29:35.788Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Thread类"><a href="#Thread类" class="headerlink" title="Thread类"></a>Thread类</h3><h4 id="new-Thread的弊端"><a href="#new-Thread的弊端" class="headerlink" title="new Thread的弊端"></a>new Thread的弊端</h4><ol><li>每次new Thread新建对象，性能差。</li><li>线程缺乏统一的管理，可能无限制地新建线程，相互竞争，有可能占用更多的系统资源导致宕机或者OOM。</li><li>缺少更多高级功能，如：更多执行、定期执行，线程中断等。</li></ol><a id="more"></a><hr><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><h4 id="线程池的好处"><a href="#线程池的好处" class="headerlink" title="线程池的好处"></a>线程池的好处</h4><ol><li>重用存在的线程，减少对象的创建、销毁的开销，性能好。</li><li>可以有效地控制最大并发的线程数量，提高系统资源利用率，同时可以避免过多的资源竞争，避免阻塞。</li><li>提供定期执行、定时执行、单线程、并发控制等功能。</li></ol><h4 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h4><h5 id="初始化的参数"><a href="#初始化的参数" class="headerlink" title="初始化的参数"></a>初始化的参数</h5><ol><li>corePoolSize：核心线程数量；</li><li>maximumPoolSize：最大线程数量；</li><li>workQueue：阻塞队列，存储等待执行的任务，对线程池的运行过程有重大影响。</li><li>keepAliveTime：线程中无任务空转，但仍保持存活的延期时间。当目前线程池中的线程数量大于等于corePoolSize时才有效。</li><li>unit：是keepAliveTime的时间单位。</li><li>threadFactory：即用来创建线程的工厂。未指定则会使用默认的threadFactory来创建线程：线程优先级相同、非守护线程、默认递增的名字。</li><li>rejectedExecutionHandler：拒绝策略。</li></ol><blockquote><p>四种拒绝策略：</p><ol><li>ThreadPoolExecutor.AbortPolicy：默认策略，直接抛出异常。</li><li>ThreadPoolExecutor.CallerRunsPolicy：调用目前所在的线程来执行任务。</li><li>ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列中最早的一个线程中的任务，并执行当前的任务。</li><li>ThreadPoolExecutor.DiscardPolicy：直接丢弃该任务。</li></ol></blockquote><h5 id="初始化参数间的关系"><a href="#初始化参数间的关系" class="headerlink" title="初始化参数间的关系"></a>初始化参数间的关系</h5><ol><li>当目前线程池中的线程数量小于corePoolSize时，且有新的线程创建请求时，直接创建新的线程。</li><li>当目前线程池中的线程数量大于等于corePoolSize，但小于maximumPoolSize时，若此时workQueue未满，则该任务会被放在workQueue中等待；若此时workQueue已经满了，则会为该任务直接创建新的线程。</li><li>当目前线程池中的线程数量大于maximumPoolSize时，如果workQueue未满则将线程请求将被放在阻塞队列workQueue中；如果workQueue已满，则会根据指定参数rejectHandler采用相应的拒绝策略，来处理线程请求。</li></ol><blockquote><p>workQueue是一个保存任务的阻塞队列。根据上面的三种情况，该workQueue对应的处理也有三种：</p><ol><li>直接切换：默认使用SynchronousQueue实现。</li><li>使用无界队列LinkedBlockingQueue，此时可以创建的最多线程数即是corePoolSize，maximumPoolSize则不会起作用了。</li><li>使用有界队列，常用ArrayBlockingQueue，可以指定队列的maximumPoolSize，但会使线程调度更加困难。因此推荐使用无界队列。</li></ol></blockquote><h4 id="ThreadPoolExecutor的状态"><a href="#ThreadPoolExecutor的状态" class="headerlink" title="ThreadPoolExecutor的状态"></a>ThreadPoolExecutor的状态</h4><p><img src="/2018/08/03/线程池/threadpoolexecutor状态.png" alt="图示"></p><ol><li>RUNNING:运行中。可以接受新提交的任务，或处理阻塞队列中的任务。</li><li>SHUTDOWN:关闭。不能接受新提交的任务，但可以继续处理阻塞队列中的任务。</li><li>STOP:停止。既不能接受新提交的任务，但可以继续处理阻塞队列中的任务，并中断正在进行中的线程。</li><li>TIDYING:整理中。在SHUTDOWN时，当阻塞队列为空且线程池中工作的线程数量为0时，或在STOP时，线程池中工作的线程数量为0时，转为该状态，并整理线程池中的内容。此时等待线程池被终结。</li><li>TERMINATED:TIDYING时调用terminated()方法，进入TERMINATED。即线程池被销毁。</li></ol><h4 id="ThreadPoolExecutor的方法成员"><a href="#ThreadPoolExecutor的方法成员" class="headerlink" title="ThreadPoolExecutor的方法成员"></a>ThreadPoolExecutor的方法成员</h4><p><img src="/2018/08/03/线程池/threadpoolexecutor方法.png" alt="图示"></p><ol><li>execute()：执行任务，由线程池运行。</li><li>submit()：提交任务，可以返回执行的结果。即execute()方法，配合Future的结合。</li><li>shutdown()：关闭线程池（不是立刻关闭）。不接受新提交的任务，但可以继续处理阻塞队列中的任务；当任务执行完毕才会关闭线程池。</li><li>shutdownNow()：立即关闭线程池。不接受新提交的任务，中断正在执行中的线程，丢弃阻塞队列中的任务。</li><li>getTaskCount()：返回线程池中已执行和未执行的任务总数。</li><li>getCompletedTaskCount()：返回已经执行完毕的任务数量。</li><li>getPoolSize()：返回目前线程池中的线程数量。（因存在线程间的动态切换，故返回值是近似值）</li><li>getActiveCount()：返回线程池中正在执行任务的线程数量。（因存在线程间的动态切换，故返回值是近似值）</li></ol><h4 id="ThreadPoolExecutor的类图"><a href="#ThreadPoolExecutor的类图" class="headerlink" title="ThreadPoolExecutor的类图"></a>ThreadPoolExecutor的类图</h4><p><img src="/2018/08/03/线程池/类图关系.png" alt="图示"></p><p>其中左上角部分：<br>Executor：一个运行线程任务的简单接口。<br>ExecutorService：拓展了Executor：添加了管理执行器生命周期、任务生命周期的方法。<br>ScheduledExecutorService：拓展了ExecutorService：支持Future和定期执行任务。</p><h4 id="Executors类"><a href="#Executors类" class="headerlink" title="Executors类"></a>Executors类</h4><blockquote><p>该类是针对Executor接口提供的工厂方法和工具方法。</p></blockquote><p>Executors类内部方法：</p><p><img src="/2018/08/03/线程池/executors内部方法.png" alt="图示"></p><ol><li>Executors的newCachedThreadPool()方法：创建一个容量大小可变的线程池：根据需要回收线程或新建线程。</li><li>Executors的newFixedThreadPool(int nThreads)方法，创建一个固定大小的线程池。若线程池已满则阻塞在workQueue中。</li><li>Executors的newScheduledThreadPool(int corePoolSize)方法，也是固定大小的线程池，但支持定时执行或周期执行任务。</li><li>Executors的newSingleThreadScheduledExecutor()方法：单线程的线程池，可以指定优先级或FIFO/LIFO。</li></ol><h4 id="看看源码"><a href="#看看源码" class="headerlink" title="看看源码"></a>看看源码</h4><p>newCachedThreadPool()：（有重载的指定threadfactory的方法）<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="keyword">new</span><span class="type">CachedThreadPool</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60</span>L, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="type">SynchronousQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>newFixedThreadPool(int nThreads)：（有重载的指定threadfactory的方法）<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="keyword">new</span><span class="type">FixedThreadPool</span>(int nThreads) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0</span>L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="type">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其他的几个线程池的方法类似，都是调用ThreadPoolExecutor的构造函数。线程池返回的值都是ExecutorService实例。</p><h4 id="演示例子"><a href="#演示例子" class="headerlink" title="演示例子"></a>演示例子</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExample4</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ScheduledExecutorService executorService = Executors.newScheduledThreadPool(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        executorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                log.warn(<span class="string">"schedule run"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">1</span>, <span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">        Timer timer = <span class="keyword">new</span> Timer();</span><br><span class="line">        timer.schedule(<span class="keyword">new</span> TimerTask() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                log.warn(<span class="string">"timer run"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="keyword">new</span> Date(), <span class="number">5</span> * <span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="运行结果："><a href="#运行结果：" class="headerlink" title="运行结果："></a>运行结果：</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">00<span class="selector-pseudo">:53</span><span class="selector-pseudo">:53.070</span> <span class="selector-attr">[Timer-0]</span> <span class="selector-tag">WARN</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.threadPool</span><span class="selector-class">.ThreadPoolExample4</span> <span class="selector-tag">-</span> <span class="selector-tag">timer</span> <span class="selector-tag">run</span></span><br><span class="line">00<span class="selector-pseudo">:53</span><span class="selector-pseudo">:54.066</span> <span class="selector-attr">[pool-1-thread-1]</span> <span class="selector-tag">WARN</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.threadPool</span><span class="selector-class">.ThreadPoolExample4</span> <span class="selector-tag">-</span> <span class="selector-tag">schedule</span> <span class="selector-tag">run</span></span><br><span class="line">00<span class="selector-pseudo">:53</span><span class="selector-pseudo">:57.068</span> <span class="selector-attr">[pool-1-thread-1]</span> <span class="selector-tag">WARN</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.threadPool</span><span class="selector-class">.ThreadPoolExample4</span> <span class="selector-tag">-</span> <span class="selector-tag">schedule</span> <span class="selector-tag">run</span></span><br><span class="line">00<span class="selector-pseudo">:53</span><span class="selector-pseudo">:58.067</span> <span class="selector-attr">[Timer-0]</span> <span class="selector-tag">WARN</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.threadPool</span><span class="selector-class">.ThreadPoolExample4</span> <span class="selector-tag">-</span> <span class="selector-tag">timer</span> <span class="selector-tag">run</span></span><br><span class="line">00<span class="selector-pseudo">:54</span><span class="selector-pseudo">:00.067</span> <span class="selector-attr">[pool-1-thread-1]</span> <span class="selector-tag">WARN</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.threadPool</span><span class="selector-class">.ThreadPoolExample4</span> <span class="selector-tag">-</span> <span class="selector-tag">schedule</span> <span class="selector-tag">run</span></span><br><span class="line">00<span class="selector-pseudo">:54</span><span class="selector-pseudo">:03.067</span> <span class="selector-attr">[pool-1-thread-1]</span> <span class="selector-tag">WARN</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.threadPool</span><span class="selector-class">.ThreadPoolExample4</span> <span class="selector-tag">-</span> <span class="selector-tag">schedule</span> <span class="selector-tag">run</span></span><br><span class="line">00<span class="selector-pseudo">:54</span><span class="selector-pseudo">:03.067</span> <span class="selector-attr">[Timer-0]</span> <span class="selector-tag">WARN</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.threadPool</span><span class="selector-class">.ThreadPoolExample4</span> <span class="selector-tag">-</span> <span class="selector-tag">timer</span> <span class="selector-tag">run</span></span><br><span class="line">00<span class="selector-pseudo">:54</span><span class="selector-pseudo">:06.068</span> <span class="selector-attr">[pool-1-thread-1]</span> <span class="selector-tag">WARN</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.threadPool</span><span class="selector-class">.ThreadPoolExample4</span> <span class="selector-tag">-</span> <span class="selector-tag">schedule</span> <span class="selector-tag">run</span></span><br></pre></td></tr></table></figure><h5 id="例子分析"><a href="#例子分析" class="headerlink" title="例子分析"></a>例子分析</h5><p>ExecutorService通过调用scheduleAtFixedRate方法，使该线程池配合定时器，以一个固定的频率调度执行。<br>例中定义了一个定时器Timer，在其调度方法schedule中新建TimerTask实例，并给出循环执行的时间间隔period，单位为毫秒。</p><h4 id="合理配置"><a href="#合理配置" class="headerlink" title="合理配置"></a>合理配置</h4><ol><li>当执行CPU密集型任务时，应尽量压榨使用CPU资源，参考设定线程数量为nCPU+1。</li><li>当执行IO密集型任务时，因其为输入输出两通路，线程数量参考设置为2*nCPU。</li><li>实际中，根据业务需要进行相应调整。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Thread类&quot;&gt;&lt;a href=&quot;#Thread类&quot; class=&quot;headerlink&quot; title=&quot;Thread类&quot;&gt;&lt;/a&gt;Thread类&lt;/h3&gt;&lt;h4 id=&quot;new-Thread的弊端&quot;&gt;&lt;a href=&quot;#new-Thread的弊端&quot; class=&quot;headerlink&quot; title=&quot;new Thread的弊端&quot;&gt;&lt;/a&gt;new Thread的弊端&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;每次new Thread新建对象，性能差。&lt;/li&gt;
&lt;li&gt;线程缺乏统一的管理，可能无限制地新建线程，相互竞争，有可能占用更多的系统资源导致宕机或者OOM。&lt;/li&gt;
&lt;li&gt;缺少更多高级功能，如：更多执行、定期执行，线程中断等。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Java之并发编程" scheme="http://suprisemf.github.io/categories/Java%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java" scheme="http://suprisemf.github.io/tags/Java/"/>
    
      <category term="并发编程" scheme="http://suprisemf.github.io/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>J.U.C之BlockingQueue</title>
    <link href="http://suprisemf.github.io/2018/08/03/J-U-C%E4%B9%8BBlockingQueue/"/>
    <id>http://suprisemf.github.io/2018/08/03/J-U-C之BlockingQueue/</id>
    <published>2018-08-03T01:05:49.000Z</published>
    <updated>2018-08-03T01:07:32.954Z</updated>
    
    <content type="html"><![CDATA[<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>BlockingQueue见名知意，即阻塞队列。它是一个线程安全的队列。<br>大致有两种情况：</p><ol><li>队列满了，但此时还有入队操作；</li><li>队列空了，但此时还有出队操作。<a id="more"></a><h4 id="场景分析"><a href="#场景分析" class="headerlink" title="场景分析"></a>场景分析</h4>主要应用在生产者-消费者场景。</li><li>生产者生产对象，并放入阻塞队列，直至队列已满，被阻塞。</li><li>消费者消费对象，从阻塞队列中取，直至队列已空，被阻塞。</li></ol><h4 id="队列操作方法"><a href="#队列操作方法" class="headerlink" title="队列操作方法"></a>队列操作方法</h4><p>一共有四套方法。</p><p><img src="/2018/08/03/J-U-C之BlockingQueue/blockingqueue.png" alt="图示"></p><h5 id="第一套方法：Throws-Exception"><a href="#第一套方法：Throws-Exception" class="headerlink" title="第一套方法：Throws Exception"></a>第一套方法：Throws Exception</h5><p>如果操作不能马上执行就会抛出异常。<br>type | method<br>-| -<br>Insert | add(o)<br>Remove  |  remove(o)<br>Examine  |  element()</p><h5 id="第二套方法：Special-Value"><a href="#第二套方法：Special-Value" class="headerlink" title="第二套方法：Special Value"></a>第二套方法：Special Value</h5><p>如果操作不能马上执行就会返回一个特殊值。一般是true/false<br>type | method<br>-| -<br>Insert | offer(o)<br>Remove  |  poll()<br>Examine  |  peek()</p><h5 id="第三套方法：Blocks"><a href="#第三套方法：Blocks" class="headerlink" title="第三套方法：Blocks"></a>第三套方法：Blocks</h5><p>如果操作不能马上执行就会进行阻塞操作。<br>type | method<br>-| -<br>Insert | put()<br>Remove  |  take()<br>Examine  |  无</p><h5 id="第四套方法：Times-Out"><a href="#第四套方法：Times-Out" class="headerlink" title="第四套方法：Times Out"></a>第四套方法：Times Out</h5><p>如果操作不能马上执行就会给定一个超时时间。如果超时时间已经过期还未执行就会返回一个特殊值。一般是true/false<br>type | method<br>-| -<br>Insert | offer(o，timeout，timeunit)<br>Remove  |  poll(timeout，timeunit)<br>Examine  | 无</p><h4 id="事件类"><a href="#事件类" class="headerlink" title="事件类"></a>事件类</h4><h5 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h5><ol><li>是一个有界的（容量有限,初始化时指定容量，之后不得更改）阻塞队列。</li><li>其内部实现为数组。</li><li>是以FIFO的方式存放数据。</li></ol><h5 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h5><ol><li>阻塞的对象是队列的内部元素。</li><li>其内部元素必须实现J.U.C中Delayed接口。Delayed接口继承了Comparable接口。说明DelayQueue中的元素需要排序。一般按照元素过期时间的优先级排序。</li><li>底层实现是：PriorityQueue和Lock。</li><li>使用场景广泛：连接的定时关闭、缓存对象、超时处理等。</li></ol><h5 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h5><ol><li>是BlockingQueue的一种链接版本。</li><li>见名知意，因为使用链接，故而若初始化时指定容量则是有界队列，否则默认队列的长度可变。</li><li>使用链接，故底层实现是链表。</li><li>是以FIFO的方式存放数据。</li></ol><h5 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h5><ol><li>见名知意，它是BlockingQueue的附加优先级的队列。</li><li>是一个无边界的队列，但有排序规则。</li><li>队列允许插入的元素为空（null）。</li><li>其内部元素必须实现Comparable接口。</li><li>队列中优先级的排序规则：通过自定义地对Comparable接口的实现来指定规则。</li><li>可以从PriorityBlockingQueue中获得一个迭代器（iterator），但并不保证按照队列中元素的优先级进行迭代。</li></ol><h5 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h5><ol><li>见名知意，即为“同步队列”。</li><li>队列内部仅允许容纳一个元素，即放入一个元素后只等待其被取走。</li><li>是一个无界非缓存队列。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h4&gt;&lt;p&gt;BlockingQueue见名知意，即阻塞队列。它是一个线程安全的队列。&lt;br&gt;大致有两种情况：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;队列满了，但此时还有入队操作；&lt;/li&gt;
&lt;li&gt;队列空了，但此时还有出队操作。&lt;/li&gt;&lt;/ol&gt;
    
    </summary>
    
      <category term="Java之并发编程" scheme="http://suprisemf.github.io/categories/Java%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java" scheme="http://suprisemf.github.io/tags/Java/"/>
    
      <category term="并发编程" scheme="http://suprisemf.github.io/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>J.U.C之ForkJoin</title>
    <link href="http://suprisemf.github.io/2018/08/03/J-U-C%E4%B9%8BForkJoin/"/>
    <id>http://suprisemf.github.io/2018/08/03/J-U-C之ForkJoin/</id>
    <published>2018-08-03T01:02:20.000Z</published>
    <updated>2018-08-03T01:03:25.311Z</updated>
    
    <content type="html"><![CDATA[<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>ForkJoin框架是JDK 1.7提供的一种用于并行任务执行的框架。有些像Hadoop中的MapReduce机制。即将一个大任务分为（fork）多个小任务分别执行，最后将多个小任务的执行结果进行汇总（join）。<br><a id="more"></a></p><blockquote><p>该框架采用的工作窃取算法，即<strong>当一个线程执行完它的任务后，可以从其他线程的任务队列尾部开始自行窃取任务进行执行，最后与该队列的另一个线程接头</strong>，以充分发挥该框架的优势（消除线程等待），提高效率，促进性能提升。<br>其中，每个线程的任务队列采用双端队列进行实现。<br>缺点：1. 当一个线程的双端队列中只有一个任务时，也会发生线程竞争。2. 由于使用双端队列，系统会分配更多的资源。</p></blockquote><h4 id="执行任务的局限性"><a href="#执行任务的局限性" class="headerlink" title="执行任务的局限性"></a>执行任务的局限性</h4><ol><li>任务只能使用Fork或Join作为同步机制；</li><li>线程队列中的任务不可以有IO操作；</li><li>任务不能抛出检查异常。（若有则需要必要的代码进行处理）</li></ol><h4 id="ForkJoinPool"><a href="#ForkJoinPool" class="headerlink" title="ForkJoinPool"></a>ForkJoinPool</h4><p>看一下注释：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * An &#123;@link ExecutorService&#125; <span class="keyword">for</span> <span class="built_in">running</span> &#123;@link ForkJoinTask&#125;s.</span><br><span class="line"> * A &#123;@code ForkJoinPool&#125; provides <span class="keyword">the</span> entry point <span class="keyword">for</span> submissions</span><br><span class="line"> * <span class="keyword">from</span> non-&#123;@code ForkJoinTask&#125; clients, <span class="keyword">as</span> well <span class="keyword">as</span> management <span class="keyword">and</span></span><br><span class="line"> * monitoring operations.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;A &#123;@code ForkJoinPool&#125; differs <span class="keyword">from</span> other kinds <span class="keyword">of</span> &#123;@link</span><br><span class="line"> * ExecutorService&#125; mainly <span class="keyword">by</span> virtue <span class="keyword">of</span> employing</span><br><span class="line"> * &lt;em&gt;work-stealing&lt;/em&gt;: all threads <span class="keyword">in</span> <span class="keyword">the</span> pool attempt <span class="keyword">to</span> find <span class="keyword">and</span></span><br><span class="line"> * execute tasks submitted <span class="keyword">to</span> <span class="keyword">the</span> pool <span class="keyword">and</span>/<span class="keyword">or</span> created <span class="keyword">by</span> other active</span><br><span class="line"> * tasks (eventually blocking waiting <span class="keyword">for</span> work <span class="keyword">if</span> none exist). This</span><br><span class="line"> * enables efficient processing when most tasks spawn other subtasks</span><br><span class="line"> * (<span class="keyword">as</span> do most &#123;@code ForkJoinTask&#125;s), <span class="keyword">as</span> well <span class="keyword">as</span> when many small</span><br><span class="line"> * tasks are submitted <span class="keyword">to</span> <span class="keyword">the</span> pool <span class="keyword">from</span> external clients.  Especially</span><br><span class="line"> * when setting &lt;em&gt;asyncMode&lt;/em&gt; <span class="keyword">to</span> <span class="literal">true</span> <span class="keyword">in</span> constructors, &#123;@code</span><br><span class="line"> * ForkJoinPool&#125;s may also be appropriate <span class="keyword">for</span> use <span class="keyword">with</span> event-style</span><br><span class="line"> * tasks <span class="keyword">that</span> are never joined.</span><br><span class="line"> */</span><br></pre></td></tr></table></figure></p><p>实质上，ForkJoinPool是一个从非ForkJoinTask的请求中，为运行中的ForkJoinTask的子任务提供切入点的ExecutorService。它不同于其他的ExecutorService，主要是它虚拟部署了任务窃取。尤其当在构造器中设置asyncMode为true时，ForkJoinPool也可能适当地使用事件模式的任务（从未被汇总过？？）。<br><strong>ForkJoinPool主要做实现：包括工作窃取算法、工作线程的管理、任务的状态管理、任务的执行信息等。</strong></p><h4 id="ForkJoinTask"><a href="#ForkJoinTask" class="headerlink" title="ForkJoinTask"></a>ForkJoinTask</h4><p>看下注释：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Abstract base <span class="built_in">class</span> <span class="keyword">for</span> tasks <span class="keyword">that</span> <span class="built_in">run</span> within a &#123;@link ForkJoinPool&#125;.</span><br><span class="line"> * A &#123;@code ForkJoinTask&#125; <span class="keyword">is</span> a thread-like entity <span class="keyword">that</span> <span class="keyword">is</span> much</span><br><span class="line"> * lighter weight than a normal thread.  Huge numbers <span class="keyword">of</span> tasks <span class="keyword">and</span></span><br><span class="line"> * subtasks may be hosted <span class="keyword">by</span> a small <span class="built_in">number</span> <span class="keyword">of</span> actual threads <span class="keyword">in</span> a</span><br><span class="line"> * ForkJoinPool, <span class="keyword">at</span> <span class="keyword">the</span> price <span class="keyword">of</span> <span class="keyword">some</span> usage limitations.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;A <span class="string">"main"</span> &#123;@code ForkJoinTask&#125; begins execution when <span class="keyword">it</span> <span class="keyword">is</span></span><br><span class="line"> * explicitly submitted <span class="keyword">to</span> a &#123;@link ForkJoinPool&#125;, <span class="keyword">or</span>, <span class="keyword">if</span> <span class="keyword">not</span> already</span><br><span class="line"> * engaged <span class="keyword">in</span> a ForkJoin computation, commenced <span class="keyword">in</span> <span class="keyword">the</span> &#123;@link</span><br><span class="line"> * ForkJoinPool<span class="comment">#commonPool()&#125; via &#123;@link #fork&#125;, &#123;@link #invoke&#125;, or</span></span><br><span class="line"> * related methods.  Once started, <span class="keyword">it</span> will usually <span class="keyword">in</span> turn start other</span><br><span class="line"> * subtasks.  As indicated <span class="keyword">by</span> <span class="keyword">the</span> <span class="built_in">name</span> <span class="keyword">of</span> this <span class="built_in">class</span>, many programs</span><br><span class="line"> * using &#123;@code ForkJoinTask&#125; employ only methods &#123;@link <span class="comment">#fork&#125; and</span></span><br><span class="line"> * &#123;@link <span class="comment">#join&#125;, or derivatives such as &#123;@link</span></span><br><span class="line"> * <span class="comment">#invokeAll(ForkJoinTask...) invokeAll&#125;.  However, this class also</span></span><br><span class="line"> * provides a <span class="built_in">number</span> <span class="keyword">of</span> other methods <span class="keyword">that</span> can come <span class="keyword">into</span> play <span class="keyword">in</span></span><br><span class="line"> * advanced usages, <span class="keyword">as</span> well <span class="keyword">as</span> extension mechanics <span class="keyword">that</span> allow support</span><br><span class="line"> * <span class="keyword">of</span> new forms <span class="keyword">of</span> fork/join processing.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;A &#123;@code ForkJoinTask&#125; <span class="keyword">is</span> a lightweight form <span class="keyword">of</span> &#123;@link Future&#125;.</span><br><span class="line"> * The efficiency <span class="keyword">of</span> &#123;@code ForkJoinTask&#125;s stems <span class="keyword">from</span> a <span class="keyword">set</span> <span class="keyword">of</span></span><br><span class="line"> * restrictions (<span class="keyword">that</span> are only partially statically enforceable)</span><br><span class="line"> * reflecting their main use <span class="keyword">as</span> computational tasks calculating pure</span><br><span class="line"> * functions <span class="keyword">or</span> operating <span class="keyword">on</span> purely isolated objects.  The primary</span><br><span class="line"> * coordination mechanisms are &#123;@link <span class="comment">#fork&#125;, that arranges</span></span><br><span class="line"> * asynchronous execution, <span class="keyword">and</span> &#123;@link <span class="comment">#join&#125;, that doesn't proceed</span></span><br><span class="line"> * <span class="keyword">until</span> <span class="keyword">the</span> task's <span class="literal">result</span> has been computed.  Computations should</span><br><span class="line"> * ideally avoid &#123;@code synchronized&#125; methods <span class="keyword">or</span> blocks, <span class="keyword">and</span> should</span><br><span class="line"> * minimize other blocking synchronization <span class="keyword">apart from</span> joining other</span><br><span class="line"> * tasks <span class="keyword">or</span> using synchronizers such <span class="keyword">as</span> Phasers <span class="keyword">that</span> are advertised <span class="keyword">to</span></span><br><span class="line"> * cooperate <span class="keyword">with</span> fork/join scheduling.</span><br><span class="line"> */</span><br></pre></td></tr></table></figure></p><p><strong>ForkJoinTask：主要提供任务中fork/join的机制。</strong></p><blockquote><p>我：大家自己意会一下，但可千万不要言传哦~ 真的很容易看懂的~<br>读者：emmmmm，是挺容易的，因为它容易就容易在它容易它奶奶的腿……</p></blockquote><h4 id="演示例子"><a href="#演示例子" class="headerlink" title="演示例子"></a>演示例子</h4><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line"><span class="keyword">public</span> class ForkJoinTaskExample extends RecursiveTask&lt;Integer&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> final <span class="keyword">int</span> threshold = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> start;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> <span class="built_in">end</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ForkJoinTaskExample(<span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.start = start;</span><br><span class="line">        <span class="keyword">this</span>.<span class="built_in">end</span> = <span class="built_in">end</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="keyword">protected</span> Integer compute() &#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果任务足够小就计算任务</span></span><br><span class="line">        <span class="keyword">boolean</span> canCompute = (<span class="built_in">end</span> - start) &lt;= threshold;</span><br><span class="line">        <span class="built_in">if</span> (canCompute) &#123;</span><br><span class="line">            <span class="built_in">for</span> (<span class="keyword">int</span> i = start; i &lt;= <span class="built_in">end</span>; i++) &#123;</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="built_in">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果任务大于阈值，就分裂成两个子任务计算</span></span><br><span class="line">            <span class="keyword">int</span> middle = (start + <span class="built_in">end</span>) / <span class="number">2</span>;</span><br><span class="line">            ForkJoinTaskExample leftTask = <span class="keyword">new</span> ForkJoinTaskExample(start, middle);</span><br><span class="line">            ForkJoinTaskExample rightTask = <span class="keyword">new</span> ForkJoinTaskExample(middle + <span class="number">1</span>, <span class="built_in">end</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 执行子任务</span></span><br><span class="line">            leftTask.fork();</span><br><span class="line">            rightTask.fork();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 等待任务执行结束合并其结果</span></span><br><span class="line">            <span class="keyword">int</span> leftResult = leftTask.join();</span><br><span class="line">            <span class="keyword">int</span> rightResult = rightTask.join();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 合并子任务</span></span><br><span class="line">            sum = leftResult + rightResult;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line">        ForkJoinPool forkjoinPool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//生成一个计算任务，计算1+2+3+4</span></span><br><span class="line">        ForkJoinTaskExample task = <span class="keyword">new</span> ForkJoinTaskExample(<span class="number">1</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//执行一个任务</span></span><br><span class="line">        Future&lt;Integer&gt; result = forkjoinPool.submit(task);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">try</span> &#123;</span><br><span class="line">            log.info(<span class="string">"result:&#123;&#125;"</span>, result.<span class="built_in">get</span>());</span><br><span class="line">        &#125; <span class="built_in">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">"exception"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="运行结果："><a href="#运行结果：" class="headerlink" title="运行结果："></a>运行结果：</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">14<span class="selector-pseudo">:58</span><span class="selector-pseudo">:35.442</span> <span class="selector-attr">[main]</span> <span class="selector-tag">INFO</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.aqs</span><span class="selector-class">.ForkJoinTaskExample</span> <span class="selector-tag">-</span> <span class="selector-tag">result</span><span class="selector-pseudo">:5050</span></span><br></pre></td></tr></table></figure><h5 id="例子分析"><a href="#例子分析" class="headerlink" title="例子分析"></a>例子分析</h5><ol><li>该测试类需要继承<code>RecursiveTask</code>类，即在任务<code>fork</code>中需要递归地拆分任务;</li><li><code>ForkJoinTaskExample task = new ForkJoinTaskExample(1, 100);</code>指定<code>start</code>和<code>end</code>，其构造函数完成其任务的<code>fork</code>的具体实现，之后再将其子结果<code>join</code>并返回。</li><li>最后通过ForkJoinPool调用submit()执行该任务。</li><li>其中：在任务拆分（fork）中，声明了一个threshold（阈值），即指定任务不可拆分的界限。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h4&gt;&lt;p&gt;ForkJoin框架是JDK 1.7提供的一种用于并行任务执行的框架。有些像Hadoop中的MapReduce机制。即将一个大任务分为（fork）多个小任务分别执行，最后将多个小任务的执行结果进行汇总（join）。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java之并发编程" scheme="http://suprisemf.github.io/categories/Java%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java" scheme="http://suprisemf.github.io/tags/Java/"/>
    
      <category term="并发编程" scheme="http://suprisemf.github.io/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>J.U.C之FutureTask</title>
    <link href="http://suprisemf.github.io/2018/08/03/J-U-C%E4%B9%8BFutureTask/"/>
    <id>http://suprisemf.github.io/2018/08/03/J-U-C之FutureTask/</id>
    <published>2018-08-03T00:55:46.000Z</published>
    <updated>2018-08-03T00:56:46.976Z</updated>
    
    <content type="html"><![CDATA[<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><blockquote><p>由于线程是实现了Runnable接口或继承了Thread类，其执行后无法回调其线程的执行结果，因此JDK 1.5提供了一些新机制：接口Callable和Future。通过他们可以得到线程的执行结果。</p></blockquote><a id="more"></a><p>FutureTask间接实现了Future接口，并提供了一个基础的实现：开始/取消一个计算的方法，计算结果的查询。FutureTask可以被用来去包装一个Callable或Runnable对象，并可以被提交给Executor执行器去执行。除了被用作一个独立的服务类，它还提供了protected的功能，在定制任务类时会十分有用。（好吧，被你发现了，这是我翻译的源码中的类注释，哭唧唧~）</p><h4 id="Runnable与Callable对比"><a href="#Runnable与Callable对比" class="headerlink" title="Runnable与Callable对比"></a>Runnable与Callable对比</h4><ol><li>Runnable接口只有一个run()方法；</li><li>Callable是一个泛型接口，其中也只有V call()函数，其返回类型即传入的参数泛型。</li><li>两个接口功能相似，但后者因可以返回执行信息且支持泛型而更强大一些。</li></ol><h4 id="Future接口"><a href="#Future接口" class="headerlink" title="Future接口"></a>Future接口</h4><p>通过实现该类可以得到一个<strong>异步计算</strong>的返回结果。并提供方法接口：检查是否计算完成、等待计算的完成、取回计算的结果、判断计算是否在完成前被正常地取消。</p><h4 id="FutureTask类"><a href="#FutureTask类" class="headerlink" title="FutureTask类"></a>FutureTask类</h4><p>它实现了RunnableFuture接口，而RunnableFuture接口同时继承了Runnable接口和Future接口。即FutureTask类最终也是执行的Callable的方法。组合Runnable和Future的好处：可以另起线程去专门检查并调取最终计算的结果，而其他的线程可以继续其他任务（只需监听该跑腿线程即可）。</p><h4 id="演示例子-Callable和Future结合"><a href="#演示例子-Callable和Future结合" class="headerlink" title="演示例子-Callable和Future结合"></a>演示例子-Callable和Future结合</h4><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCallable</span> <span class="keyword"><span class="keyword">implements</span> <span class="type">Callable</span></span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">String</span> call() throws Exception &#123;</span><br><span class="line">            log.info(<span class="string">"do something in callable"</span>);</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Done"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="keyword">String</span>[] args) throws Exception &#123;</span><br><span class="line">        ExecutorService executorService = Executors.<span class="keyword">new</span><span class="type">CachedThreadPool</span>();</span><br><span class="line">        Future&lt;<span class="keyword">String</span>&gt; future = executorService.submit(<span class="keyword">new</span> <span class="type">MyCallable</span>());</span><br><span class="line">        log.info(<span class="string">"do something in main"</span>);</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">String</span> result = future.<span class="keyword">get</span>();</span><br><span class="line">        log.info(<span class="string">"result：&#123;&#125;"</span>, result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">11<span class="selector-pseudo">:29</span><span class="selector-pseudo">:00.230</span> <span class="selector-attr">[main]</span> <span class="selector-tag">INFO</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.aqs</span><span class="selector-class">.FutureExample</span> <span class="selector-tag">-</span> <span class="selector-tag">do</span> <span class="selector-tag">something</span> <span class="selector-tag">in</span> <span class="selector-tag">main</span></span><br><span class="line">11<span class="selector-pseudo">:29</span><span class="selector-pseudo">:00.230</span> <span class="selector-attr">[pool-1-thread-1]</span> <span class="selector-tag">INFO</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.aqs</span><span class="selector-class">.FutureExample</span> <span class="selector-tag">-</span> <span class="selector-tag">do</span> <span class="selector-tag">something</span> <span class="selector-tag">in</span> <span class="selector-tag">callable</span></span><br><span class="line">11<span class="selector-pseudo">:29</span><span class="selector-pseudo">:05.234</span> <span class="selector-attr">[main]</span> <span class="selector-tag">INFO</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.aqs</span><span class="selector-class">.FutureExample</span> <span class="selector-tag">-</span> <span class="selector-tag">result</span>：<span class="selector-tag">Done</span></span><br></pre></td></tr></table></figure><h5 id="例子分析"><a href="#例子分析" class="headerlink" title="例子分析"></a>例子分析</h5><ol><li>结合Callable和Future两者。</li><li>实现的Callable类可以被Executors的submit(xxx)提交给线程池运行。（之前提到过）</li><li>通过Future的get()查询并取回执行结果；若未执行结束则阻塞查询。（前面有说到）</li></ol><h4 id="演示例子-FutureTask"><a href="#演示例子-FutureTask" class="headerlink" title="演示例子-FutureTask"></a>演示例子-FutureTask</h4><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line"><span class="keyword">public</span> class FutureTaskExample &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        FutureTask&lt;<span class="keyword">String</span>&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;<span class="keyword">String</span>&gt;(<span class="keyword">new</span> Callable&lt;<span class="keyword">String</span>&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">String</span> call() <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                <span class="built_in">log</span>.info(<span class="string">"do something in callable"</span>);</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"Done"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(futureTask).start();</span><br><span class="line">        <span class="built_in">log</span>.info(<span class="string">"do something in main"</span>);</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">String</span> result = futureTask.<span class="built_in">get</span>();</span><br><span class="line">        <span class="built_in">log</span>.info(<span class="string">"result：&#123;&#125;"</span>, result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="运行结果-1"><a href="#运行结果-1" class="headerlink" title="运行结果"></a>运行结果</h5><p>与上个例子结果一模一样，运行速度快了25%左右：Callable和Future结合使用耗时2s 450ms，FutureTask耗时1s 890ms。</p><h4 id="看下源码"><a href="#看下源码" class="headerlink" title="看下源码"></a>看下源码</h4><p>get()方法的内核：返回执行完成的结果或抛出异常。<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns result or throws exception for completed task.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> s completed state value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="keyword">private</span> <span class="function">V <span class="title">report</span><span class="params">(<span class="keyword">int</span> s)</span> <span class="keyword">throws</span> ExecutionException </span>&#123;</span><br><span class="line">    Object x = outcome;</span><br><span class="line">    <span class="keyword">if</span> (s == NORMAL)</span><br><span class="line">        <span class="keyword">return</span> (V)x;</span><br><span class="line">    <span class="keyword">if</span> (s &gt;= CANCELLED)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> CancellationException();</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ExecutionException((Throwable)x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>还有一个可以指定返回执行结果的构造函数：（内部都是调用Executors的callable方法）<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> FutureTask(Runnable runnable, V result) &#123;</span><br><span class="line">    <span class="keyword">this</span>.callable = Executors.callable(runnable, result);</span><br><span class="line">    <span class="keyword">this</span>.state = <span class="keyword">NEW</span>;       <span class="comment">// ensure visibility of callable</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Callable&lt;T&gt; callable(Runnable <span class="keyword">task</span>, T result) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">task</span> == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RunnableAdapter&lt;T&gt;(<span class="keyword">task</span>, result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> RunnableAdapter&lt;T&gt; <span class="keyword">implements</span> Callable&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">final</span> Runnable <span class="keyword">task</span>;</span><br><span class="line">    <span class="keyword">final</span> T result;</span><br><span class="line">    RunnableAdapter(Runnable <span class="keyword">task</span>, T result) &#123;</span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">task</span> = <span class="keyword">task</span>;</span><br><span class="line">        <span class="keyword">this</span>.result = result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="keyword">call</span>() &#123;</span><br><span class="line">        <span class="keyword">task</span>.run();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>还有一个指定超时时间的get():<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V get(<span class="keyword">long</span> timeout, TimeUnit unit)</span><br><span class="line">    <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException &#123;</span><br><span class="line">    <span class="keyword">if</span> (unit == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> s = state;</span><br><span class="line">    <span class="keyword">if</span> (s &lt;= COMPLETING &amp;&amp;</span><br><span class="line">        (s = awaitDone(<span class="keyword">true</span>, unit.toNanos(timeout))) &lt;= COMPLETING)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();</span><br><span class="line">    <span class="function"><span class="keyword">return</span> <span class="title">report</span><span class="params">(s)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当计算失败时（不包括计算被取消）被内部的run()调用:报告其中的异常<br><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">protected void <span class="built_in">set</span>Exception(Throwable t) &#123;</span><br><span class="line">    if (UNSAFE.compareAndSwapInt(this, <span class="keyword">state</span>Offset, NEW, COMPLETING)) &#123;</span><br><span class="line">        outcome = t;</span><br><span class="line">        UNSAFE.putOrderedInt(this, <span class="keyword">state</span>Offset, EXCEPTIONAL); // final <span class="keyword">state</span></span><br><span class="line">        finishCompletion();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>一旦计算完成，该计算就不能被重启或取消了，除非调用runAndReset()方法：（之前概述提到）<br><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">protected boolean runAndReset() &#123;</span><br><span class="line">    if (<span class="keyword">state</span> != NEW ||</span><br><span class="line">        !UNSAFE.compareAndSwapObject(this, runnerOffset,</span><br><span class="line">                                     null, Thread.currentThread()))</span><br><span class="line">        return false;</span><br><span class="line">    boolean ran = false;</span><br><span class="line">    int s = <span class="keyword">state</span>;</span><br><span class="line">    try &#123;</span><br><span class="line">        Callable<span class="variable">&lt;V&gt;</span> c = callable;</span><br><span class="line">        if (c != null &amp;&amp; s == NEW) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                c.call(); // don't <span class="built_in">set</span> result</span><br><span class="line">                ran = true;</span><br><span class="line">            &#125; catch (Throwable ex) &#123;</span><br><span class="line">                <span class="built_in">set</span>Exception(ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        // runner must be non-null until <span class="keyword">state</span> is settled <span class="keyword">to</span></span><br><span class="line">        // prevent concurrent calls <span class="keyword">to</span> run()</span><br><span class="line">        runner = null;</span><br><span class="line">        // <span class="keyword">state</span> must be re-read after nulling runner <span class="keyword">to</span> prevent</span><br><span class="line">        // leaked interrupts</span><br><span class="line">        s = <span class="keyword">state</span>;</span><br><span class="line">        if (s &gt;= INTERRUPTING)</span><br><span class="line">            handlePossibleCancellationInterrupt(s);</span><br><span class="line">    &#125;</span><br><span class="line">    return ran &amp;&amp; s == NEW;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;由于线程是实现了Runnable接口或继承了Thread类，其执行后无法回调其线程的执行结果，因此JDK 1.5提供了一些新机制：接口Callable和Future。通过他们可以得到线程的执行结果。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Java之并发编程" scheme="http://suprisemf.github.io/categories/Java%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java" scheme="http://suprisemf.github.io/tags/Java/"/>
    
      <category term="并发编程" scheme="http://suprisemf.github.io/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>J.U.C之AQS—RentrantLock-Part-2</title>
    <link href="http://suprisemf.github.io/2018/08/03/JJ-U-C%E4%B9%8BAQS%E2%80%94RentrantLock-part-2/"/>
    <id>http://suprisemf.github.io/2018/08/03/JJ-U-C之AQS—RentrantLock-part-2/</id>
    <published>2018-08-03T00:50:26.000Z</published>
    <updated>2018-08-03T00:52:39.989Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这部分还是接着上部分的源码学习。<br><a id="more"></a></p></blockquote><h4 id="源码学习"><a href="#源码学习" class="headerlink" title="源码学习"></a>源码学习</h4><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Sync object for non-fair locks</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">7316153563782823691</span>L;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Performs lock.  Try immediate barge, backing up to normal</span></span><br><span class="line"><span class="comment">     * acquire on failure.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="function"><span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">return</span> <span class="title">nonfairTryAcquire</span><span class="params">(acquires)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Atomically sets synchronization state to the given updated</span></span><br><span class="line"><span class="comment"> * value if the current state value equals the expected value.</span></span><br><span class="line"><span class="comment"> * This operation has memory semantics of a &#123;<span class="doctag">@code</span> volatile&#125; read</span></span><br><span class="line"><span class="comment"> * and write.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> expect the expected value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> update the new value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if successful. False return indicates that the actual</span></span><br><span class="line"><span class="comment"> *         value was not equal to the expected value.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="function"><span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// See below for intrinsics setup to support this</span></span><br><span class="line">    <span class="function"><span class="keyword">return</span> unsafe.<span class="title">compareAndSwapInt</span><span class="params">(<span class="keyword">this</span>, stateOffset, expect, update)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Sets the thread that currently owns exclusive access.</span></span><br><span class="line"><span class="comment"> * A &#123;<span class="doctag">@code</span> null&#125; argument indicates that no thread owns access.</span></span><br><span class="line"><span class="comment"> * This method does not otherwise impose any synchronization or</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> volatile&#125; field accesses.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> thread the owner thread</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="function"><span class="keyword">void</span> <span class="title">setExclusiveOwnerThread</span><span class="params">(Thread thread)</span> </span>&#123;</span><br><span class="line">    exclusiveOwnerThread = thread;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Acquires in exclusive mode, ignoring interrupts.  Implemented</span></span><br><span class="line"><span class="comment"> * by invoking at least once &#123;<span class="doctag">@link</span> #tryAcquire&#125;,</span></span><br><span class="line"><span class="comment"> * returning on success.  Otherwise the thread is queued, possibly</span></span><br><span class="line"><span class="comment"> * repeatedly blocking and unblocking, invoking &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment"> * #tryAcquire&#125; until success.  This method can be used</span></span><br><span class="line"><span class="comment"> * to implement method &#123;<span class="doctag">@link</span> Lock#lock&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arg the acquire argument.  This value is conveyed to</span></span><br><span class="line"><span class="comment"> *        &#123;<span class="doctag">@link</span> #tryAcquire&#125; but is otherwise uninterpreted and</span></span><br><span class="line"><span class="comment"> *        can represent anything you like.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="function"><span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="function"><span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Convenience method to interrupt current thread.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">selfInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread.currentThread().interrupt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">interrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> != Thread.currentThread())</span><br><span class="line">        checkAccess();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (blockerLock) &#123;</span><br><span class="line">        Interruptible b = blocker;</span><br><span class="line">        <span class="keyword">if</span> (b != <span class="keyword">null</span>) &#123;</span><br><span class="line">            interrupt0();           <span class="comment">// Just to set the interrupt flag</span></span><br><span class="line">            b.interrupt(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    interrupt0();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="function"><span class="keyword">void</span> <span class="title">interrupt0</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h4 id="配合的Condition"><a href="#配合的Condition" class="headerlink" title="配合的Condition"></a>配合的Condition</h4><p>在下篇手记-介绍Condition中有详细分析~</p><h4 id="小总结："><a href="#小总结：" class="headerlink" title="小总结："></a>小总结：</h4><ol><li>synchronized关键字：它是由JVM实现，并有很多内存监控工具提供帮助，并通过这些工具配合synchronized的内存标识，进行内存层面的“debug”或观察；当运行时出现异常，JVM会自动解锁并进行处理。</li><li>ReentrantLock、ReentrantReadWriteLock、StampedLock是对象层面的锁，需要手动指定加锁与解锁操作（放在finally中）。</li><li>StampedLock：因为加入乐观锁，故对吞吐量有较大的优化，尤其是读多写少时。但使用起来较复杂，API内容较多。</li><li>当线程较少推荐使用synchronized关键字，简单效率高；当线程较多，且线程并发的增长有一定趋势时（可预估），推荐使用ReentrantLock。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这部分还是接着上部分的源码学习。&lt;br&gt;&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Java之并发编程" scheme="http://suprisemf.github.io/categories/Java%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java" scheme="http://suprisemf.github.io/tags/Java/"/>
    
      <category term="并发编程" scheme="http://suprisemf.github.io/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>J.U.C之AQS—RentrantLock-Part-1</title>
    <link href="http://suprisemf.github.io/2018/08/03/JJ-U-C%E4%B9%8BAQS%E2%80%94RentrantLock-part-1/"/>
    <id>http://suprisemf.github.io/2018/08/03/JJ-U-C之AQS—RentrantLock-part-1/</id>
    <published>2018-08-03T00:37:29.000Z</published>
    <updated>2018-08-03T00:44:12.465Z</updated>
    
    <content type="html"><![CDATA[<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>RentrantLock即重入锁，是JDK中J.U.C提供的最重要的锁。<br>通过自旋锁实现RentrantLock：循环调用CAS操作实现枷锁，即<strong>阻止线程进入内核态被阻塞</strong>，故而效率较高。</p><a id="more"></a><h4 id="与Synchronized对比"><a href="#与Synchronized对比" class="headerlink" title="与Synchronized对比"></a>与Synchronized对比</h4><ol><li>可重入性：两者都具有可重入性。</li><li>锁的实现：RentrantLock是JDK中源码实现；Synchronized的锁机制是由JVM的JMM机制管理实现。</li><li>性能区别：Synchronized关键字优化前，其性能很差；但优化后（借鉴了RentrantLock中的CAS机制：在用户态加锁解锁），引入了偏向锁、自旋锁后，两者性能几无差异。（更推荐synchronized）。</li><li>功能区别：(1).synchronized关键字使用更加简洁简单，由编译器保证实现；RentrantLock需声明锁，并加锁，在finally中解锁。(2).RentrantLock锁粒度更细，灵活度高。</li></ol><blockquote><p>公平锁即按照线程的请求的先后顺序给与锁；非公平锁即按照对锁的争夺成功的线程加锁。</p></blockquote><h4 id="特有功能："><a href="#特有功能：" class="headerlink" title="特有功能："></a>特有功能：</h4><ol><li>RentrantLock可以指定该lock是公平锁或非公平锁（而synchronized只能是非公平锁）；</li><li>通过方法提供Condition类，可以分组唤醒需要唤醒的线程。</li><li>提供能够中断等待锁的线程的机制 –&gt; lock.lockInterruptibly()</li></ol><h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><p>当需要用到上面RentrantLock的特有功能时，必须使用RentrantLock。</p><h4 id="演示例子"><a href="#演示例子" class="headerlink" title="演示例子"></a>演示例子</h4><h5 id="RentrantLock"><a href="#RentrantLock" class="headerlink" title="RentrantLock"></a>RentrantLock</h5><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockExample2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> clientTotal = <span class="number">5000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> threadTotal = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(threadTotal);</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(clientTotal);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clientTotal ; i++) &#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    add();</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.<span class="keyword">error</span>(<span class="string">"exception"</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">        log.info(<span class="string">"count:&#123;&#125;"</span>, count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="例子分析："><a href="#例子分析：" class="headerlink" title="例子分析："></a>例子分析：</h5><p>简简单单，只是在核心方法执行前加锁，在之后的finally中解锁。</p><h5 id="RentrantReadWriteLock"><a href="#RentrantReadWriteLock" class="headerlink" title="RentrantReadWriteLock"></a>RentrantReadWriteLock</h5><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class LockExample3 &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;<span class="keyword">String</span>, Data&gt; <span class="built_in">map</span> = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock lock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock readLock = lock.readLock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock writeLock = lock.writeLock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Data <span class="built_in">get</span>(<span class="keyword">String</span> <span class="built_in">key</span>) &#123;</span><br><span class="line">        readLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">map</span>.<span class="built_in">get</span>(<span class="built_in">key</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            readLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Set&lt;<span class="keyword">String</span>&gt; getAllKeys() &#123;</span><br><span class="line">        readLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">map</span>.keySet();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            readLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Data put(<span class="keyword">String</span> <span class="built_in">key</span>, Data value) &#123;</span><br><span class="line">        writeLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">map</span>.put(<span class="built_in">key</span>, value);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            readLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="例子说明"><a href="#例子说明" class="headerlink" title="例子说明"></a>例子说明</h5><ol><li>其中使用了RentrantReadWriteLock，该锁是读写分离锁，即读操作和写操作分别持有一把锁。</li><li>而且由于该RentrantReadWriteLock的读锁是一种悲观锁，即只有当其他操作都执行完后才会进行写操作。那么，但实际应用中读操作是远远多于写操作的（一般情况下），那么可能会导致写操作产生线程饥饿。<blockquote><p><strong>悲观锁</strong>：对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度；因为悲观，认为自己的数据很容易在并发中产生错误，所以在整个数据处理过程中，将数据处于锁定状态.<br><strong>乐观锁</strong>：大多是基于数据版本记录机制实现；读取出数据时，将此版本号（version字段）一同读出，之后更新时，对此版本号加一；若提交的数据版本大于数据库表当前版本号，则予以更新，否则认为是过期数据。<br><strong>线程饥饿</strong>：通常是因为线程优先级过低，导致该线程等待被执行的时间过久，甚至执行操作已经无意义。</p></blockquote></li><li>因此，该类实际中用到的不多。</li></ol><h5 id="StampedLock"><a href="#StampedLock" class="headerlink" title="StampedLock"></a>StampedLock</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StampedLockExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">double</span> x, y;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> StampedLock sl = <span class="keyword">new</span> StampedLock();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">double</span> deltaX, <span class="keyword">double</span> deltaY)</span> </span>&#123; <span class="comment">// an exclusively locked method</span></span><br><span class="line">            <span class="keyword">long</span> stamp = sl.writeLock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                x += deltaX;</span><br><span class="line">                y += deltaY;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                sl.unlockWrite(stamp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//下面是乐观读锁案例</span></span><br><span class="line">        <span class="function"><span class="keyword">double</span> <span class="title">distanceFromOrigin</span><span class="params">()</span> </span>&#123; <span class="comment">// A read-only method</span></span><br><span class="line">            <span class="keyword">long</span> stamp = sl.tryOptimisticRead(); <span class="comment">//获得一个乐观读锁</span></span><br><span class="line">            <span class="keyword">double</span> currentX = x, currentY = y;  <span class="comment">//将两个字段读入本地局部变量</span></span><br><span class="line">            <span class="keyword">if</span> (!sl.validate(stamp)) &#123; <span class="comment">//检查发出乐观读锁后同时是否有其他写锁发生？</span></span><br><span class="line">                stamp = sl.readLock();  <span class="comment">//如果没有，我们再次获得一个读悲观锁</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    currentX = x; <span class="comment">// 将两个字段读入本地局部变量</span></span><br><span class="line">                    currentY = y; <span class="comment">// 将两个字段读入本地局部变量</span></span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    sl.unlockRead(stamp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> Math.sqrt(currentX * currentX + currentY * currentY);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//下面是悲观读锁案例</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">moveIfAtOrigin</span><span class="params">(<span class="keyword">double</span> newX, <span class="keyword">double</span> newY)</span> </span>&#123; <span class="comment">// upgrade</span></span><br><span class="line">            <span class="comment">// Could instead start with optimistic, not read mode</span></span><br><span class="line">            <span class="keyword">long</span> stamp = sl.readLock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (x == <span class="number">0.0</span> &amp;&amp; y == <span class="number">0.0</span>) &#123; <span class="comment">//循环，检查当前状态是否符合</span></span><br><span class="line">                    <span class="keyword">long</span> ws = sl.tryConvertToWriteLock(stamp); <span class="comment">//将读锁转为写锁</span></span><br><span class="line">                    <span class="keyword">if</span> (ws != <span class="number">0L</span>) &#123; <span class="comment">//这是确认转为写锁是否成功</span></span><br><span class="line">                        stamp = ws; <span class="comment">//如果成功 替换票据</span></span><br><span class="line">                        x = newX; <span class="comment">//进行状态改变</span></span><br><span class="line">                        y = newY;  <span class="comment">//进行状态改变</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123; <span class="comment">//如果不能成功转换为写锁</span></span><br><span class="line">                        sl.unlockRead(stamp);  <span class="comment">//我们显式释放读锁</span></span><br><span class="line">                        stamp = sl.writeLock();  <span class="comment">//显式直接进行写锁 然后再通过循环再试</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                sl.unlock(stamp); <span class="comment">//释放读锁或写锁</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="例子分析"><a href="#例子分析" class="headerlink" title="例子分析"></a>例子分析</h5><p>这个例子是JDK源码中提供的参考例子。相对于RentrantReadWriteLock，StampedLock的有三种控制锁的模式：写锁，读锁，乐观读锁(!!)。由于提供了乐观锁的实现机制，那么即使是在读操作占比很高的情况中，系统仍然可以保持较好性能和高IO吞吐量。</p><h6 id="StampedLock源码分析"><a href="#StampedLock源码分析" class="headerlink" title="StampedLock源码分析"></a>StampedLock源码分析</h6><p>先看顶部注释：<br><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * A capability-based lock <span class="keyword">with</span> three modes <span class="keyword">for</span> controlling read/write</span><br><span class="line"> * <span class="keyword">access</span>.  The state <span class="keyword">of</span> a StampedLock consists <span class="keyword">of</span> a version <span class="keyword">and</span> mode.</span><br><span class="line"> * Lock acquisition methods <span class="keyword">return</span> a stamp that represents <span class="keyword">and</span></span><br><span class="line"> * controls <span class="keyword">access</span> <span class="keyword">with</span> respect to a lock state; <span class="string">"try"</span> versions <span class="keyword">of</span></span><br><span class="line"> * these methods may instead <span class="keyword">return</span> the special value zero to</span><br><span class="line"> * represent failure to acquire <span class="keyword">access</span>. Lock release <span class="keyword">and</span> conversion</span><br><span class="line"> * methods require stamps as arguments, <span class="keyword">and</span> fail <span class="keyword">if</span> they <span class="keyword">do</span> <span class="keyword">not</span> match</span><br><span class="line"> * the state <span class="keyword">of</span> the lock. ……</span><br><span class="line"> *</span><br><span class="line"> *  &lt;li&gt;&lt;b&gt;Optimistic Reading.&lt;/b&gt; Method &#123;@link #tryOptimisticRead&#125;</span><br><span class="line"> *   returns a non-zero stamp only <span class="keyword">if</span> the lock <span class="keyword">is</span> <span class="keyword">not</span> currently held</span><br><span class="line"> *   <span class="keyword">in</span> write mode. Method &#123;@link #validate&#125; returns <span class="literal">true</span> <span class="keyword">if</span> the lock</span><br><span class="line"> *   has <span class="keyword">not</span> been acquired <span class="keyword">in</span> write mode since obtaining a given</span><br><span class="line"> *   stamp.  This mode can be thought <span class="keyword">of</span> as an extremely weak version</span><br><span class="line"> *   <span class="keyword">of</span> a read-lock, that can be broken by a writer <span class="keyword">at</span> any time.  The</span><br><span class="line"> *   <span class="keyword">use</span> <span class="keyword">of</span> optimistic mode <span class="keyword">for</span> short read-only code segments often</span><br><span class="line"> *   reduces contention <span class="keyword">and</span> improves throughput.  However, its <span class="keyword">use</span> <span class="keyword">is</span></span><br><span class="line"> *   inherently fragile.  Optimistic read sections should only read</span><br><span class="line"> *   fields <span class="keyword">and</span> hold them <span class="keyword">in</span> local variables <span class="keyword">for</span> later <span class="keyword">use</span> after</span><br><span class="line"> *   validation. Fields read <span class="keyword">while</span> <span class="keyword">in</span> optimistic mode may be wildly</span><br><span class="line"> *   inconsistent, so usage applies only <span class="keyword">when</span> you are familiar enough</span><br><span class="line"> *   <span class="keyword">with</span> data representations to check consistency <span class="keyword">and</span>/<span class="keyword">or</span> repeatedly</span><br><span class="line"> *   invoke method &#123;@code validate()&#125;.  <span class="keyword">For</span> example, such steps are</span><br><span class="line"> *   typically required <span class="keyword">when</span> first reading an object <span class="keyword">or</span> <span class="keyword">array</span></span><br><span class="line"> *   reference, <span class="keyword">and</span> <span class="keyword">then</span> accessing one <span class="keyword">of</span> its fields, elements <span class="keyword">or</span></span><br><span class="line"> *   methods. &lt;/li&gt;</span><br><span class="line"> *</span><br><span class="line">     * Algorithmic notes:</span><br><span class="line">     *</span><br><span class="line">     * The design employs elements <span class="keyword">of</span> Sequence locks</span><br><span class="line">     * (as used <span class="keyword">in</span> linux kernels; see Lameter<span class="symbol">'s</span></span><br><span class="line">     * http://www.lameter.com/gelato2005.pdf</span><br><span class="line">     * <span class="keyword">and</span> elsewhere; see</span><br><span class="line">     * Boehm<span class="symbol">'s</span> http://www.hpl.hp.com/techreports/<span class="number">2012</span>/HPL-<span class="number">2012</span>-<span class="number">68</span>.html)</span><br><span class="line">     * <span class="keyword">and</span> Ordered RW locks (see Shirako et al</span><br><span class="line">     * http://dl.acm.org/citation.cfm?id=<span class="number">2312015</span>)</span><br><span class="line">     *</span><br><span class="line">     * Conceptually, the primary state <span class="keyword">of</span> the lock includes a sequence</span><br><span class="line">     * number that <span class="keyword">is</span> odd <span class="keyword">when</span> write-locked <span class="keyword">and</span> even otherwise.</span><br><span class="line">     * However, this <span class="keyword">is</span> offset by a reader count that <span class="keyword">is</span> non-zero <span class="keyword">when</span></span><br><span class="line">     * read-locked.  The read count <span class="keyword">is</span> ignored <span class="keyword">when</span> validating</span><br><span class="line">     * <span class="string">"optimistic"</span> seqlock-reader-style stamps.  Because we must <span class="keyword">use</span></span><br><span class="line">     * a small finite number <span class="keyword">of</span> bits (currently <span class="number">7</span>) <span class="keyword">for</span> readers, a</span><br><span class="line">     * supplementary reader overflow word <span class="keyword">is</span> used <span class="keyword">when</span> the number <span class="keyword">of</span></span><br><span class="line">     * readers exceeds the count field. We <span class="keyword">do</span> this by treating the max</span><br><span class="line">     * reader count value (RBITS) as a spinlock protecting overflow</span><br><span class="line">     * updates.</span><br><span class="line">     *</span><br><span class="line">     * Waiters <span class="keyword">use</span> a modified form <span class="keyword">of</span> CLH lock used <span class="keyword">in</span></span><br><span class="line">     * AbstractQueuedSynchronizer (see its internal documentation <span class="keyword">for</span></span><br><span class="line">     * a fuller account), where each node <span class="keyword">is</span> <span class="keyword">tagged</span> (field mode) as</span><br><span class="line">     * either a reader <span class="keyword">or</span> writer. Sets <span class="keyword">of</span> waiting readers are grouped</span><br><span class="line">     * (linked) under a common node (field cowait) so act as a single</span><br><span class="line">     * node <span class="keyword">with</span> respect to most CLH mechanics.  By virtue <span class="keyword">of</span> the</span><br><span class="line">     * queue structure, wait nodes need <span class="keyword">not</span> actually carry sequence</span><br><span class="line">     * numbers; we know each <span class="keyword">is</span> greater than its predecessor.  This</span><br><span class="line">     * simplifies the scheduling policy to a mainly-FIFO scheme that</span><br><span class="line">     * incorporates elements <span class="keyword">of</span> Phase-Fair locks (see Brandenburg &amp;</span><br><span class="line">     * Anderson, especially http://www.cs.unc.edu/~bbb/diss/).  <span class="keyword">In</span></span><br><span class="line">     * particular, we <span class="keyword">use</span> the phase-fair anti-barging rule: <span class="keyword">If</span> an</span><br><span class="line">     * incoming reader arrives <span class="keyword">while</span> read lock <span class="keyword">is</span> held but there <span class="keyword">is</span> a</span><br><span class="line">     * queued writer, this incoming reader <span class="keyword">is</span> queued.  (This rule <span class="keyword">is</span></span><br><span class="line">     * responsible <span class="keyword">for</span> <span class="keyword">some</span> <span class="keyword">of</span> the complexity <span class="keyword">of</span> method acquireRead,</span><br><span class="line">     * but without it, the lock becomes highly unfair.) Method release</span><br><span class="line">     * does <span class="keyword">not</span> (<span class="keyword">and</span> sometimes cannot) itself wake up cowaiters. This</span><br><span class="line">     * <span class="keyword">is</span> done by the primary thread, but helped by any other threads</span><br><span class="line">     * <span class="keyword">with</span> nothing better to <span class="keyword">do</span> <span class="keyword">in</span> methods acquireRead <span class="keyword">and</span></span><br><span class="line">     * acquireWrite.</span><br><span class="line">     *</span><br><span class="line">     * These rules apply to threads actually queued. <span class="keyword">All</span> tryLock forms</span><br><span class="line">     * opportunistically try to acquire locks regardless <span class="keyword">of</span> preference</span><br><span class="line">     * rules, <span class="keyword">and</span> so may <span class="string">"barge"</span> their way <span class="keyword">in</span>.  Randomized spinning <span class="keyword">is</span></span><br><span class="line">     * used <span class="keyword">in</span> the acquire methods to reduce (increasingly expensive)</span><br><span class="line">     * context switching <span class="keyword">while</span> also avoiding sustained memory</span><br><span class="line">     * thrashing among many threads.  We limit spins to the head <span class="keyword">of</span></span><br><span class="line">     * queue. A thread spin-waits up to SPINS times (where each</span><br><span class="line">     * iteration decreases spin count <span class="keyword">with</span> <span class="number">50</span>% probability) before</span><br><span class="line">     * blocking. <span class="keyword">If</span>, upon wakening it fails to obtain lock, <span class="keyword">and</span> <span class="keyword">is</span></span><br><span class="line">     * still (<span class="keyword">or</span> becomes) the first waiting thread (which indicates</span><br><span class="line">     * that <span class="keyword">some</span> other thread barged <span class="keyword">and</span> obtained lock), it escalates</span><br><span class="line">     * spins (up to MAX_HEAD_SPINS) to reduce the likelihood <span class="keyword">of</span></span><br><span class="line">     * continually losing to barging threads.</span><br><span class="line">     *</span><br><span class="line">     * Nearly <span class="keyword">all</span> <span class="keyword">of</span> these mechanics are carried <span class="keyword">out</span> <span class="keyword">in</span> methods</span><br><span class="line">     * acquireWrite <span class="keyword">and</span> acquireRead, that, as typical <span class="keyword">of</span> such code,</span><br><span class="line">     * sprawl <span class="keyword">out</span> because actions <span class="keyword">and</span> retries rely on consistent sets</span><br><span class="line">     * <span class="keyword">of</span> locally cached reads.</span><br><span class="line">     *</span><br><span class="line">     * As noted <span class="keyword">in</span> Boehm<span class="symbol">'s</span> paper (above), sequence validation (mainly</span><br><span class="line">     * method validate()) requires stricter ordering rules than apply</span><br><span class="line">     * to normal volatile reads (<span class="keyword">of</span> <span class="string">"state"</span>).  To force orderings <span class="keyword">of</span></span><br><span class="line">     * reads before a validation <span class="keyword">and</span> the validation itself <span class="keyword">in</span> those</span><br><span class="line">     * cases where this <span class="keyword">is</span> <span class="keyword">not</span> already forced, we <span class="keyword">use</span></span><br><span class="line">     * Unsafe.loadFence.</span><br><span class="line">     *</span><br><span class="line">     * The memory layout keeps lock state <span class="keyword">and</span> queue pointers together</span><br><span class="line">     * (normally on the same cache line). This usually works well <span class="keyword">for</span></span><br><span class="line">     * read-mostly loads. <span class="keyword">In</span> most other cases, the natural tendency <span class="keyword">of</span></span><br><span class="line">     * adaptive-spin CLH locks to reduce memory contention lessens</span><br><span class="line">     * motivation to further spread <span class="keyword">out</span> contended locations, but might</span><br><span class="line">     * be subject to future improvements.</span><br><span class="line"> */</span><br></pre></td></tr></table></figure></p><p>看来这个类还是有、东西的。不过内容太多了，也不知从何看起。目前先了解一下大致情况，以后继续慢慢了解~</p><blockquote><p>答应我，不要吐~ 还是翻回去从头好好看一下，其中有用到AQS的CLH队列哦~</p></blockquote><p>（后接part-2）</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h4&gt;&lt;p&gt;RentrantLock即重入锁，是JDK中J.U.C提供的最重要的锁。&lt;br&gt;通过自旋锁实现RentrantLock：循环调用CAS操作实现枷锁，即&lt;strong&gt;阻止线程进入内核态被阻塞&lt;/strong&gt;，故而效率较高。&lt;/p&gt;
    
    </summary>
    
      <category term="Java之并发编程" scheme="http://suprisemf.github.io/categories/Java%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java" scheme="http://suprisemf.github.io/tags/Java/"/>
    
      <category term="并发编程" scheme="http://suprisemf.github.io/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
</feed>

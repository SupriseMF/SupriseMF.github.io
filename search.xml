<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>J.U.C之BlockingQueue</title>
      <link href="/2018/08/03/J-U-C%E4%B9%8BBlockingQueue/"/>
      <url>/2018/08/03/J-U-C%E4%B9%8BBlockingQueue/</url>
      <content type="html"><![CDATA[<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>BlockingQueue见名知意，即阻塞队列。它是一个线程安全的队列。<br>大致有两种情况：</p><ol><li>队列满了，但此时还有入队操作；</li><li>队列空了，但此时还有出队操作。<a id="more"></a><h4 id="场景分析"><a href="#场景分析" class="headerlink" title="场景分析"></a>场景分析</h4>主要应用在生产者-消费者场景。</li><li>生产者生产对象，并放入阻塞队列，直至队列已满，被阻塞。</li><li>消费者消费对象，从阻塞队列中取，直至队列已空，被阻塞。</li></ol><h4 id="队列操作方法"><a href="#队列操作方法" class="headerlink" title="队列操作方法"></a>队列操作方法</h4><p>一共有四套方法。</p><p><img src="/2018/08/03/J-U-C之BlockingQueue/blockingqueue.png" alt="图示"></p><h5 id="第一套方法：Throws-Exception"><a href="#第一套方法：Throws-Exception" class="headerlink" title="第一套方法：Throws Exception"></a>第一套方法：Throws Exception</h5><p>如果操作不能马上执行就会抛出异常。<br>type | method<br>-| -<br>Insert | add(o)<br>Remove  |  remove(o)<br>Examine  |  element()</p><h5 id="第二套方法：Special-Value"><a href="#第二套方法：Special-Value" class="headerlink" title="第二套方法：Special Value"></a>第二套方法：Special Value</h5><p>如果操作不能马上执行就会返回一个特殊值。一般是true/false<br>type | method<br>-| -<br>Insert | offer(o)<br>Remove  |  poll()<br>Examine  |  peek()</p><h5 id="第三套方法：Blocks"><a href="#第三套方法：Blocks" class="headerlink" title="第三套方法：Blocks"></a>第三套方法：Blocks</h5><p>如果操作不能马上执行就会进行阻塞操作。<br>type | method<br>-| -<br>Insert | put()<br>Remove  |  take()<br>Examine  |  无</p><h5 id="第四套方法：Times-Out"><a href="#第四套方法：Times-Out" class="headerlink" title="第四套方法：Times Out"></a>第四套方法：Times Out</h5><p>如果操作不能马上执行就会给定一个超时时间。如果超时时间已经过期还未执行就会返回一个特殊值。一般是true/false<br>type | method<br>-| -<br>Insert | offer(o，timeout，timeunit)<br>Remove  |  poll(timeout，timeunit)<br>Examine  | 无</p><h4 id="事件类"><a href="#事件类" class="headerlink" title="事件类"></a>事件类</h4><h5 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h5><ol><li>是一个有界的（容量有限,初始化时指定容量，之后不得更改）阻塞队列。</li><li>其内部实现为数组。</li><li>是以FIFO的方式存放数据。</li></ol><h5 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h5><ol><li>阻塞的对象是队列的内部元素。</li><li>其内部元素必须实现J.U.C中Delayed接口。Delayed接口继承了Comparable接口。说明DelayQueue中的元素需要排序。一般按照元素过期时间的优先级排序。</li><li>底层实现是：PriorityQueue和Lock。</li><li>使用场景广泛：连接的定时关闭、缓存对象、超时处理等。</li></ol><h5 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h5><ol><li>是BlockingQueue的一种链接版本。</li><li>见名知意，因为使用链接，故而若初始化时指定容量则是有界队列，否则默认队列的长度可变。</li><li>使用链接，故底层实现是链表。</li><li>是以FIFO的方式存放数据。</li></ol><h5 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h5><ol><li>见名知意，它是BlockingQueue的附加优先级的队列。</li><li>是一个无边界的队列，但有排序规则。</li><li>队列允许插入的元素为空（null）。</li><li>其内部元素必须实现Comparable接口。</li><li>队列中优先级的排序规则：通过自定义地对Comparable接口的实现来指定规则。</li><li>可以从PriorityBlockingQueue中获得一个迭代器（iterator），但并不保证按照队列中元素的优先级进行迭代。</li></ol><h5 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h5><ol><li>见名知意，即为“同步队列”。</li><li>队列内部仅允许容纳一个元素，即放入一个元素后只等待其被取走。</li><li>是一个无界非缓存队列。</li></ol>]]></content>
      
      <categories>
          
          <category> Java之并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>J.U.C之ForkJoin</title>
      <link href="/2018/08/03/J-U-C%E4%B9%8BForkJoin/"/>
      <url>/2018/08/03/J-U-C%E4%B9%8BForkJoin/</url>
      <content type="html"><![CDATA[<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>ForkJoin框架是JDK 1.7提供的一种用于并行任务执行的框架。有些像Hadoop中的MapReduce机制。即将一个大任务分为（fork）多个小任务分别执行，最后将多个小任务的执行结果进行汇总（join）。<br><a id="more"></a></p><blockquote><p>该框架采用的工作窃取算法，即<strong>当一个线程执行完它的任务后，可以从其他线程的任务队列尾部开始自行窃取任务进行执行，最后与该队列的另一个线程接头</strong>，以充分发挥该框架的优势（消除线程等待），提高效率，促进性能提升。<br>其中，每个线程的任务队列采用双端队列进行实现。<br>缺点：1. 当一个线程的双端队列中只有一个任务时，也会发生线程竞争。2. 由于使用双端队列，系统会分配更多的资源。</p></blockquote><h4 id="执行任务的局限性"><a href="#执行任务的局限性" class="headerlink" title="执行任务的局限性"></a>执行任务的局限性</h4><ol><li>任务只能使用Fork或Join作为同步机制；</li><li>线程队列中的任务不可以有IO操作；</li><li>任务不能抛出检查异常。（若有则需要必要的代码进行处理）</li></ol><h4 id="ForkJoinPool"><a href="#ForkJoinPool" class="headerlink" title="ForkJoinPool"></a>ForkJoinPool</h4><p>看一下注释：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * An &#123;@link ExecutorService&#125; <span class="keyword">for</span> <span class="built_in">running</span> &#123;@link ForkJoinTask&#125;s.</span><br><span class="line"> * A &#123;@code ForkJoinPool&#125; provides <span class="keyword">the</span> entry point <span class="keyword">for</span> submissions</span><br><span class="line"> * <span class="keyword">from</span> non-&#123;@code ForkJoinTask&#125; clients, <span class="keyword">as</span> well <span class="keyword">as</span> management <span class="keyword">and</span></span><br><span class="line"> * monitoring operations.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;A &#123;@code ForkJoinPool&#125; differs <span class="keyword">from</span> other kinds <span class="keyword">of</span> &#123;@link</span><br><span class="line"> * ExecutorService&#125; mainly <span class="keyword">by</span> virtue <span class="keyword">of</span> employing</span><br><span class="line"> * &lt;em&gt;work-stealing&lt;/em&gt;: all threads <span class="keyword">in</span> <span class="keyword">the</span> pool attempt <span class="keyword">to</span> find <span class="keyword">and</span></span><br><span class="line"> * execute tasks submitted <span class="keyword">to</span> <span class="keyword">the</span> pool <span class="keyword">and</span>/<span class="keyword">or</span> created <span class="keyword">by</span> other active</span><br><span class="line"> * tasks (eventually blocking waiting <span class="keyword">for</span> work <span class="keyword">if</span> none exist). This</span><br><span class="line"> * enables efficient processing when most tasks spawn other subtasks</span><br><span class="line"> * (<span class="keyword">as</span> do most &#123;@code ForkJoinTask&#125;s), <span class="keyword">as</span> well <span class="keyword">as</span> when many small</span><br><span class="line"> * tasks are submitted <span class="keyword">to</span> <span class="keyword">the</span> pool <span class="keyword">from</span> external clients.  Especially</span><br><span class="line"> * when setting &lt;em&gt;asyncMode&lt;/em&gt; <span class="keyword">to</span> <span class="literal">true</span> <span class="keyword">in</span> constructors, &#123;@code</span><br><span class="line"> * ForkJoinPool&#125;s may also be appropriate <span class="keyword">for</span> use <span class="keyword">with</span> event-style</span><br><span class="line"> * tasks <span class="keyword">that</span> are never joined.</span><br><span class="line"> */</span><br></pre></td></tr></table></figure></p><p>实质上，ForkJoinPool是一个从非ForkJoinTask的请求中，为运行中的ForkJoinTask的子任务提供切入点的ExecutorService。它不同于其他的ExecutorService，主要是它虚拟部署了任务窃取。尤其当在构造器中设置asyncMode为true时，ForkJoinPool也可能适当地使用事件模式的任务（从未被汇总过？？）。<br><strong>ForkJoinPool主要做实现：包括工作窃取算法、工作线程的管理、任务的状态管理、任务的执行信息等。</strong></p><h4 id="ForkJoinTask"><a href="#ForkJoinTask" class="headerlink" title="ForkJoinTask"></a>ForkJoinTask</h4><p>看下注释：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Abstract base <span class="built_in">class</span> <span class="keyword">for</span> tasks <span class="keyword">that</span> <span class="built_in">run</span> within a &#123;@link ForkJoinPool&#125;.</span><br><span class="line"> * A &#123;@code ForkJoinTask&#125; <span class="keyword">is</span> a thread-like entity <span class="keyword">that</span> <span class="keyword">is</span> much</span><br><span class="line"> * lighter weight than a normal thread.  Huge numbers <span class="keyword">of</span> tasks <span class="keyword">and</span></span><br><span class="line"> * subtasks may be hosted <span class="keyword">by</span> a small <span class="built_in">number</span> <span class="keyword">of</span> actual threads <span class="keyword">in</span> a</span><br><span class="line"> * ForkJoinPool, <span class="keyword">at</span> <span class="keyword">the</span> price <span class="keyword">of</span> <span class="keyword">some</span> usage limitations.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;A <span class="string">"main"</span> &#123;@code ForkJoinTask&#125; begins execution when <span class="keyword">it</span> <span class="keyword">is</span></span><br><span class="line"> * explicitly submitted <span class="keyword">to</span> a &#123;@link ForkJoinPool&#125;, <span class="keyword">or</span>, <span class="keyword">if</span> <span class="keyword">not</span> already</span><br><span class="line"> * engaged <span class="keyword">in</span> a ForkJoin computation, commenced <span class="keyword">in</span> <span class="keyword">the</span> &#123;@link</span><br><span class="line"> * ForkJoinPool<span class="comment">#commonPool()&#125; via &#123;@link #fork&#125;, &#123;@link #invoke&#125;, or</span></span><br><span class="line"> * related methods.  Once started, <span class="keyword">it</span> will usually <span class="keyword">in</span> turn start other</span><br><span class="line"> * subtasks.  As indicated <span class="keyword">by</span> <span class="keyword">the</span> <span class="built_in">name</span> <span class="keyword">of</span> this <span class="built_in">class</span>, many programs</span><br><span class="line"> * using &#123;@code ForkJoinTask&#125; employ only methods &#123;@link <span class="comment">#fork&#125; and</span></span><br><span class="line"> * &#123;@link <span class="comment">#join&#125;, or derivatives such as &#123;@link</span></span><br><span class="line"> * <span class="comment">#invokeAll(ForkJoinTask...) invokeAll&#125;.  However, this class also</span></span><br><span class="line"> * provides a <span class="built_in">number</span> <span class="keyword">of</span> other methods <span class="keyword">that</span> can come <span class="keyword">into</span> play <span class="keyword">in</span></span><br><span class="line"> * advanced usages, <span class="keyword">as</span> well <span class="keyword">as</span> extension mechanics <span class="keyword">that</span> allow support</span><br><span class="line"> * <span class="keyword">of</span> new forms <span class="keyword">of</span> fork/join processing.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;A &#123;@code ForkJoinTask&#125; <span class="keyword">is</span> a lightweight form <span class="keyword">of</span> &#123;@link Future&#125;.</span><br><span class="line"> * The efficiency <span class="keyword">of</span> &#123;@code ForkJoinTask&#125;s stems <span class="keyword">from</span> a <span class="keyword">set</span> <span class="keyword">of</span></span><br><span class="line"> * restrictions (<span class="keyword">that</span> are only partially statically enforceable)</span><br><span class="line"> * reflecting their main use <span class="keyword">as</span> computational tasks calculating pure</span><br><span class="line"> * functions <span class="keyword">or</span> operating <span class="keyword">on</span> purely isolated objects.  The primary</span><br><span class="line"> * coordination mechanisms are &#123;@link <span class="comment">#fork&#125;, that arranges</span></span><br><span class="line"> * asynchronous execution, <span class="keyword">and</span> &#123;@link <span class="comment">#join&#125;, that doesn't proceed</span></span><br><span class="line"> * <span class="keyword">until</span> <span class="keyword">the</span> task's <span class="literal">result</span> has been computed.  Computations should</span><br><span class="line"> * ideally avoid &#123;@code synchronized&#125; methods <span class="keyword">or</span> blocks, <span class="keyword">and</span> should</span><br><span class="line"> * minimize other blocking synchronization <span class="keyword">apart from</span> joining other</span><br><span class="line"> * tasks <span class="keyword">or</span> using synchronizers such <span class="keyword">as</span> Phasers <span class="keyword">that</span> are advertised <span class="keyword">to</span></span><br><span class="line"> * cooperate <span class="keyword">with</span> fork/join scheduling.</span><br><span class="line"> */</span><br></pre></td></tr></table></figure></p><p><strong>ForkJoinTask：主要提供任务中fork/join的机制。</strong></p><blockquote><p>我：大家自己意会一下，但可千万不要言传哦~ 真的很容易看懂的~<br>读者：emmmmm，是挺容易的，因为它容易就容易在它容易它奶奶的腿……</p></blockquote><h4 id="演示例子"><a href="#演示例子" class="headerlink" title="演示例子"></a>演示例子</h4><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line"><span class="keyword">public</span> class ForkJoinTaskExample extends RecursiveTask&lt;Integer&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> final <span class="keyword">int</span> threshold = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> start;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> <span class="built_in">end</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ForkJoinTaskExample(<span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.start = start;</span><br><span class="line">        <span class="keyword">this</span>.<span class="built_in">end</span> = <span class="built_in">end</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="keyword">protected</span> Integer compute() &#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果任务足够小就计算任务</span></span><br><span class="line">        <span class="keyword">boolean</span> canCompute = (<span class="built_in">end</span> - start) &lt;= threshold;</span><br><span class="line">        <span class="built_in">if</span> (canCompute) &#123;</span><br><span class="line">            <span class="built_in">for</span> (<span class="keyword">int</span> i = start; i &lt;= <span class="built_in">end</span>; i++) &#123;</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="built_in">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果任务大于阈值，就分裂成两个子任务计算</span></span><br><span class="line">            <span class="keyword">int</span> middle = (start + <span class="built_in">end</span>) / <span class="number">2</span>;</span><br><span class="line">            ForkJoinTaskExample leftTask = <span class="keyword">new</span> ForkJoinTaskExample(start, middle);</span><br><span class="line">            ForkJoinTaskExample rightTask = <span class="keyword">new</span> ForkJoinTaskExample(middle + <span class="number">1</span>, <span class="built_in">end</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 执行子任务</span></span><br><span class="line">            leftTask.fork();</span><br><span class="line">            rightTask.fork();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 等待任务执行结束合并其结果</span></span><br><span class="line">            <span class="keyword">int</span> leftResult = leftTask.join();</span><br><span class="line">            <span class="keyword">int</span> rightResult = rightTask.join();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 合并子任务</span></span><br><span class="line">            sum = leftResult + rightResult;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line">        ForkJoinPool forkjoinPool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//生成一个计算任务，计算1+2+3+4</span></span><br><span class="line">        ForkJoinTaskExample task = <span class="keyword">new</span> ForkJoinTaskExample(<span class="number">1</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//执行一个任务</span></span><br><span class="line">        Future&lt;Integer&gt; result = forkjoinPool.submit(task);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">try</span> &#123;</span><br><span class="line">            log.info(<span class="string">"result:&#123;&#125;"</span>, result.<span class="built_in">get</span>());</span><br><span class="line">        &#125; <span class="built_in">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">"exception"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="运行结果："><a href="#运行结果：" class="headerlink" title="运行结果："></a>运行结果：</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">14<span class="selector-pseudo">:58</span><span class="selector-pseudo">:35.442</span> <span class="selector-attr">[main]</span> <span class="selector-tag">INFO</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.aqs</span><span class="selector-class">.ForkJoinTaskExample</span> <span class="selector-tag">-</span> <span class="selector-tag">result</span><span class="selector-pseudo">:5050</span></span><br></pre></td></tr></table></figure><h5 id="例子分析"><a href="#例子分析" class="headerlink" title="例子分析"></a>例子分析</h5><ol><li>该测试类需要继承<code>RecursiveTask</code>类，即在任务<code>fork</code>中需要递归地拆分任务;</li><li><code>ForkJoinTaskExample task = new ForkJoinTaskExample(1, 100);</code>指定<code>start</code>和<code>end</code>，其构造函数完成其任务的<code>fork</code>的具体实现，之后再将其子结果<code>join</code>并返回。</li><li>最后通过ForkJoinPool调用submit()执行该任务。</li><li>其中：在任务拆分（fork）中，声明了一个threshold（阈值），即指定任务不可拆分的界限。</li></ol>]]></content>
      
      <categories>
          
          <category> Java之并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>J.U.C之FutureTask</title>
      <link href="/2018/08/03/J-U-C%E4%B9%8BFutureTask/"/>
      <url>/2018/08/03/J-U-C%E4%B9%8BFutureTask/</url>
      <content type="html"><![CDATA[<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><blockquote><p>由于线程是实现了Runnable接口或继承了Thread类，其执行后无法回调其线程的执行结果，因此JDK 1.5提供了一些新机制：接口Callable和Future。通过他们可以得到线程的执行结果。</p></blockquote><a id="more"></a><p>FutureTask间接实现了Future接口，并提供了一个基础的实现：开始/取消一个计算的方法，计算结果的查询。FutureTask可以被用来去包装一个Callable或Runnable对象，并可以被提交给Executor执行器去执行。除了被用作一个独立的服务类，它还提供了protected的功能，在定制任务类时会十分有用。（好吧，被你发现了，这是我翻译的源码中的类注释，哭唧唧~）</p><h4 id="Runnable与Callable对比"><a href="#Runnable与Callable对比" class="headerlink" title="Runnable与Callable对比"></a>Runnable与Callable对比</h4><ol><li>Runnable接口只有一个run()方法；</li><li>Callable是一个泛型接口，其中也只有V call()函数，其返回类型即传入的参数泛型。</li><li>两个接口功能相似，但后者因可以返回执行信息且支持泛型而更强大一些。</li></ol><h4 id="Future接口"><a href="#Future接口" class="headerlink" title="Future接口"></a>Future接口</h4><p>通过实现该类可以得到一个<strong>异步计算</strong>的返回结果。并提供方法接口：检查是否计算完成、等待计算的完成、取回计算的结果、判断计算是否在完成前被正常地取消。</p><h4 id="FutureTask类"><a href="#FutureTask类" class="headerlink" title="FutureTask类"></a>FutureTask类</h4><p>它实现了RunnableFuture接口，而RunnableFuture接口同时继承了Runnable接口和Future接口。即FutureTask类最终也是执行的Callable的方法。组合Runnable和Future的好处：可以另起线程去专门检查并调取最终计算的结果，而其他的线程可以继续其他任务（只需监听该跑腿线程即可）。</p><h4 id="演示例子-Callable和Future结合"><a href="#演示例子-Callable和Future结合" class="headerlink" title="演示例子-Callable和Future结合"></a>演示例子-Callable和Future结合</h4><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCallable</span> <span class="keyword"><span class="keyword">implements</span> <span class="type">Callable</span></span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">String</span> call() throws Exception &#123;</span><br><span class="line">            log.info(<span class="string">"do something in callable"</span>);</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Done"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="keyword">String</span>[] args) throws Exception &#123;</span><br><span class="line">        ExecutorService executorService = Executors.<span class="keyword">new</span><span class="type">CachedThreadPool</span>();</span><br><span class="line">        Future&lt;<span class="keyword">String</span>&gt; future = executorService.submit(<span class="keyword">new</span> <span class="type">MyCallable</span>());</span><br><span class="line">        log.info(<span class="string">"do something in main"</span>);</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">String</span> result = future.<span class="keyword">get</span>();</span><br><span class="line">        log.info(<span class="string">"result：&#123;&#125;"</span>, result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">11<span class="selector-pseudo">:29</span><span class="selector-pseudo">:00.230</span> <span class="selector-attr">[main]</span> <span class="selector-tag">INFO</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.aqs</span><span class="selector-class">.FutureExample</span> <span class="selector-tag">-</span> <span class="selector-tag">do</span> <span class="selector-tag">something</span> <span class="selector-tag">in</span> <span class="selector-tag">main</span></span><br><span class="line">11<span class="selector-pseudo">:29</span><span class="selector-pseudo">:00.230</span> <span class="selector-attr">[pool-1-thread-1]</span> <span class="selector-tag">INFO</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.aqs</span><span class="selector-class">.FutureExample</span> <span class="selector-tag">-</span> <span class="selector-tag">do</span> <span class="selector-tag">something</span> <span class="selector-tag">in</span> <span class="selector-tag">callable</span></span><br><span class="line">11<span class="selector-pseudo">:29</span><span class="selector-pseudo">:05.234</span> <span class="selector-attr">[main]</span> <span class="selector-tag">INFO</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.aqs</span><span class="selector-class">.FutureExample</span> <span class="selector-tag">-</span> <span class="selector-tag">result</span>：<span class="selector-tag">Done</span></span><br></pre></td></tr></table></figure><h5 id="例子分析"><a href="#例子分析" class="headerlink" title="例子分析"></a>例子分析</h5><ol><li>结合Callable和Future两者。</li><li>实现的Callable类可以被Executors的submit(xxx)提交给线程池运行。（之前提到过）</li><li>通过Future的get()查询并取回执行结果；若未执行结束则阻塞查询。（前面有说到）</li></ol><h4 id="演示例子-FutureTask"><a href="#演示例子-FutureTask" class="headerlink" title="演示例子-FutureTask"></a>演示例子-FutureTask</h4><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line"><span class="keyword">public</span> class FutureTaskExample &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        FutureTask&lt;<span class="keyword">String</span>&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;<span class="keyword">String</span>&gt;(<span class="keyword">new</span> Callable&lt;<span class="keyword">String</span>&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">String</span> call() <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                <span class="built_in">log</span>.info(<span class="string">"do something in callable"</span>);</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"Done"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(futureTask).start();</span><br><span class="line">        <span class="built_in">log</span>.info(<span class="string">"do something in main"</span>);</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">String</span> result = futureTask.<span class="built_in">get</span>();</span><br><span class="line">        <span class="built_in">log</span>.info(<span class="string">"result：&#123;&#125;"</span>, result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="运行结果-1"><a href="#运行结果-1" class="headerlink" title="运行结果"></a>运行结果</h5><p>与上个例子结果一模一样，运行速度快了25%左右：Callable和Future结合使用耗时2s 450ms，FutureTask耗时1s 890ms。</p><h4 id="看下源码"><a href="#看下源码" class="headerlink" title="看下源码"></a>看下源码</h4><p>get()方法的内核：返回执行完成的结果或抛出异常。<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns result or throws exception for completed task.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> s completed state value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="keyword">private</span> <span class="function">V <span class="title">report</span><span class="params">(<span class="keyword">int</span> s)</span> <span class="keyword">throws</span> ExecutionException </span>&#123;</span><br><span class="line">    Object x = outcome;</span><br><span class="line">    <span class="keyword">if</span> (s == NORMAL)</span><br><span class="line">        <span class="keyword">return</span> (V)x;</span><br><span class="line">    <span class="keyword">if</span> (s &gt;= CANCELLED)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> CancellationException();</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ExecutionException((Throwable)x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>还有一个可以指定返回执行结果的构造函数：（内部都是调用Executors的callable方法）<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> FutureTask(Runnable runnable, V result) &#123;</span><br><span class="line">    <span class="keyword">this</span>.callable = Executors.callable(runnable, result);</span><br><span class="line">    <span class="keyword">this</span>.state = <span class="keyword">NEW</span>;       <span class="comment">// ensure visibility of callable</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Callable&lt;T&gt; callable(Runnable <span class="keyword">task</span>, T result) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">task</span> == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RunnableAdapter&lt;T&gt;(<span class="keyword">task</span>, result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> RunnableAdapter&lt;T&gt; <span class="keyword">implements</span> Callable&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">final</span> Runnable <span class="keyword">task</span>;</span><br><span class="line">    <span class="keyword">final</span> T result;</span><br><span class="line">    RunnableAdapter(Runnable <span class="keyword">task</span>, T result) &#123;</span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">task</span> = <span class="keyword">task</span>;</span><br><span class="line">        <span class="keyword">this</span>.result = result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="keyword">call</span>() &#123;</span><br><span class="line">        <span class="keyword">task</span>.run();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>还有一个指定超时时间的get():<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V get(<span class="keyword">long</span> timeout, TimeUnit unit)</span><br><span class="line">    <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException &#123;</span><br><span class="line">    <span class="keyword">if</span> (unit == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> s = state;</span><br><span class="line">    <span class="keyword">if</span> (s &lt;= COMPLETING &amp;&amp;</span><br><span class="line">        (s = awaitDone(<span class="keyword">true</span>, unit.toNanos(timeout))) &lt;= COMPLETING)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();</span><br><span class="line">    <span class="function"><span class="keyword">return</span> <span class="title">report</span><span class="params">(s)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当计算失败时（不包括计算被取消）被内部的run()调用:报告其中的异常<br><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">protected void <span class="built_in">set</span>Exception(Throwable t) &#123;</span><br><span class="line">    if (UNSAFE.compareAndSwapInt(this, <span class="keyword">state</span>Offset, NEW, COMPLETING)) &#123;</span><br><span class="line">        outcome = t;</span><br><span class="line">        UNSAFE.putOrderedInt(this, <span class="keyword">state</span>Offset, EXCEPTIONAL); // final <span class="keyword">state</span></span><br><span class="line">        finishCompletion();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>一旦计算完成，该计算就不能被重启或取消了，除非调用runAndReset()方法：（之前概述提到）<br><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">protected boolean runAndReset() &#123;</span><br><span class="line">    if (<span class="keyword">state</span> != NEW ||</span><br><span class="line">        !UNSAFE.compareAndSwapObject(this, runnerOffset,</span><br><span class="line">                                     null, Thread.currentThread()))</span><br><span class="line">        return false;</span><br><span class="line">    boolean ran = false;</span><br><span class="line">    int s = <span class="keyword">state</span>;</span><br><span class="line">    try &#123;</span><br><span class="line">        Callable<span class="variable">&lt;V&gt;</span> c = callable;</span><br><span class="line">        if (c != null &amp;&amp; s == NEW) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                c.call(); // don't <span class="built_in">set</span> result</span><br><span class="line">                ran = true;</span><br><span class="line">            &#125; catch (Throwable ex) &#123;</span><br><span class="line">                <span class="built_in">set</span>Exception(ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        // runner must be non-null until <span class="keyword">state</span> is settled <span class="keyword">to</span></span><br><span class="line">        // prevent concurrent calls <span class="keyword">to</span> run()</span><br><span class="line">        runner = null;</span><br><span class="line">        // <span class="keyword">state</span> must be re-read after nulling runner <span class="keyword">to</span> prevent</span><br><span class="line">        // leaked interrupts</span><br><span class="line">        s = <span class="keyword">state</span>;</span><br><span class="line">        if (s &gt;= INTERRUPTING)</span><br><span class="line">            handlePossibleCancellationInterrupt(s);</span><br><span class="line">    &#125;</span><br><span class="line">    return ran &amp;&amp; s == NEW;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> Java之并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>J.U.C之AQS—RentrantLock-Part-2</title>
      <link href="/2018/08/03/JJ-U-C%E4%B9%8BAQS%E2%80%94RentrantLock-part-2/"/>
      <url>/2018/08/03/JJ-U-C%E4%B9%8BAQS%E2%80%94RentrantLock-part-2/</url>
      <content type="html"><![CDATA[<blockquote><p>这部分还是接着上部分的源码学习。<br><a id="more"></a></p></blockquote><h4 id="源码学习"><a href="#源码学习" class="headerlink" title="源码学习"></a>源码学习</h4><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Sync object for non-fair locks</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">7316153563782823691</span>L;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Performs lock.  Try immediate barge, backing up to normal</span></span><br><span class="line"><span class="comment">     * acquire on failure.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="function"><span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">return</span> <span class="title">nonfairTryAcquire</span><span class="params">(acquires)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Atomically sets synchronization state to the given updated</span></span><br><span class="line"><span class="comment"> * value if the current state value equals the expected value.</span></span><br><span class="line"><span class="comment"> * This operation has memory semantics of a &#123;<span class="doctag">@code</span> volatile&#125; read</span></span><br><span class="line"><span class="comment"> * and write.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> expect the expected value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> update the new value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if successful. False return indicates that the actual</span></span><br><span class="line"><span class="comment"> *         value was not equal to the expected value.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="function"><span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// See below for intrinsics setup to support this</span></span><br><span class="line">    <span class="function"><span class="keyword">return</span> unsafe.<span class="title">compareAndSwapInt</span><span class="params">(<span class="keyword">this</span>, stateOffset, expect, update)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Sets the thread that currently owns exclusive access.</span></span><br><span class="line"><span class="comment"> * A &#123;<span class="doctag">@code</span> null&#125; argument indicates that no thread owns access.</span></span><br><span class="line"><span class="comment"> * This method does not otherwise impose any synchronization or</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> volatile&#125; field accesses.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> thread the owner thread</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="function"><span class="keyword">void</span> <span class="title">setExclusiveOwnerThread</span><span class="params">(Thread thread)</span> </span>&#123;</span><br><span class="line">    exclusiveOwnerThread = thread;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Acquires in exclusive mode, ignoring interrupts.  Implemented</span></span><br><span class="line"><span class="comment"> * by invoking at least once &#123;<span class="doctag">@link</span> #tryAcquire&#125;,</span></span><br><span class="line"><span class="comment"> * returning on success.  Otherwise the thread is queued, possibly</span></span><br><span class="line"><span class="comment"> * repeatedly blocking and unblocking, invoking &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment"> * #tryAcquire&#125; until success.  This method can be used</span></span><br><span class="line"><span class="comment"> * to implement method &#123;<span class="doctag">@link</span> Lock#lock&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arg the acquire argument.  This value is conveyed to</span></span><br><span class="line"><span class="comment"> *        &#123;<span class="doctag">@link</span> #tryAcquire&#125; but is otherwise uninterpreted and</span></span><br><span class="line"><span class="comment"> *        can represent anything you like.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="function"><span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="function"><span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Convenience method to interrupt current thread.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">selfInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread.currentThread().interrupt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">interrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> != Thread.currentThread())</span><br><span class="line">        checkAccess();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (blockerLock) &#123;</span><br><span class="line">        Interruptible b = blocker;</span><br><span class="line">        <span class="keyword">if</span> (b != <span class="keyword">null</span>) &#123;</span><br><span class="line">            interrupt0();           <span class="comment">// Just to set the interrupt flag</span></span><br><span class="line">            b.interrupt(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    interrupt0();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="function"><span class="keyword">void</span> <span class="title">interrupt0</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h4 id="配合的Condition"><a href="#配合的Condition" class="headerlink" title="配合的Condition"></a>配合的Condition</h4><p>在下篇手记-介绍Condition中有详细分析~</p><h4 id="小总结："><a href="#小总结：" class="headerlink" title="小总结："></a>小总结：</h4><ol><li>synchronized关键字：它是由JVM实现，并有很多内存监控工具提供帮助，并通过这些工具配合synchronized的内存标识，进行内存层面的“debug”或观察；当运行时出现异常，JVM会自动解锁并进行处理。</li><li>ReentrantLock、ReentrantReadWriteLock、StampedLock是对象层面的锁，需要手动指定加锁与解锁操作（放在finally中）。</li><li>StampedLock：因为加入乐观锁，故对吞吐量有较大的优化，尤其是读多写少时。但使用起来较复杂，API内容较多。</li><li>当线程较少推荐使用synchronized关键字，简单效率高；当线程较多，且线程并发的增长有一定趋势时（可预估），推荐使用ReentrantLock。</li></ol>]]></content>
      
      <categories>
          
          <category> Java之并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>J.U.C之AQS—RentrantLock-Part-1</title>
      <link href="/2018/08/03/JJ-U-C%E4%B9%8BAQS%E2%80%94RentrantLock-part-1/"/>
      <url>/2018/08/03/JJ-U-C%E4%B9%8BAQS%E2%80%94RentrantLock-part-1/</url>
      <content type="html"><![CDATA[<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>RentrantLock即重入锁，是JDK中J.U.C提供的最重要的锁。<br>通过自旋锁实现RentrantLock：循环调用CAS操作实现枷锁，即<strong>阻止线程进入内核态被阻塞</strong>，故而效率较高。</p><a id="more"></a><h4 id="与Synchronized对比"><a href="#与Synchronized对比" class="headerlink" title="与Synchronized对比"></a>与Synchronized对比</h4><ol><li>可重入性：两者都具有可重入性。</li><li>锁的实现：RentrantLock是JDK中源码实现；Synchronized的锁机制是由JVM的JMM机制管理实现。</li><li>性能区别：Synchronized关键字优化前，其性能很差；但优化后（借鉴了RentrantLock中的CAS机制：在用户态加锁解锁），引入了偏向锁、自旋锁后，两者性能几无差异。（更推荐synchronized）。</li><li>功能区别：(1).synchronized关键字使用更加简洁简单，由编译器保证实现；RentrantLock需声明锁，并加锁，在finally中解锁。(2).RentrantLock锁粒度更细，灵活度高。</li></ol><blockquote><p>公平锁即按照线程的请求的先后顺序给与锁；非公平锁即按照对锁的争夺成功的线程加锁。</p></blockquote><h4 id="特有功能："><a href="#特有功能：" class="headerlink" title="特有功能："></a>特有功能：</h4><ol><li>RentrantLock可以指定该lock是公平锁或非公平锁（而synchronized只能是非公平锁）；</li><li>通过方法提供Condition类，可以分组唤醒需要唤醒的线程。</li><li>提供能够中断等待锁的线程的机制 –&gt; lock.lockInterruptibly()</li></ol><h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><p>当需要用到上面RentrantLock的特有功能时，必须使用RentrantLock。</p><h4 id="演示例子"><a href="#演示例子" class="headerlink" title="演示例子"></a>演示例子</h4><h5 id="RentrantLock"><a href="#RentrantLock" class="headerlink" title="RentrantLock"></a>RentrantLock</h5><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockExample2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> clientTotal = <span class="number">5000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> threadTotal = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(threadTotal);</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(clientTotal);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clientTotal ; i++) &#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    add();</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.<span class="keyword">error</span>(<span class="string">"exception"</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">        log.info(<span class="string">"count:&#123;&#125;"</span>, count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="例子分析："><a href="#例子分析：" class="headerlink" title="例子分析："></a>例子分析：</h5><p>简简单单，只是在核心方法执行前加锁，在之后的finally中解锁。</p><h5 id="RentrantReadWriteLock"><a href="#RentrantReadWriteLock" class="headerlink" title="RentrantReadWriteLock"></a>RentrantReadWriteLock</h5><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class LockExample3 &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;<span class="keyword">String</span>, Data&gt; <span class="built_in">map</span> = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock lock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock readLock = lock.readLock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock writeLock = lock.writeLock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Data <span class="built_in">get</span>(<span class="keyword">String</span> <span class="built_in">key</span>) &#123;</span><br><span class="line">        readLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">map</span>.<span class="built_in">get</span>(<span class="built_in">key</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            readLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Set&lt;<span class="keyword">String</span>&gt; getAllKeys() &#123;</span><br><span class="line">        readLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">map</span>.keySet();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            readLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Data put(<span class="keyword">String</span> <span class="built_in">key</span>, Data value) &#123;</span><br><span class="line">        writeLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">map</span>.put(<span class="built_in">key</span>, value);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            readLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="例子说明"><a href="#例子说明" class="headerlink" title="例子说明"></a>例子说明</h5><ol><li>其中使用了RentrantReadWriteLock，该锁是读写分离锁，即读操作和写操作分别持有一把锁。</li><li>而且由于该RentrantReadWriteLock的读锁是一种悲观锁，即只有当其他操作都执行完后才会进行写操作。那么，但实际应用中读操作是远远多于写操作的（一般情况下），那么可能会导致写操作产生线程饥饿。<blockquote><p><strong>悲观锁</strong>：对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度；因为悲观，认为自己的数据很容易在并发中产生错误，所以在整个数据处理过程中，将数据处于锁定状态.<br><strong>乐观锁</strong>：大多是基于数据版本记录机制实现；读取出数据时，将此版本号（version字段）一同读出，之后更新时，对此版本号加一；若提交的数据版本大于数据库表当前版本号，则予以更新，否则认为是过期数据。<br><strong>线程饥饿</strong>：通常是因为线程优先级过低，导致该线程等待被执行的时间过久，甚至执行操作已经无意义。</p></blockquote></li><li>因此，该类实际中用到的不多。</li></ol><h5 id="StampedLock"><a href="#StampedLock" class="headerlink" title="StampedLock"></a>StampedLock</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StampedLockExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">double</span> x, y;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> StampedLock sl = <span class="keyword">new</span> StampedLock();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">double</span> deltaX, <span class="keyword">double</span> deltaY)</span> </span>&#123; <span class="comment">// an exclusively locked method</span></span><br><span class="line">            <span class="keyword">long</span> stamp = sl.writeLock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                x += deltaX;</span><br><span class="line">                y += deltaY;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                sl.unlockWrite(stamp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//下面是乐观读锁案例</span></span><br><span class="line">        <span class="function"><span class="keyword">double</span> <span class="title">distanceFromOrigin</span><span class="params">()</span> </span>&#123; <span class="comment">// A read-only method</span></span><br><span class="line">            <span class="keyword">long</span> stamp = sl.tryOptimisticRead(); <span class="comment">//获得一个乐观读锁</span></span><br><span class="line">            <span class="keyword">double</span> currentX = x, currentY = y;  <span class="comment">//将两个字段读入本地局部变量</span></span><br><span class="line">            <span class="keyword">if</span> (!sl.validate(stamp)) &#123; <span class="comment">//检查发出乐观读锁后同时是否有其他写锁发生？</span></span><br><span class="line">                stamp = sl.readLock();  <span class="comment">//如果没有，我们再次获得一个读悲观锁</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    currentX = x; <span class="comment">// 将两个字段读入本地局部变量</span></span><br><span class="line">                    currentY = y; <span class="comment">// 将两个字段读入本地局部变量</span></span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    sl.unlockRead(stamp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> Math.sqrt(currentX * currentX + currentY * currentY);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//下面是悲观读锁案例</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">moveIfAtOrigin</span><span class="params">(<span class="keyword">double</span> newX, <span class="keyword">double</span> newY)</span> </span>&#123; <span class="comment">// upgrade</span></span><br><span class="line">            <span class="comment">// Could instead start with optimistic, not read mode</span></span><br><span class="line">            <span class="keyword">long</span> stamp = sl.readLock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (x == <span class="number">0.0</span> &amp;&amp; y == <span class="number">0.0</span>) &#123; <span class="comment">//循环，检查当前状态是否符合</span></span><br><span class="line">                    <span class="keyword">long</span> ws = sl.tryConvertToWriteLock(stamp); <span class="comment">//将读锁转为写锁</span></span><br><span class="line">                    <span class="keyword">if</span> (ws != <span class="number">0L</span>) &#123; <span class="comment">//这是确认转为写锁是否成功</span></span><br><span class="line">                        stamp = ws; <span class="comment">//如果成功 替换票据</span></span><br><span class="line">                        x = newX; <span class="comment">//进行状态改变</span></span><br><span class="line">                        y = newY;  <span class="comment">//进行状态改变</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123; <span class="comment">//如果不能成功转换为写锁</span></span><br><span class="line">                        sl.unlockRead(stamp);  <span class="comment">//我们显式释放读锁</span></span><br><span class="line">                        stamp = sl.writeLock();  <span class="comment">//显式直接进行写锁 然后再通过循环再试</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                sl.unlock(stamp); <span class="comment">//释放读锁或写锁</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="例子分析"><a href="#例子分析" class="headerlink" title="例子分析"></a>例子分析</h5><p>这个例子是JDK源码中提供的参考例子。相对于RentrantReadWriteLock，StampedLock的有三种控制锁的模式：写锁，读锁，乐观读锁(!!)。由于提供了乐观锁的实现机制，那么即使是在读操作占比很高的情况中，系统仍然可以保持较好性能和高IO吞吐量。</p><h6 id="StampedLock源码分析"><a href="#StampedLock源码分析" class="headerlink" title="StampedLock源码分析"></a>StampedLock源码分析</h6><p>先看顶部注释：<br><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * A capability-based lock <span class="keyword">with</span> three modes <span class="keyword">for</span> controlling read/write</span><br><span class="line"> * <span class="keyword">access</span>.  The state <span class="keyword">of</span> a StampedLock consists <span class="keyword">of</span> a version <span class="keyword">and</span> mode.</span><br><span class="line"> * Lock acquisition methods <span class="keyword">return</span> a stamp that represents <span class="keyword">and</span></span><br><span class="line"> * controls <span class="keyword">access</span> <span class="keyword">with</span> respect to a lock state; <span class="string">"try"</span> versions <span class="keyword">of</span></span><br><span class="line"> * these methods may instead <span class="keyword">return</span> the special value zero to</span><br><span class="line"> * represent failure to acquire <span class="keyword">access</span>. Lock release <span class="keyword">and</span> conversion</span><br><span class="line"> * methods require stamps as arguments, <span class="keyword">and</span> fail <span class="keyword">if</span> they <span class="keyword">do</span> <span class="keyword">not</span> match</span><br><span class="line"> * the state <span class="keyword">of</span> the lock. ……</span><br><span class="line"> *</span><br><span class="line"> *  &lt;li&gt;&lt;b&gt;Optimistic Reading.&lt;/b&gt; Method &#123;@link #tryOptimisticRead&#125;</span><br><span class="line"> *   returns a non-zero stamp only <span class="keyword">if</span> the lock <span class="keyword">is</span> <span class="keyword">not</span> currently held</span><br><span class="line"> *   <span class="keyword">in</span> write mode. Method &#123;@link #validate&#125; returns <span class="literal">true</span> <span class="keyword">if</span> the lock</span><br><span class="line"> *   has <span class="keyword">not</span> been acquired <span class="keyword">in</span> write mode since obtaining a given</span><br><span class="line"> *   stamp.  This mode can be thought <span class="keyword">of</span> as an extremely weak version</span><br><span class="line"> *   <span class="keyword">of</span> a read-lock, that can be broken by a writer <span class="keyword">at</span> any time.  The</span><br><span class="line"> *   <span class="keyword">use</span> <span class="keyword">of</span> optimistic mode <span class="keyword">for</span> short read-only code segments often</span><br><span class="line"> *   reduces contention <span class="keyword">and</span> improves throughput.  However, its <span class="keyword">use</span> <span class="keyword">is</span></span><br><span class="line"> *   inherently fragile.  Optimistic read sections should only read</span><br><span class="line"> *   fields <span class="keyword">and</span> hold them <span class="keyword">in</span> local variables <span class="keyword">for</span> later <span class="keyword">use</span> after</span><br><span class="line"> *   validation. Fields read <span class="keyword">while</span> <span class="keyword">in</span> optimistic mode may be wildly</span><br><span class="line"> *   inconsistent, so usage applies only <span class="keyword">when</span> you are familiar enough</span><br><span class="line"> *   <span class="keyword">with</span> data representations to check consistency <span class="keyword">and</span>/<span class="keyword">or</span> repeatedly</span><br><span class="line"> *   invoke method &#123;@code validate()&#125;.  <span class="keyword">For</span> example, such steps are</span><br><span class="line"> *   typically required <span class="keyword">when</span> first reading an object <span class="keyword">or</span> <span class="keyword">array</span></span><br><span class="line"> *   reference, <span class="keyword">and</span> <span class="keyword">then</span> accessing one <span class="keyword">of</span> its fields, elements <span class="keyword">or</span></span><br><span class="line"> *   methods. &lt;/li&gt;</span><br><span class="line"> *</span><br><span class="line">     * Algorithmic notes:</span><br><span class="line">     *</span><br><span class="line">     * The design employs elements <span class="keyword">of</span> Sequence locks</span><br><span class="line">     * (as used <span class="keyword">in</span> linux kernels; see Lameter<span class="symbol">'s</span></span><br><span class="line">     * http://www.lameter.com/gelato2005.pdf</span><br><span class="line">     * <span class="keyword">and</span> elsewhere; see</span><br><span class="line">     * Boehm<span class="symbol">'s</span> http://www.hpl.hp.com/techreports/<span class="number">2012</span>/HPL-<span class="number">2012</span>-<span class="number">68</span>.html)</span><br><span class="line">     * <span class="keyword">and</span> Ordered RW locks (see Shirako et al</span><br><span class="line">     * http://dl.acm.org/citation.cfm?id=<span class="number">2312015</span>)</span><br><span class="line">     *</span><br><span class="line">     * Conceptually, the primary state <span class="keyword">of</span> the lock includes a sequence</span><br><span class="line">     * number that <span class="keyword">is</span> odd <span class="keyword">when</span> write-locked <span class="keyword">and</span> even otherwise.</span><br><span class="line">     * However, this <span class="keyword">is</span> offset by a reader count that <span class="keyword">is</span> non-zero <span class="keyword">when</span></span><br><span class="line">     * read-locked.  The read count <span class="keyword">is</span> ignored <span class="keyword">when</span> validating</span><br><span class="line">     * <span class="string">"optimistic"</span> seqlock-reader-style stamps.  Because we must <span class="keyword">use</span></span><br><span class="line">     * a small finite number <span class="keyword">of</span> bits (currently <span class="number">7</span>) <span class="keyword">for</span> readers, a</span><br><span class="line">     * supplementary reader overflow word <span class="keyword">is</span> used <span class="keyword">when</span> the number <span class="keyword">of</span></span><br><span class="line">     * readers exceeds the count field. We <span class="keyword">do</span> this by treating the max</span><br><span class="line">     * reader count value (RBITS) as a spinlock protecting overflow</span><br><span class="line">     * updates.</span><br><span class="line">     *</span><br><span class="line">     * Waiters <span class="keyword">use</span> a modified form <span class="keyword">of</span> CLH lock used <span class="keyword">in</span></span><br><span class="line">     * AbstractQueuedSynchronizer (see its internal documentation <span class="keyword">for</span></span><br><span class="line">     * a fuller account), where each node <span class="keyword">is</span> <span class="keyword">tagged</span> (field mode) as</span><br><span class="line">     * either a reader <span class="keyword">or</span> writer. Sets <span class="keyword">of</span> waiting readers are grouped</span><br><span class="line">     * (linked) under a common node (field cowait) so act as a single</span><br><span class="line">     * node <span class="keyword">with</span> respect to most CLH mechanics.  By virtue <span class="keyword">of</span> the</span><br><span class="line">     * queue structure, wait nodes need <span class="keyword">not</span> actually carry sequence</span><br><span class="line">     * numbers; we know each <span class="keyword">is</span> greater than its predecessor.  This</span><br><span class="line">     * simplifies the scheduling policy to a mainly-FIFO scheme that</span><br><span class="line">     * incorporates elements <span class="keyword">of</span> Phase-Fair locks (see Brandenburg &amp;</span><br><span class="line">     * Anderson, especially http://www.cs.unc.edu/~bbb/diss/).  <span class="keyword">In</span></span><br><span class="line">     * particular, we <span class="keyword">use</span> the phase-fair anti-barging rule: <span class="keyword">If</span> an</span><br><span class="line">     * incoming reader arrives <span class="keyword">while</span> read lock <span class="keyword">is</span> held but there <span class="keyword">is</span> a</span><br><span class="line">     * queued writer, this incoming reader <span class="keyword">is</span> queued.  (This rule <span class="keyword">is</span></span><br><span class="line">     * responsible <span class="keyword">for</span> <span class="keyword">some</span> <span class="keyword">of</span> the complexity <span class="keyword">of</span> method acquireRead,</span><br><span class="line">     * but without it, the lock becomes highly unfair.) Method release</span><br><span class="line">     * does <span class="keyword">not</span> (<span class="keyword">and</span> sometimes cannot) itself wake up cowaiters. This</span><br><span class="line">     * <span class="keyword">is</span> done by the primary thread, but helped by any other threads</span><br><span class="line">     * <span class="keyword">with</span> nothing better to <span class="keyword">do</span> <span class="keyword">in</span> methods acquireRead <span class="keyword">and</span></span><br><span class="line">     * acquireWrite.</span><br><span class="line">     *</span><br><span class="line">     * These rules apply to threads actually queued. <span class="keyword">All</span> tryLock forms</span><br><span class="line">     * opportunistically try to acquire locks regardless <span class="keyword">of</span> preference</span><br><span class="line">     * rules, <span class="keyword">and</span> so may <span class="string">"barge"</span> their way <span class="keyword">in</span>.  Randomized spinning <span class="keyword">is</span></span><br><span class="line">     * used <span class="keyword">in</span> the acquire methods to reduce (increasingly expensive)</span><br><span class="line">     * context switching <span class="keyword">while</span> also avoiding sustained memory</span><br><span class="line">     * thrashing among many threads.  We limit spins to the head <span class="keyword">of</span></span><br><span class="line">     * queue. A thread spin-waits up to SPINS times (where each</span><br><span class="line">     * iteration decreases spin count <span class="keyword">with</span> <span class="number">50</span>% probability) before</span><br><span class="line">     * blocking. <span class="keyword">If</span>, upon wakening it fails to obtain lock, <span class="keyword">and</span> <span class="keyword">is</span></span><br><span class="line">     * still (<span class="keyword">or</span> becomes) the first waiting thread (which indicates</span><br><span class="line">     * that <span class="keyword">some</span> other thread barged <span class="keyword">and</span> obtained lock), it escalates</span><br><span class="line">     * spins (up to MAX_HEAD_SPINS) to reduce the likelihood <span class="keyword">of</span></span><br><span class="line">     * continually losing to barging threads.</span><br><span class="line">     *</span><br><span class="line">     * Nearly <span class="keyword">all</span> <span class="keyword">of</span> these mechanics are carried <span class="keyword">out</span> <span class="keyword">in</span> methods</span><br><span class="line">     * acquireWrite <span class="keyword">and</span> acquireRead, that, as typical <span class="keyword">of</span> such code,</span><br><span class="line">     * sprawl <span class="keyword">out</span> because actions <span class="keyword">and</span> retries rely on consistent sets</span><br><span class="line">     * <span class="keyword">of</span> locally cached reads.</span><br><span class="line">     *</span><br><span class="line">     * As noted <span class="keyword">in</span> Boehm<span class="symbol">'s</span> paper (above), sequence validation (mainly</span><br><span class="line">     * method validate()) requires stricter ordering rules than apply</span><br><span class="line">     * to normal volatile reads (<span class="keyword">of</span> <span class="string">"state"</span>).  To force orderings <span class="keyword">of</span></span><br><span class="line">     * reads before a validation <span class="keyword">and</span> the validation itself <span class="keyword">in</span> those</span><br><span class="line">     * cases where this <span class="keyword">is</span> <span class="keyword">not</span> already forced, we <span class="keyword">use</span></span><br><span class="line">     * Unsafe.loadFence.</span><br><span class="line">     *</span><br><span class="line">     * The memory layout keeps lock state <span class="keyword">and</span> queue pointers together</span><br><span class="line">     * (normally on the same cache line). This usually works well <span class="keyword">for</span></span><br><span class="line">     * read-mostly loads. <span class="keyword">In</span> most other cases, the natural tendency <span class="keyword">of</span></span><br><span class="line">     * adaptive-spin CLH locks to reduce memory contention lessens</span><br><span class="line">     * motivation to further spread <span class="keyword">out</span> contended locations, but might</span><br><span class="line">     * be subject to future improvements.</span><br><span class="line"> */</span><br></pre></td></tr></table></figure></p><p>看来这个类还是有、东西的。不过内容太多了，也不知从何看起。目前先了解一下大致情况，以后继续慢慢了解~</p><blockquote><p>答应我，不要吐~ 还是翻回去从头好好看一下，其中有用到AQS的CLH队列哦~</p></blockquote><p>（后接part-2）</p>]]></content>
      
      <categories>
          
          <category> Java之并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>J.U.C之AQS—Condition</title>
      <link href="/2018/08/03/J-U-C%E4%B9%8BAQS%E2%80%94Condition/"/>
      <url>/2018/08/03/J-U-C%E4%B9%8BAQS%E2%80%94Condition/</url>
      <content type="html"><![CDATA[<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>他是一个接口类。</p><h4 id="演示例子"><a href="#演示例子" class="headerlink" title="演示例子"></a>演示例子</h4><a id="more"></a><h5 id="结合重入锁ReentrantLock："><a href="#结合重入锁ReentrantLock：" class="headerlink" title="结合重入锁ReentrantLock："></a>结合重入锁ReentrantLock：</h5><figure class="highlight pony"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">@<span class="type">Slf4j</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">LockExample6</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    public static void main(<span class="type">String</span>[] args) &#123;</span><br><span class="line">        <span class="type">ReentrantLock</span> reentrantLock = <span class="function"><span class="keyword">new</span> <span class="title">ReentrantLock</span>();</span></span><br><span class="line"><span class="function">        <span class="title">Condition</span> <span class="title">condition</span> = <span class="title">reentrantLock</span>.<span class="title">newCondition</span>();</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">        <span class="comment">//执行顺序用数字标出</span></span></span><br><span class="line"><span class="function">        <span class="title">new</span> <span class="title">Thread</span>(() -&gt; &#123;<span class="comment">//线程1</span></span></span><br><span class="line"><span class="function">            <span class="title">try</span> &#123;</span></span><br><span class="line"><span class="function">                <span class="title">reentrantLock</span>.<span class="title">lock</span>();</span></span><br><span class="line"><span class="function">                <span class="title">log</span>.<span class="title">info</span>("wait signal"); <span class="comment">// 1</span></span></span><br><span class="line"><span class="function">                <span class="title">condition</span>.<span class="title">await</span>();</span></span><br><span class="line"><span class="function">            &#125; <span class="title">catch</span> (<span class="type">InterruptedException</span> e) &#123;</span></span><br><span class="line"><span class="function">                <span class="title">e</span>.<span class="title">printStackTrace</span>();</span></span><br><span class="line"><span class="function">            &#125;</span></span><br><span class="line"><span class="function">            <span class="title">log</span>.<span class="title">info</span>("get signal"); <span class="comment">// 4</span></span></span><br><span class="line"><span class="function">            <span class="title">reentrantLock</span>.<span class="title">unlock</span>();</span></span><br><span class="line"><span class="function">        &#125;).<span class="title">start</span>();</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">        <span class="title">new</span> <span class="title">Thread</span>(() -&gt; &#123;<span class="comment">//线程2</span></span></span><br><span class="line"><span class="function">            <span class="title">reentrantLock</span>.<span class="title">lock</span>();</span></span><br><span class="line"><span class="function">            <span class="title">log</span>.<span class="title">info</span>("get lock"); <span class="comment">// 2</span></span></span><br><span class="line"><span class="function">            <span class="title">try</span> &#123;</span></span><br><span class="line"><span class="function">                <span class="title">Thread</span>.<span class="title">sleep</span>(<span class="number">3000</span>);</span></span><br><span class="line"><span class="function">            &#125; <span class="title">catch</span> (<span class="type">InterruptedException</span> e) &#123;</span></span><br><span class="line"><span class="function">                <span class="title">e</span>.<span class="title">printStackTrace</span>();</span></span><br><span class="line"><span class="function">            &#125;</span></span><br><span class="line"><span class="function">            <span class="title">condition</span>.<span class="title">signalAll</span>();</span></span><br><span class="line"><span class="function">            <span class="title">log</span>.<span class="title">info</span>("send signal ~ "); <span class="comment">// 3</span></span></span><br><span class="line"><span class="function">            <span class="title">reentrantLock</span>.<span class="title">unlock</span>();</span></span><br><span class="line"><span class="function">        &#125;).<span class="title">start</span>();</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><h5 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">09<span class="selector-pseudo">:39</span><span class="selector-pseudo">:54.468</span> <span class="selector-attr">[Thread-0]</span> <span class="selector-tag">INFO</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.lock</span><span class="selector-class">.LockExample6</span> <span class="selector-tag">-</span> <span class="selector-tag">wait</span> <span class="selector-tag">signal</span></span><br><span class="line">09<span class="selector-pseudo">:39</span><span class="selector-pseudo">:54.476</span> <span class="selector-attr">[Thread-1]</span> <span class="selector-tag">INFO</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.lock</span><span class="selector-class">.LockExample6</span> <span class="selector-tag">-</span> <span class="selector-tag">get</span> <span class="selector-tag">lock</span></span><br><span class="line">09<span class="selector-pseudo">:39</span><span class="selector-pseudo">:57.476</span> <span class="selector-attr">[Thread-1]</span> <span class="selector-tag">INFO</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.lock</span><span class="selector-class">.LockExample6</span> <span class="selector-tag">-</span> <span class="selector-tag">send</span> <span class="selector-tag">signal</span> ~</span><br><span class="line">09<span class="selector-pseudo">:39</span><span class="selector-pseudo">:57.476</span> <span class="selector-attr">[Thread-0]</span> <span class="selector-tag">INFO</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.lock</span><span class="selector-class">.LockExample6</span> <span class="selector-tag">-</span> <span class="selector-tag">get</span> <span class="selector-tag">signal</span></span><br></pre></td></tr></table></figure><h5 id="例子分析"><a href="#例子分析" class="headerlink" title="例子分析"></a>例子分析</h5><ol><li>可以看出输出的日志是与我们提到的执行顺序是对应的。</li><li>首先声明定义一个reentrantlock实例，并调用它的newCondition()创建一个condition实例并取出；</li><li>然后当线程1中调用reentrantLock.lock()后，就进入AQS的等待队列中，即之前介绍过的双向列表；</li><li>当调用condition.await()后，线程释放锁并从AQS等待队列中被移除，紧接着就被加入到Condition的等待队列中，该线程再次被唤醒则需要一个signal信号；</li><li>当线程1释放锁，线程2就被唤醒并尝试获取锁。获取后，也加入到AQS的等待队列中。通过调用condition.signalAll()给所有处于condition等待队列的线程发送信号，此时线程1又从Condition等待队列被移除，并加入到AQS等待队列中（还未唤醒）。最后线程2释放锁。</li><li>在线程2释放锁后，线程1拿到锁。此时线程1又处于AQS等待队列的head节点，则又被唤醒，接着上次执行到的地方继续执行后续操作。</li></ol><h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><h5 id="类内成员"><a href="#类内成员" class="headerlink" title="类内成员"></a>类内成员</h5><p><img src="/2018/08/03/J-U-C之AQS—Condition/Condition内部成员.png" alt="图示"></p><hr><h5 id="源码大注释："><a href="#源码大注释：" class="headerlink" title="源码大注释："></a>源码大注释：</h5><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * &#123;@code Condition&#125; factors out the &#123;@code Object&#125; monitor</span><br><span class="line"> * methods (&#123;@link Object<span class="comment">#wait() wait&#125;, &#123;@link Object#notify notify&#125;</span></span><br><span class="line"> *<span class="built_in"> and </span>&#123;@link Object<span class="comment">#notifyAll notifyAll&#125;) into distinct objects to</span></span><br><span class="line"> * give the effect of having multiple wait-sets per object, by</span><br><span class="line"> * combining them with the use of arbitrary &#123;@link Lock&#125; implementations.</span><br><span class="line"> * Where a &#123;@code Lock&#125; replaces the use of &#123;@code synchronized&#125; methods</span><br><span class="line"> *<span class="built_in"> and </span>statements, a &#123;@code Condition&#125; replaces the use of the Object</span><br><span class="line"> *<span class="built_in"> monitor </span>methods.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;Conditions (also known as &lt;em&gt;condition queues&lt;/em&gt; or</span><br><span class="line"> * &lt;em&gt;condition variables&lt;/em&gt;) provide a means for one thread to</span><br><span class="line"> * suspend execution (to &amp;quot;wait&amp;quot;) until notified by another</span><br><span class="line"> * thread that some state condition may now be true.  Because access</span><br><span class="line"> * to this shared state information occurs in different threads, it</span><br><span class="line"> * must be<span class="keyword"> protected</span>, so a lock of some form is associated with the</span><br><span class="line"> * condition. The key property that waiting for a condition provides</span><br><span class="line"> * is that it &lt;em&gt;atomically&lt;/em&gt; releases the associated lock and</span><br><span class="line"> * suspends the current thread, just like &#123;@code Object.wait&#125;.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;A &#123;@code Condition&#125;<span class="built_in"> instance </span>is intrinsically bound to a lock.</span><br><span class="line"> * To obtain a &#123;@code Condition&#125;<span class="built_in"> instance </span>for a particular &#123;@link Lock&#125;</span><br><span class="line"> *<span class="built_in"> instance </span>use its &#123;@link Lock<span class="comment">#newCondition newCondition()&#125; method.</span></span><br><span class="line"> */</span><br></pre></td></tr></table></figure><p><strong>注释重点：</strong></p><ol><li>Condition使得每个对象，因都通过结合他们自己和随意锁的实现，且具有多个等待集合（wait-sets）而被区分开来，从而使监视器（monitor）方法失效。</li><li>Conditions（被当做Condition队列）为场景提供一种新处理方式：一个线程可以暂停自己的执行，直到被另一个具有一些可能正确的状态信息的线程通知。由于共享的状态信息的访问发生在不同的线程间，因此它必须被某种形式的锁保护起来。</li><li>该类提供的关键属性是原子性地释放锁，并暂停当前线程。</li><li>Condition的实例实际上是一个锁。如果为了一个锁机制而要获取一个Condition实例，需要使用它的newCondition()方法。</li></ol><hr><h5 id="类内接口"><a href="#类内接口" class="headerlink" title="类内接口"></a>类内接口</h5><h6 id="1-await"><a href="#1-await" class="headerlink" title="1. await()"></a>1. await()</h6><p>调用该方法会使线程等待直至线程被给予信号量或被中断。</p><h6 id="2-await-long-time-TimeUnit-unit"><a href="#2-await-long-time-TimeUnit-unit" class="headerlink" title="2. await(long time, TimeUnit unit)"></a>2. await(long time, TimeUnit unit)</h6><p>指定超时时间参数，或超时时间过期时线程也会被重新调用</p><h6 id="3-awaitNanos-long-nanosTimeout"><a href="#3-awaitNanos-long-nanosTimeout" class="headerlink" title="3. awaitNanos(long nanosTimeout)"></a>3. awaitNanos(long nanosTimeout)</h6><p>这个方法通过被指定毫微的超时时间，会返回一个线程剩余要等待的毫微时间数。如果超时了的话，该返回值是小于等于0的。</p><h6 id="4-awaitUninterruptibly"><a href="#4-awaitUninterruptibly" class="headerlink" title="4. awaitUninterruptibly()"></a>4. awaitUninterruptibly()</h6><p>该方法是不会产生线程中断情况下的await()方法。</p><h6 id="5-awaitUntil-Date-deadline"><a href="#5-awaitUntil-Date-deadline" class="headerlink" title="5. awaitUntil(Date deadline)"></a>5. awaitUntil(Date deadline)</h6><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Causes <span class="keyword">the</span> current thread <span class="keyword">to</span> wait <span class="keyword">until</span> <span class="keyword">it</span> <span class="keyword">is</span> signalled <span class="keyword">or</span> interrupted,</span><br><span class="line"> * <span class="keyword">or</span> <span class="keyword">the</span> specified deadline elapses.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;The lock associated <span class="keyword">with</span> this condition <span class="keyword">is</span> atomically</span><br><span class="line"> * released <span class="keyword">and</span> <span class="keyword">the</span> current thread becomes disabled <span class="keyword">for</span> thread scheduling</span><br><span class="line"> * purposes <span class="keyword">and</span> lies dormant <span class="keyword">until</span> &lt;em&gt;one&lt;/em&gt; <span class="keyword">of</span> five things happens:</span><br><span class="line"> * &lt;ul&gt;</span><br><span class="line"> * &lt;li&gt;Some other thread invokes <span class="keyword">the</span> &#123;@link <span class="comment">#signal&#125; method for this</span></span><br><span class="line"> * &#123;@code Condition&#125; <span class="keyword">and</span> <span class="keyword">the</span> current thread happens <span class="keyword">to</span> be chosen <span class="keyword">as</span> <span class="keyword">the</span></span><br><span class="line"> * thread <span class="keyword">to</span> be awakened; <span class="keyword">or</span></span><br><span class="line"> * &lt;li&gt;Some other thread invokes <span class="keyword">the</span> &#123;@link <span class="comment">#signalAll&#125; method for this</span></span><br><span class="line"> * &#123;@code Condition&#125;; <span class="keyword">or</span></span><br><span class="line"> * &lt;li&gt;Some other thread &#123;@linkplain Thread<span class="comment">#interrupt interrupts&#125; the</span></span><br><span class="line"> * current thread, <span class="keyword">and</span> interruption <span class="keyword">of</span> thread suspension <span class="keyword">is</span> supported; <span class="keyword">or</span></span><br><span class="line"> * &lt;li&gt;The specified deadline elapses; <span class="keyword">or</span></span><br><span class="line"> * &lt;li&gt;A &amp;quot;&lt;em&gt;spurious wakeup&lt;/em&gt;&amp;quot; occurs.</span><br><span class="line"> * &lt;/ul&gt;</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;In all cases, <span class="keyword">before</span> this method can <span class="literal">return</span> <span class="keyword">the</span> current thread must</span><br><span class="line"> * re-acquire <span class="keyword">the</span> lock associated <span class="keyword">with</span> this condition. When <span class="keyword">the</span></span><br><span class="line"> * thread returns <span class="keyword">it</span> <span class="keyword">is</span> &lt;em&gt;guaranteed&lt;/em&gt; <span class="keyword">to</span> hold this lock.</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><h6 id="6-signal"><a href="#6-signal" class="headerlink" title="6. signal()"></a>6. signal()</h6><p>唤醒一个等待中的线程。<br>该线程在从await()返回前，必须重新请求获取锁。</p><h6 id="7-signalAll"><a href="#7-signalAll" class="headerlink" title="7. signalAll()"></a>7. signalAll()</h6><p>唤醒所有的线程。其中每个线程在从await()返回前，都必须重新请求获取锁。</p>]]></content>
      
      <categories>
          
          <category> Java之并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>J.U.C之AQS—CyclicBarrier</title>
      <link href="/2018/08/02/J-U-C%E4%B9%8BAQS%E2%80%94CyclicBarrier/"/>
      <url>/2018/08/02/J-U-C%E4%B9%8BAQS%E2%80%94CyclicBarrier/</url>
      <content type="html"><![CDATA[<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>CyclicBarrier也是JDK提供的辅助类。它允许一组线程相互等待，直到到达一个公共的屏障点（CommonBarrierPoint）。通过它可以使多个线程间相互等待，只有当每个线程都准备就绪后才能各自继续执行后面的操作。<br><a id="more"></a></p><p><img src="/2018/08/02/J-U-C之AQS—CyclicBarrier/cyclicbarrier原理图.png" alt="原理图"></p><h4 id="与CountDownLatch的比较："><a href="#与CountDownLatch的比较：" class="headerlink" title="与CountDownLatch的比较："></a>与CountDownLatch的比较：</h4><ol><li>CountDownLatch是实现<strong>一个或多个线程需要等待其他线程完成某项操作</strong>之后才会才会继续执行。而CyclicBarrier是实现<strong>多个线程间相互等待，直到所有线程都满足条件</strong>后继续执行后续操作。</li><li>同时通过计数器实现，该类不过是加一操作；</li><li>当线程调用await()时，进入等待状态；</li><li>当达到指定值时都会执行一定的操作：CountDownLatch是计数到达0或超时时间过期会执行下一步操作；CyclicBarrier是加一操作计数达到设定初始值或超时时间过期时，等待的线程会继续执行后续的操作。</li><li>当CountDownLatch计数到0后，就不可再使用了；但CyclicBarrier计数到设定值后，可以复用，可以reset重新计数使用。（呼应名字：循环屏障）</li><li>使用场景相似：CyclicBarrier和CountDownLatch都可用于多线程计算数据，最后汇总计算。但CyclicBarrier可以处理对付更加复杂的场景，例如：若一次并发执行后出现错误，接着可reset计数器，重新执行一次。</li></ol><h4 id="演示例子-1"><a href="#演示例子-1" class="headerlink" title="演示例子-1"></a>演示例子-1</h4><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierExample1</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    private static CyclicBarrier barrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    public static <span class="literal">void</span> main(String[] args) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        ExecutorService executor = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">            final int threadNum = i;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            executor.execute<span class="function"><span class="params">(() -&gt; &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">try</span> &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">                    race(threadNum);</span></span></span><br><span class="line"><span class="function"><span class="params">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">                    log.error(<span class="string">"exception"</span>, e);</span></span></span><br><span class="line"><span class="function"><span class="params">                &#125;</span></span></span><br><span class="line"><span class="function"><span class="params">            &#125;)</span>;</span></span><br><span class="line"><span class="function">        &#125;</span></span><br><span class="line"><span class="function">        <span class="title">executor</span>.<span class="title">shutdown</span><span class="params">()</span>;</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="title">private</span> <span class="title">static</span> <span class="title">void</span> <span class="title">race</span><span class="params">(int threadNum)</span> <span class="title">throws</span> <span class="title">Exception</span> &#123;</span></span><br><span class="line"><span class="function">        <span class="title">Thread</span>.<span class="title">sleep</span><span class="params">(<span class="number">1000</span>)</span>;</span></span><br><span class="line"><span class="function">        <span class="title">log</span>.<span class="title">info</span><span class="params">(<span class="string">"&#123;&#125; is ready"</span>, threadNum)</span>;</span></span><br><span class="line"><span class="function">        <span class="title">barrier</span>.<span class="title">await</span><span class="params">()</span>;</span></span><br><span class="line"><span class="function">        <span class="title">log</span>.<span class="title">info</span><span class="params">(<span class="string">"&#123;&#125; continue"</span>, threadNum)</span>;</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><h5 id="运行结果："><a href="#运行结果：" class="headerlink" title="运行结果："></a>运行结果：</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">19<span class="selector-pseudo">:12</span><span class="selector-pseudo">:14.192</span> <span class="selector-attr">[pool-1-thread-1]</span> <span class="selector-tag">INFO</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.aqs</span><span class="selector-class">.CyclicBarrierExample1</span> <span class="selector-tag">-</span> 0 <span class="selector-tag">is</span> <span class="selector-tag">ready</span></span><br><span class="line">19<span class="selector-pseudo">:12</span><span class="selector-pseudo">:15.190</span> <span class="selector-attr">[pool-1-thread-2]</span> <span class="selector-tag">INFO</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.aqs</span><span class="selector-class">.CyclicBarrierExample1</span> <span class="selector-tag">-</span> 1 <span class="selector-tag">is</span> <span class="selector-tag">ready</span></span><br><span class="line">19<span class="selector-pseudo">:12</span><span class="selector-pseudo">:15.190</span> <span class="selector-attr">[pool-1-thread-2]</span> <span class="selector-tag">INFO</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.aqs</span><span class="selector-class">.CyclicBarrierExample1</span> <span class="selector-tag">-</span> 1 <span class="selector-tag">continue</span></span><br><span class="line">19<span class="selector-pseudo">:12</span><span class="selector-pseudo">:15.190</span> <span class="selector-attr">[pool-1-thread-1]</span> <span class="selector-tag">INFO</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.aqs</span><span class="selector-class">.CyclicBarrierExample1</span> <span class="selector-tag">-</span> 0 <span class="selector-tag">continue</span></span><br><span class="line">19<span class="selector-pseudo">:12</span><span class="selector-pseudo">:16.190</span> <span class="selector-attr">[pool-1-thread-3]</span> <span class="selector-tag">INFO</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.aqs</span><span class="selector-class">.CyclicBarrierExample1</span> <span class="selector-tag">-</span> 2 <span class="selector-tag">is</span> <span class="selector-tag">ready</span></span><br><span class="line">19<span class="selector-pseudo">:12</span><span class="selector-pseudo">:17.191</span> <span class="selector-attr">[pool-1-thread-1]</span> <span class="selector-tag">INFO</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.aqs</span><span class="selector-class">.CyclicBarrierExample1</span> <span class="selector-tag">-</span> 3 <span class="selector-tag">is</span> <span class="selector-tag">ready</span></span><br><span class="line">19<span class="selector-pseudo">:12</span><span class="selector-pseudo">:17.191</span> <span class="selector-attr">[pool-1-thread-1]</span> <span class="selector-tag">INFO</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.aqs</span><span class="selector-class">.CyclicBarrierExample1</span> <span class="selector-tag">-</span> 3 <span class="selector-tag">continue</span></span><br><span class="line">19<span class="selector-pseudo">:12</span><span class="selector-pseudo">:17.191</span> <span class="selector-attr">[pool-1-thread-3]</span> <span class="selector-tag">INFO</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.aqs</span><span class="selector-class">.CyclicBarrierExample1</span> <span class="selector-tag">-</span> 2 <span class="selector-tag">continue</span></span><br><span class="line">19<span class="selector-pseudo">:12</span><span class="selector-pseudo">:18.191</span> <span class="selector-attr">[pool-1-thread-2]</span> <span class="selector-tag">INFO</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.aqs</span><span class="selector-class">.CyclicBarrierExample1</span> <span class="selector-tag">-</span> 4 <span class="selector-tag">is</span> <span class="selector-tag">ready</span></span><br><span class="line">19<span class="selector-pseudo">:12</span><span class="selector-pseudo">:19.192</span> <span class="selector-attr">[pool-1-thread-3]</span> <span class="selector-tag">INFO</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.aqs</span><span class="selector-class">.CyclicBarrierExample1</span> <span class="selector-tag">-</span> 5 <span class="selector-tag">is</span> <span class="selector-tag">ready</span></span><br><span class="line">19<span class="selector-pseudo">:12</span><span class="selector-pseudo">:19.192</span> <span class="selector-attr">[pool-1-thread-3]</span> <span class="selector-tag">INFO</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.aqs</span><span class="selector-class">.CyclicBarrierExample1</span> <span class="selector-tag">-</span> 5 <span class="selector-tag">continue</span></span><br><span class="line">19<span class="selector-pseudo">:12</span><span class="selector-pseudo">:19.192</span> <span class="selector-attr">[pool-1-thread-2]</span> <span class="selector-tag">INFO</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.aqs</span><span class="selector-class">.CyclicBarrierExample1</span> <span class="selector-tag">-</span> 4 <span class="selector-tag">continue</span></span><br></pre></td></tr></table></figure><h5 id="结果分析："><a href="#结果分析：" class="headerlink" title="结果分析："></a>结果分析：</h5><ol><li>当线程0和1都已经到达ready后，才会continue。</li><li>当上一层执行结束后，紧接着开始下一层的执行。</li></ol><h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><p>看一下该类的内部成员：</p><p><img src="/2018/08/02/J-U-C之AQS—CyclicBarrier/cyclicbarrier内部成员.png" alt="图示"></p><p>带有阻塞是操作指令参数的构造函数：<br><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Creates a<span class="built_in"> new </span>&#123;@code CyclicBarrier&#125; that will trip when the</span><br><span class="line"> * given number of parties (threads) are waiting upon it,<span class="built_in"> and </span>which</span><br><span class="line"> * will<span class="built_in"> execute </span>the given barrier action when the barrier is tripped,</span><br><span class="line"> * performed by the last thread entering the barrier.</span><br><span class="line"> *</span><br><span class="line"> * @param parties the number of threads that must<span class="built_in"> invoke </span>&#123;@link <span class="comment">#await&#125;</span></span><br><span class="line"> *        before the barrier is tripped</span><br><span class="line"> * @param barrierAction the command to<span class="built_in"> execute </span>when the barrier is</span><br><span class="line"> *        tripped,<span class="built_in"> or </span>&#123;@code null&#125;<span class="built_in"> if </span>there is no action</span><br><span class="line"> * @throws IllegalArgumentException<span class="built_in"> if </span>&#123;@code parties&#125; is less than 1</span><br><span class="line"> */</span><br><span class="line">public CyclicBarrier(int parties, Runnable barrierAction) &#123;</span><br><span class="line">   <span class="built_in"> if </span>(parties &lt;= 0)<span class="built_in"> throw </span>new IllegalArgumentException();</span><br><span class="line">    this.parties = parties;</span><br><span class="line">    this.count = parties;</span><br><span class="line">    this.barrierCommand = barrierAction;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>带有超时时间参数的await()：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> await(<span class="keyword">long</span> timeout, TimeUnit unit)</span><br><span class="line">    <span class="keyword">throws</span> InterruptedException,</span><br><span class="line">           BrokenBarrierException,</span><br><span class="line">           TimeoutException &#123;</span><br><span class="line">    <span class="keyword">return</span> dowait(<span class="keyword">true</span>, unit.toNanos(timeout));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>设置当前屏障无效，并唤醒每个线程。(持锁时有效)<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private void <span class="keyword">breakBarrier() </span>&#123;</span><br><span class="line">    generation.<span class="keyword">broken </span>= true<span class="comment">;</span></span><br><span class="line">    <span class="built_in">count</span> = parties<span class="comment">;</span></span><br><span class="line">    trip.signalAll()<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>重置当前屏障计数：先加锁，再设置当前屏障代无效并创建新一代。<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reset</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    final ReentrantLock <span class="keyword">lock</span> = <span class="keyword">this</span>.<span class="keyword">lock</span>;</span><br><span class="line">    <span class="keyword">lock</span>.<span class="keyword">lock</span>();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        breakBarrier();   <span class="comment">// break the current generation</span></span><br><span class="line">        nextGeneration(); <span class="comment">// start a new generation</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">lock</span>.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>创建新一代屏障：更新屏障闸的state字段并唤醒每个线程（持锁时有效）。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">nextGeneration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// signal completion of last generation</span></span><br><span class="line">    trip.signalAll();</span><br><span class="line">    <span class="comment">// set up next generation</span></span><br><span class="line">    count = parties;</span><br><span class="line">    generation = <span class="keyword">new</span> Generation();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>await()中真正的实现方法==&gt;dowait():<br><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> dowait(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span><br><span class="line">    throws InterruptedException, BrokenBarrierException,</span><br><span class="line">           TimeoutException &#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;<span class="comment">//使用重入锁。</span></span><br><span class="line">    lock.lock();<span class="comment">//锁内操作保安全</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> Generation g = generation;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (g.broken)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">            breakBarrier();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//count为parties即聚集个数（互相等待的个数）</span></span><br><span class="line">        <span class="comment">//当index减为0，即所有线程都执行了该dowait()方法，都已执行完毕。</span></span><br><span class="line">        <span class="keyword">int</span> <span class="keyword">index</span> = --<span class="keyword">count</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">index</span> == <span class="number">0</span>) &#123;  <span class="comment">// tripped</span></span><br><span class="line">            <span class="keyword">boolean</span> ranAction = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;<span class="comment">//如果有执行命令则运行，并返回方法。</span></span><br><span class="line">                <span class="keyword">final</span> Runnable command = barrierCommand;</span><br><span class="line">                <span class="keyword">if</span> (command != <span class="keyword">null</span>)</span><br><span class="line">                    command.run();</span><br><span class="line">                ranAction = <span class="keyword">true</span>;</span><br><span class="line">                nextGeneration();</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!ranAction)<span class="comment">//执行命令为null，则破除屏障</span></span><br><span class="line">                    breakBarrier();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// loop until tripped, broken, interrupted, or timed out</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!timed)</span><br><span class="line">                    trip.await();</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; <span class="number">0</span>L)</span><br><span class="line">                    nanos = trip.awaitNanos(nanos);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                <span class="keyword">if</span> (g == generation &amp;&amp; ! g.broken) &#123;</span><br><span class="line">                    breakBarrier();</span><br><span class="line">                    <span class="keyword">throw</span> ie;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// We're about to finish waiting even if we had not</span></span><br><span class="line">                    <span class="comment">// been interrupted, so this interrupt is deemed to</span></span><br><span class="line">                    <span class="comment">// "belong" to subsequent execution.</span></span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (g.broken)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (g != generation)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">index</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0</span>L) &#123;</span><br><span class="line">                breakBarrier();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();<span class="comment">//操作结束释放锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Conditin：放闸前所处的等待状态<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> final Condition trip = lock.<span class="keyword">new</span><span class="type">Condition</span>();</span><br></pre></td></tr></table></figure></p><h4 id="演示例子-2"><a href="#演示例子-2" class="headerlink" title="演示例子-2"></a>演示例子-2</h4><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierExample2</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    private static CyclicBarrier barrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    public static <span class="literal">void</span> main(String[] args) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        ExecutorService executor = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            final int threadNum = i;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            executor.execute<span class="function"><span class="params">(() -&gt; &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">try</span> &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">                    race(threadNum);</span></span></span><br><span class="line"><span class="function"><span class="params">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">                    log.error(<span class="string">"exception"</span>, e);</span></span></span><br><span class="line"><span class="function"><span class="params">                &#125;</span></span></span><br><span class="line"><span class="function"><span class="params">            &#125;)</span>;</span></span><br><span class="line"><span class="function">        &#125;</span></span><br><span class="line"><span class="function">        <span class="title">executor</span>.<span class="title">shutdown</span><span class="params">()</span>;</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="title">private</span> <span class="title">static</span> <span class="title">void</span> <span class="title">race</span><span class="params">(int threadNum)</span> <span class="title">throws</span> <span class="title">Exception</span> &#123;</span></span><br><span class="line"><span class="function">        <span class="title">Thread</span>.<span class="title">sleep</span><span class="params">(<span class="number">1000</span>)</span>;</span></span><br><span class="line"><span class="function">        <span class="title">log</span>.<span class="title">info</span><span class="params">(<span class="string">"&#123;&#125; is ready"</span>, threadNum)</span>;</span></span><br><span class="line"><span class="function">        <span class="title">try</span> &#123;</span></span><br><span class="line"><span class="function">            //只等待2000<span class="title">ms</span>，之后的线程就会被抛弃了。</span></span><br><span class="line"><span class="function">            // 因线程的<span class="title">condition</span>改变为<span class="title">broken</span>（因超时而强行打破屏障继续执行）而产生了<span class="title">BrokenBarrierException</span>，</span></span><br><span class="line"><span class="function">            // 或因线程被中断而产生线程中断异常而产生的需要<span class="title">try-catch</span></span></span><br><span class="line"><span class="function">            <span class="title">barrier</span>.<span class="title">await</span><span class="params">(<span class="number">2000</span>, TimeUnit.MILLISECONDS)</span>;</span></span><br><span class="line"><span class="function">        &#125; <span class="title">catch</span> <span class="params">(Exception e)</span> &#123;</span></span><br><span class="line"><span class="function">            <span class="title">log</span>.<span class="title">warn</span><span class="params">(<span class="string">"BarrierException"</span>, e)</span>;</span></span><br><span class="line"><span class="function">        &#125;</span></span><br><span class="line"><span class="function">        <span class="title">log</span>.<span class="title">info</span><span class="params">(<span class="string">"&#123;&#125; continue"</span>, threadNum)</span>;</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><h5 id="运行结果：（部分截取）"><a href="#运行结果：（部分截取）" class="headerlink" title="运行结果：（部分截取）"></a>运行结果：（部分截取）</h5><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">20</span>:<span class="number">45</span>:<span class="number">32.745</span> [pool-<span class="number">1</span>-thread-<span class="number">1</span>] INFO com<span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.aqs</span><span class="selector-class">.CyclicBarrierExample2</span> - <span class="number">0</span> is ready</span><br><span class="line"><span class="number">20</span>:<span class="number">45</span>:<span class="number">33.742</span> [pool-<span class="number">1</span>-thread-<span class="number">2</span>] INFO com<span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.aqs</span><span class="selector-class">.CyclicBarrierExample2</span> - <span class="number">1</span> is ready</span><br><span class="line"><span class="number">20</span>:<span class="number">45</span>:<span class="number">34.742</span> [pool-<span class="number">1</span>-thread-<span class="number">3</span>] INFO com<span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.aqs</span><span class="selector-class">.CyclicBarrierExample2</span> - <span class="number">2</span> is ready</span><br><span class="line"><span class="number">20</span>:<span class="number">45</span>:<span class="number">34.755</span> [pool-<span class="number">1</span>-thread-<span class="number">2</span>] WARN com<span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.aqs</span><span class="selector-class">.CyclicBarrierExample2</span> - BarrierException</span><br><span class="line">java<span class="selector-class">.util</span><span class="selector-class">.concurrent</span><span class="selector-class">.BrokenBarrierException</span>: null</span><br><span class="line">trueat java<span class="selector-class">.util</span><span class="selector-class">.concurrent</span><span class="selector-class">.CyclicBarrier</span><span class="selector-class">.dowait</span>(CyclicBarrier<span class="selector-class">.java</span>:<span class="number">250</span>)</span><br><span class="line">trueat java<span class="selector-class">.util</span><span class="selector-class">.concurrent</span><span class="selector-class">.CyclicBarrier</span><span class="selector-class">.await</span>(CyclicBarrier<span class="selector-class">.java</span>:<span class="number">435</span>)</span><br><span class="line">trueat com<span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.aqs</span><span class="selector-class">.CyclicBarrierExample2</span><span class="selector-class">.race</span>(CyclicBarrierExample2<span class="selector-class">.java</span>:<span class="number">40</span>)</span><br><span class="line">trueat com<span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.aqs</span><span class="selector-class">.CyclicBarrierExample2</span><span class="selector-class">.lambda</span><span class="variable">$main</span>$<span class="number">0</span>(CyclicBarrierExample2<span class="selector-class">.java</span>:<span class="number">24</span>)</span><br><span class="line">trueat java<span class="selector-class">.util</span><span class="selector-class">.concurrent</span><span class="selector-class">.ThreadPoolExecutor</span><span class="selector-class">.runWorker</span>(ThreadPoolExecutor<span class="selector-class">.java</span>:<span class="number">1149</span>)</span><br><span class="line">trueat java<span class="selector-class">.util</span><span class="selector-class">.concurrent</span><span class="selector-class">.ThreadPoolExecutor</span><span class="variable">$Worker</span>.run(ThreadPoolExecutor<span class="selector-class">.java</span>:<span class="number">624</span>)</span><br><span class="line">trueat java<span class="selector-class">.lang</span><span class="selector-class">.Thread</span><span class="selector-class">.run</span>(Thread<span class="selector-class">.java</span>:<span class="number">748</span>)</span><br><span class="line"><span class="number">20</span>:<span class="number">45</span>:<span class="number">34.755</span> [pool-<span class="number">1</span>-thread-<span class="number">3</span>] WARN com<span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.aqs</span><span class="selector-class">.CyclicBarrierExample2</span> - BarrierException</span><br><span class="line">java<span class="selector-class">.util</span><span class="selector-class">.concurrent</span><span class="selector-class">.BrokenBarrierException</span>: null</span><br><span class="line">trueat java<span class="selector-class">.util</span><span class="selector-class">.concurrent</span><span class="selector-class">.CyclicBarrier</span><span class="selector-class">.dowait</span>(CyclicBarrier<span class="selector-class">.java</span>:<span class="number">250</span>)</span><br><span class="line">trueat java<span class="selector-class">.util</span><span class="selector-class">.concurrent</span><span class="selector-class">.CyclicBarrier</span><span class="selector-class">.await</span>(CyclicBarrier<span class="selector-class">.java</span>:<span class="number">435</span>)</span><br><span class="line">trueat com<span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.aqs</span><span class="selector-class">.CyclicBarrierExample2</span><span class="selector-class">.race</span>(CyclicBarrierExample2<span class="selector-class">.java</span>:<span class="number">40</span>)</span><br><span class="line">trueat com<span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.aqs</span><span class="selector-class">.CyclicBarrierExample2</span><span class="selector-class">.lambda</span><span class="variable">$main</span>$<span class="number">0</span>(CyclicBarrierExample2<span class="selector-class">.java</span>:<span class="number">24</span>)</span><br><span class="line">trueat java<span class="selector-class">.util</span><span class="selector-class">.concurrent</span><span class="selector-class">.ThreadPoolExecutor</span><span class="selector-class">.runWorker</span>(ThreadPoolExecutor<span class="selector-class">.java</span>:<span class="number">1149</span>)</span><br><span class="line">trueat java<span class="selector-class">.util</span><span class="selector-class">.concurrent</span><span class="selector-class">.ThreadPoolExecutor</span><span class="variable">$Worker</span>.run(ThreadPoolExecutor<span class="selector-class">.java</span>:<span class="number">624</span>)</span><br><span class="line">trueat java<span class="selector-class">.lang</span><span class="selector-class">.Thread</span><span class="selector-class">.run</span>(Thread<span class="selector-class">.java</span>:<span class="number">748</span>)</span><br></pre></td></tr></table></figure><h4 id="演示例子-3"><a href="#演示例子-3" class="headerlink" title="演示例子-3"></a>演示例子-3</h4><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierExample3</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="regexp">//有参的构造函数，在dowait()方法执行时若存在则优先执行该Runnable指令再返</span></span><br><span class="line"><span class="regexp">    //</span> 回（该时执行不到打破屏障代码段），之后再打破屏障并继续执行后续操作。</span><br><span class="line">    private static CyclicBarrier barrier = <span class="keyword">new</span> CyclicBarrier<span class="function"><span class="params">(<span class="number">5</span>, () -&gt; &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">        log.info(<span class="string">"callback is running"</span>);</span></span></span><br><span class="line"><span class="function"><span class="params">    &#125;)</span>;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="title">public</span> <span class="title">static</span> <span class="title">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="title">throws</span> <span class="title">Exception</span> &#123;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">        <span class="title">ExecutorService</span> <span class="title">executor</span> = <span class="title">Executors</span>.<span class="title">newCachedThreadPool</span><span class="params">()</span>;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">        <span class="title">for</span> <span class="params">(int i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span> &#123;</span></span><br><span class="line"><span class="function">            <span class="title">final</span> <span class="title">int</span> <span class="title">threadNum</span> = <span class="title">i</span>;</span></span><br><span class="line"><span class="function">            <span class="title">Thread</span>.<span class="title">sleep</span><span class="params">(<span class="number">1000</span>)</span>;</span></span><br><span class="line"><span class="function">            <span class="title">executor</span>.<span class="title">execute</span><span class="params">(() -&gt; &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">try</span> &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">                    race(threadNum);</span></span></span><br><span class="line"><span class="function"><span class="params">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">                    log.error(<span class="string">"exception"</span>, e);</span></span></span><br><span class="line"><span class="function"><span class="params">                &#125;</span></span></span><br><span class="line"><span class="function"><span class="params">            &#125;)</span>;</span></span><br><span class="line"><span class="function">        &#125;</span></span><br><span class="line"><span class="function">        <span class="title">executor</span>.<span class="title">shutdown</span><span class="params">()</span>;</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="title">private</span> <span class="title">static</span> <span class="title">void</span> <span class="title">race</span><span class="params">(int threadNum)</span> <span class="title">throws</span> <span class="title">Exception</span> &#123;</span></span><br><span class="line"><span class="function">        <span class="title">Thread</span>.<span class="title">sleep</span><span class="params">(<span class="number">1000</span>)</span>;</span></span><br><span class="line"><span class="function">        <span class="title">log</span>.<span class="title">info</span><span class="params">(<span class="string">"&#123;&#125; is ready"</span>, threadNum)</span>;</span></span><br><span class="line"><span class="function">        <span class="title">barrier</span>.<span class="title">await</span><span class="params">()</span>;</span></span><br><span class="line"><span class="function">        <span class="title">log</span>.<span class="title">info</span><span class="params">(<span class="string">"&#123;&#125; continue"</span>, threadNum)</span>;</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><h5 id="运行结果：（截取部分）"><a href="#运行结果：（截取部分）" class="headerlink" title="运行结果：（截取部分）"></a>运行结果：（截取部分）</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">20<span class="selector-pseudo">:48</span><span class="selector-pseudo">:26.018</span> <span class="selector-attr">[pool-1-thread-1]</span> <span class="selector-tag">INFO</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.aqs</span><span class="selector-class">.CyclicBarrierExample3</span> <span class="selector-tag">-</span> 0 <span class="selector-tag">is</span> <span class="selector-tag">ready</span></span><br><span class="line">20<span class="selector-pseudo">:48</span><span class="selector-pseudo">:27.015</span> <span class="selector-attr">[pool-1-thread-2]</span> <span class="selector-tag">INFO</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.aqs</span><span class="selector-class">.CyclicBarrierExample3</span> <span class="selector-tag">-</span> 1 <span class="selector-tag">is</span> <span class="selector-tag">ready</span></span><br><span class="line">20<span class="selector-pseudo">:48</span><span class="selector-pseudo">:28.015</span> <span class="selector-attr">[pool-1-thread-3]</span> <span class="selector-tag">INFO</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.aqs</span><span class="selector-class">.CyclicBarrierExample3</span> <span class="selector-tag">-</span> 2 <span class="selector-tag">is</span> <span class="selector-tag">ready</span></span><br><span class="line">20<span class="selector-pseudo">:48</span><span class="selector-pseudo">:29.015</span> <span class="selector-attr">[pool-1-thread-4]</span> <span class="selector-tag">INFO</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.aqs</span><span class="selector-class">.CyclicBarrierExample3</span> <span class="selector-tag">-</span> 3 <span class="selector-tag">is</span> <span class="selector-tag">ready</span></span><br><span class="line">20<span class="selector-pseudo">:48</span><span class="selector-pseudo">:30.016</span> <span class="selector-attr">[pool-1-thread-5]</span> <span class="selector-tag">INFO</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.aqs</span><span class="selector-class">.CyclicBarrierExample3</span> <span class="selector-tag">-</span> 4 <span class="selector-tag">is</span> <span class="selector-tag">ready</span></span><br><span class="line">20<span class="selector-pseudo">:48</span><span class="selector-pseudo">:30.016</span> <span class="selector-attr">[pool-1-thread-5]</span> <span class="selector-tag">INFO</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.aqs</span><span class="selector-class">.CyclicBarrierExample3</span> <span class="selector-tag">-</span> <span class="selector-tag">callback</span> <span class="selector-tag">is</span> <span class="selector-tag">running</span></span><br><span class="line">20<span class="selector-pseudo">:48</span><span class="selector-pseudo">:30.016</span> <span class="selector-attr">[pool-1-thread-5]</span> <span class="selector-tag">INFO</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.aqs</span><span class="selector-class">.CyclicBarrierExample3</span> <span class="selector-tag">-</span> 4 <span class="selector-tag">continue</span></span><br><span class="line">20<span class="selector-pseudo">:48</span><span class="selector-pseudo">:30.016</span> <span class="selector-attr">[pool-1-thread-1]</span> <span class="selector-tag">INFO</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.aqs</span><span class="selector-class">.CyclicBarrierExample3</span> <span class="selector-tag">-</span> 0 <span class="selector-tag">continue</span></span><br><span class="line">20<span class="selector-pseudo">:48</span><span class="selector-pseudo">:30.016</span> <span class="selector-attr">[pool-1-thread-2]</span> <span class="selector-tag">INFO</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.aqs</span><span class="selector-class">.CyclicBarrierExample3</span> <span class="selector-tag">-</span> 1 <span class="selector-tag">continue</span></span><br><span class="line">20<span class="selector-pseudo">:48</span><span class="selector-pseudo">:30.016</span> <span class="selector-attr">[pool-1-thread-4]</span> <span class="selector-tag">INFO</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.aqs</span><span class="selector-class">.CyclicBarrierExample3</span> <span class="selector-tag">-</span> 3 <span class="selector-tag">continue</span></span><br><span class="line">20<span class="selector-pseudo">:48</span><span class="selector-pseudo">:30.016</span> <span class="selector-attr">[pool-1-thread-3]</span> <span class="selector-tag">INFO</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.aqs</span><span class="selector-class">.CyclicBarrierExample3</span> <span class="selector-tag">-</span> 2 <span class="selector-tag">continue</span></span><br><span class="line">20<span class="selector-pseudo">:48</span><span class="selector-pseudo">:31.016</span> <span class="selector-attr">[pool-1-thread-6]</span> <span class="selector-tag">INFO</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.aqs</span><span class="selector-class">.CyclicBarrierExample3</span> <span class="selector-tag">-</span> 5 <span class="selector-tag">is</span> <span class="selector-tag">ready</span></span><br><span class="line">20<span class="selector-pseudo">:48</span><span class="selector-pseudo">:32.017</span> <span class="selector-attr">[pool-1-thread-3]</span> <span class="selector-tag">INFO</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.aqs</span><span class="selector-class">.CyclicBarrierExample3</span> <span class="selector-tag">-</span> 6 <span class="selector-tag">is</span> <span class="selector-tag">ready</span></span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Java之并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>J.U.C之AQS—Semaphore</title>
      <link href="/2018/08/02/J-U-C%E4%B9%8BAQS%E2%80%94Semaphore/"/>
      <url>/2018/08/02/J-U-C%E4%B9%8BAQS%E2%80%94Semaphore/</url>
      <content type="html"><![CDATA[<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>Semaphore字面意思就是信号量。它通过提供同步机制，控制资源可同时被并发访问的线程的个数。当信号量限定为1时，它就和单线程很相似了。Semaphore和CountDownLatch的使用有些相似，其中也有两个核心实现方法：acquire()和release()。</p><blockquote><p>通过semaphore可以实现有限结点个数的链表，虽然可重入锁reentrant也可以实现，但是semaphore的实现更为简单。</p></blockquote><a id="more"></a><hr><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>常适用于仅能提供有限资源访问的场景。<br>如：数据库链接数远远小于上层应用业务并发的数量，如果不对数据库的访问进行控制，很容易出现因有些线程因无法获取到数据库链接而导致的异常。</p><h4 id="例子演示"><a href="#例子演示" class="headerlink" title="例子演示"></a>例子演示</h4><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreExample1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> threadCount = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">2</span>);<span class="comment">//信号量声明</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> threadNum = i;</span><br><span class="line">            exec.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();<span class="comment">//信号量获取</span></span><br><span class="line">                    test(threadNum);</span><br><span class="line">                    semaphore.release();<span class="comment">//信号量释放</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.<span class="keyword">error</span>(<span class="string">"exception"</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> threadNum)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        log.info(<span class="string">"&#123;&#125;"</span>, threadNum);</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">14<span class="selector-pseudo">:00</span><span class="selector-pseudo">:22.444</span> <span class="selector-attr">[pool-1-thread-2]</span> <span class="selector-tag">INFO</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.aqs</span><span class="selector-class">.SemaphoreExample1</span> <span class="selector-tag">-</span> 1</span><br><span class="line">14<span class="selector-pseudo">:00</span><span class="selector-pseudo">:22.444</span> <span class="selector-attr">[pool-1-thread-1]</span> <span class="selector-tag">INFO</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.aqs</span><span class="selector-class">.SemaphoreExample1</span> <span class="selector-tag">-</span> 0</span><br><span class="line">14<span class="selector-pseudo">:00</span><span class="selector-pseudo">:23.451</span> <span class="selector-attr">[pool-1-thread-3]</span> <span class="selector-tag">INFO</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.aqs</span><span class="selector-class">.SemaphoreExample1</span> <span class="selector-tag">-</span> 2</span><br><span class="line">14<span class="selector-pseudo">:00</span><span class="selector-pseudo">:23.451</span> <span class="selector-attr">[pool-1-thread-4]</span> <span class="selector-tag">INFO</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.aqs</span><span class="selector-class">.SemaphoreExample1</span> <span class="selector-tag">-</span> 3</span><br><span class="line">14<span class="selector-pseudo">:00</span><span class="selector-pseudo">:24.452</span> <span class="selector-attr">[pool-1-thread-5]</span> <span class="selector-tag">INFO</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.aqs</span><span class="selector-class">.SemaphoreExample1</span> <span class="selector-tag">-</span> 4</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">Process</span> <span class="selector-tag">finished</span> <span class="selector-tag">with</span> <span class="selector-tag">exit</span> <span class="selector-tag">code</span> 0</span><br></pre></td></tr></table></figure><p><strong>例子说明：</strong><br>仔细的童鞋应该已经根据运行结果发现了：相同的信号量的输出是在同一时刻的！这也就对应了semaphore的含义。semaphore的使用也十分简单，方法执行前声明并制定允许的并发访问的数量，并用semaphore.acquire()和semaphore.release()分别前后包裹着test()方法即可。</p><p><strong>看一下semaphore的源码：</strong><br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">acquire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> permits)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (permits &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    sync.acquireSharedInterruptibly(permits);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (permits &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    sync.releaseShared(permits);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其实semaphore.acquire()和semaphore.release()都是可以制定获取/释放信号量的数量的。而且都是使用的sync的方法获取或释放。那再看一下sync是什么鬼？</p><blockquote><p>读者：等等！！你不是说只是看一看源码吗？看看就得了，怎么还一直分析起来了？<br>我：大爷，来都来了，不进去逛逛？</p></blockquote><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** All mechanics via AbstractQueuedSynchronizer subclass */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Sync</span> sync;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Synchronization implementation for semaphore.  Uses AQS state</span></span><br><span class="line"><span class="comment"> * to represent permits. Subclassed into fair and nonfair</span></span><br><span class="line"><span class="comment"> * versions.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">abstract</span> static <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">  xx省略一万字xx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sync是其中的内部类，semaphore果然是使用了AQS框架！！使用了AQS的state字段来实现信号量的允许值（state字段之前提到过）。还分为公平和非公平两个版本！！</p><p><strong>那sync的方法是怎么实现的呢？</strong> 再看看源码：</p><blockquote><p>读者：公子！停停停！STOP!别看了，我有点恶心了~<br>我：emmm？我裤子都脱了，你让我停？</p></blockquote><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> acquireSharedInterruptibly(<span class="keyword">int</span> arg)</span><br><span class="line">        <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> doAcquireSharedInterruptibly(<span class="keyword">int</span> arg)</span><br><span class="line">    <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="function"><span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Ensure that a release propagates, even if there are other</span></span><br><span class="line"><span class="comment">     * in-progress acquires/releases.  This proceeds in the usual</span></span><br><span class="line"><span class="comment">     * way of trying to unparkSuccessor of head if it needs</span></span><br><span class="line"><span class="comment">     * signal. But if it does not, status is set to PROPAGATE to</span></span><br><span class="line"><span class="comment">     * ensure that upon release, propagation continues.</span></span><br><span class="line"><span class="comment">     * Additionally, we must loop in case a new node is added</span></span><br><span class="line"><span class="comment">     * while we are doing this. Also, unlike other uses of</span></span><br><span class="line"><span class="comment">     * unparkSuccessor, we need to know if CAS to reset status</span></span><br><span class="line"><span class="comment">     * fails, if so rechecking.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * CAS waitStatus field of a node.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> compareAndSetWaitStatus(Node node,</span><br><span class="line">                                                     <span class="keyword">int</span> expect,</span><br><span class="line">                                                     <span class="keyword">int</span> update) &#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(node, waitStatusOffset,</span><br><span class="line">                                    expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>hasQueuedPredecessors()</strong><br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public final boolean hasQueuedPredecessors() &#123;</span><br><span class="line">    // The correctness of this depends on head being initialized</span><br><span class="line">    // before tail <span class="keyword">and</span> on head.next being accurate if the current</span><br><span class="line">    // thread is first <span class="keyword">in</span> queue.</span><br><span class="line">    <span class="keyword">Node</span> <span class="title">t</span> = tail; // <span class="keyword">Read</span> fields <span class="keyword">in</span> reverse initialization order</span><br><span class="line">    <span class="keyword">Node</span> <span class="title">h</span> = head;</span><br><span class="line">    <span class="keyword">Node</span> <span class="title">s</span>;</span><br><span class="line">    return h != t &amp;&amp;</span><br><span class="line">        ((s = h.next) == null || s.thread != Thread.currentThread());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>读者：公子！咱们走吧，咱不看了吧~<br>我：呕~ 呕呕呕~~扶我起来，我还能…（话音未落，倒地身亡~）</p></blockquote><p>在<code>acquire()</code>中，调用<code>sync</code>的<code>acquireSharedInterruptibly()</code>其中指定参数（默认为1）：在共享模式中获取，首先检查线程状态，再至少调用一次<code>tryAcquireShared()</code>查询判断当前对象的<code>state</code>允许在共享模式中被获取，不允许则执行<code>doAcquireSharedInterruptibly(args)</code>，其中调用<code>addWaiter(Node.SHARED)</code>（参数指明为在共享模式下）进行声明：添加等待获取的结点，并循环遍历当前等待结点的前一结点，如果是<code>head</code>结点且此时再次查询当前对象的<code>state</code>允许在共享模式中被获取，那么设置队列的<code>head</code>并检查是否成功的对象正处于队列中，若是则传递消息以尝试给下一个队列结点传信号。如果不是<code>head</code>结点则调用<code>cancelAcquire(node)</code>，取消获取信号量。</p><p>在<code>release()</code>中，当参数存在时，调用<code>sync.releaseShared(permits)</code>，再调用<code>tryReleaseShared(args)</code>查询是否允许释放，若是则调用<code>doReleaseShared()</code>：即使有其他进行中的请求/释放信号量的进程，也要确保释放的消息传递，循环遍历以防止在这个过程中有新的结点加入；一般释放信号量的过程是当<code>head</code>需要信号量时，尝试释放head的继承结点。由于结合了CAS，需循环是否CAS重置状态失败了，若是则重新检查。</p><h4 id="如果并发数太多了，但是资源还有限，这时候怎么搞？"><a href="#如果并发数太多了，但是资源还有限，这时候怎么搞？" class="headerlink" title="如果并发数太多了，但是资源还有限，这时候怎么搞？"></a>如果并发数太多了，但是资源还有限，这时候怎么搞？</h4><p>semaphore还有一个叫做tryAcquire的方法。<br>看下例子：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreExample3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> threadCount = <span class="number">2000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> threadNum = i;</span><br><span class="line">            exec.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (semaphore.tryAcquire()) &#123; <span class="comment">// 尝试获取一个许可</span></span><br><span class="line">                        test(threadNum);</span><br><span class="line">                        semaphore.release(); <span class="comment">// 释放一个许可</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.<span class="keyword">error</span>(<span class="string">"exception"</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> threadNum)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        log.info(<span class="string">"&#123;&#125;"</span>, threadNum);</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>运行结果：</strong><br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">16<span class="selector-pseudo">:00</span><span class="selector-pseudo">:49.454</span> <span class="selector-attr">[pool-1-thread-2]</span> <span class="selector-tag">INFO</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.aqs</span><span class="selector-class">.SemaphoreExample3</span> <span class="selector-tag">-</span> 1</span><br><span class="line">16<span class="selector-pseudo">:00</span><span class="selector-pseudo">:49.455</span> <span class="selector-attr">[pool-1-thread-3]</span> <span class="selector-tag">INFO</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.aqs</span><span class="selector-class">.SemaphoreExample3</span> <span class="selector-tag">-</span> 2</span><br><span class="line">16<span class="selector-pseudo">:00</span><span class="selector-pseudo">:49.453</span> <span class="selector-attr">[pool-1-thread-1]</span> <span class="selector-tag">INFO</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.aqs</span><span class="selector-class">.SemaphoreExample3</span> <span class="selector-tag">-</span> 0</span><br></pre></td></tr></table></figure></p><p>为什么只有三个线程执行了测试方法？是不是测试方法中的线程休眠时间太长了？现在改成500ms。</p><p>再次运行：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">16<span class="selector-pseudo">:03</span><span class="selector-pseudo">:13.925</span> <span class="selector-attr">[pool-1-thread-1]</span> <span class="selector-tag">INFO</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.aqs</span><span class="selector-class">.SemaphoreExample3</span> <span class="selector-tag">-</span> 0</span><br><span class="line">16<span class="selector-pseudo">:03</span><span class="selector-pseudo">:13.944</span> <span class="selector-attr">[pool-1-thread-2]</span> <span class="selector-tag">INFO</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.aqs</span><span class="selector-class">.SemaphoreExample3</span> <span class="selector-tag">-</span> 1</span><br><span class="line">16<span class="selector-pseudo">:03</span><span class="selector-pseudo">:13.945</span> <span class="selector-attr">[pool-1-thread-3]</span> <span class="selector-tag">INFO</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.aqs</span><span class="selector-class">.SemaphoreExample3</span> <span class="selector-tag">-</span> 2</span><br></pre></td></tr></table></figure></p><p>再改小一些：==&gt;Thread.sleep(10)<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">16<span class="selector-pseudo">:04</span><span class="selector-pseudo">:12.730</span> <span class="selector-attr">[pool-1-thread-4]</span> <span class="selector-tag">INFO</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.aqs</span><span class="selector-class">.SemaphoreExample3</span> <span class="selector-tag">-</span> 1279</span><br><span class="line">16<span class="selector-pseudo">:04</span><span class="selector-pseudo">:12.730</span> <span class="selector-attr">[pool-1-thread-5]</span> <span class="selector-tag">INFO</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.aqs</span><span class="selector-class">.SemaphoreExample3</span> <span class="selector-tag">-</span> 1278</span><br><span class="line">16<span class="selector-pseudo">:04</span><span class="selector-pseudo">:12.742</span> <span class="selector-attr">[pool-1-thread-10]</span> <span class="selector-tag">INFO</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.aqs</span><span class="selector-class">.SemaphoreExample3</span> <span class="selector-tag">-</span> 9</span><br><span class="line">16<span class="selector-pseudo">:04</span><span class="selector-pseudo">:12.744</span> <span class="selector-attr">[pool-1-thread-11]</span> <span class="selector-tag">INFO</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.aqs</span><span class="selector-class">.SemaphoreExample3</span> <span class="selector-tag">-</span> 10</span><br><span class="line">16<span class="selector-pseudo">:04</span><span class="selector-pseudo">:12.744</span> <span class="selector-attr">[pool-1-thread-12]</span> <span class="selector-tag">INFO</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.aqs</span><span class="selector-class">.SemaphoreExample3</span> <span class="selector-tag">-</span> 11</span><br><span class="line">16<span class="selector-pseudo">:04</span><span class="selector-pseudo">:12.753</span> <span class="selector-attr">[pool-1-thread-49]</span> <span class="selector-tag">INFO</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.aqs</span><span class="selector-class">.SemaphoreExample3</span> <span class="selector-tag">-</span> 75</span><br><span class="line">16<span class="selector-pseudo">:04</span><span class="selector-pseudo">:12.755</span> <span class="selector-attr">[pool-1-thread-60]</span> <span class="selector-tag">INFO</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.aqs</span><span class="selector-class">.SemaphoreExample3</span> <span class="selector-tag">-</span> 102</span><br><span class="line">16<span class="selector-pseudo">:04</span><span class="selector-pseudo">:12.755</span> <span class="selector-attr">[pool-1-thread-62]</span> <span class="selector-tag">INFO</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.aqs</span><span class="selector-class">.SemaphoreExample3</span> <span class="selector-tag">-</span> 106</span><br></pre></td></tr></table></figure></p><p>其中只截取了一部分，总共应该有45个左右线程执行了。</p><p>我再改一下，去掉线程休眠，看看能不能全部2000个线程都执行测试方法：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">16<span class="selector-pseudo">:07</span><span class="selector-pseudo">:21.873</span> <span class="selector-attr">[pool-1-thread-1]</span> <span class="selector-tag">INFO</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.aqs</span><span class="selector-class">.SemaphoreExample3</span> <span class="selector-tag">-</span> 1860</span><br><span class="line">16<span class="selector-pseudo">:07</span><span class="selector-pseudo">:21.873</span> <span class="selector-attr">[pool-1-thread-66]</span> <span class="selector-tag">INFO</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.aqs</span><span class="selector-class">.SemaphoreExample3</span> <span class="selector-tag">-</span> 1856</span><br><span class="line">16<span class="selector-pseudo">:07</span><span class="selector-pseudo">:21.873</span> <span class="selector-attr">[pool-1-thread-2]</span> <span class="selector-tag">INFO</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.aqs</span><span class="selector-class">.SemaphoreExample3</span> <span class="selector-tag">-</span> 1889</span><br><span class="line">16<span class="selector-pseudo">:07</span><span class="selector-pseudo">:21.873</span> <span class="selector-attr">[pool-1-thread-9]</span> <span class="selector-tag">INFO</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.aqs</span><span class="selector-class">.SemaphoreExample3</span> <span class="selector-tag">-</span> 1886</span><br><span class="line">16<span class="selector-pseudo">:07</span><span class="selector-pseudo">:21.873</span> <span class="selector-attr">[pool-1-thread-10]</span> <span class="selector-tag">INFO</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.aqs</span><span class="selector-class">.SemaphoreExample3</span> <span class="selector-tag">-</span> 1888</span><br></pre></td></tr></table></figure></p><p>在结果中截取了部分，并且只找到了最大的线程数为1889，即当线程不休眠时，有1900个线程执行了测试方法，即90%的线程可以得到运行。</p><p>既然测试了该方法，那就看看它的源码吧：</p><blockquote><p>读者君：(～﹃～)~zZ 啊？啊啊？？现在几点了？<br>我：坐正，抬头挺胸！小手放背后！（敲黑板）</p></blockquote><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Acquires a permit <span class="keyword">from</span> this semaphore, only <span class="keyword">if</span> one <span class="keyword">is</span> available <span class="keyword">at</span> <span class="keyword">the</span></span><br><span class="line"> * <span class="built_in">time</span> <span class="keyword">of</span> invocation.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;Acquires a permit, <span class="keyword">if</span> one <span class="keyword">is</span> available <span class="keyword">and</span> returns immediately,</span><br><span class="line"> * <span class="keyword">with</span> <span class="keyword">the</span> value &#123;@code <span class="literal">true</span>&#125;,</span><br><span class="line"> * reducing <span class="keyword">the</span> <span class="built_in">number</span> <span class="keyword">of</span> available permits <span class="keyword">by</span> one.</span><br><span class="line"> */</span><br><span class="line">public <span class="built_in">boolean</span> tryAcquire() &#123;</span><br><span class="line"><span class="built_in">    return</span> sync.nonfairTryAcquireShared(<span class="number">1</span>) &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final int nonfairTryAcquireShared(int acquires) &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        int available = getState();</span><br><span class="line">        int remaining = available - acquires;</span><br><span class="line">        <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">            compareAndSetState(available, remaining))</span><br><span class="line"><span class="built_in">            return</span> remaining;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实tryAcquire()还可以指定超时时间：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">boolean</span> tryAcquire(<span class="keyword">long</span> timeout, TimeUnit unit)</span><br><span class="line">    <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">return</span> sync.tryAcquireSharedNanos(<span class="number">1</span>, unit.toNanos(timeout));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> tryAcquireSharedNanos(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span><br><span class="line">        <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">return</span> tryAcquireShared(arg) &gt;= <span class="number">0</span> ||</span><br><span class="line">        doAcquireSharedNanos(arg, nanosTimeout);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> doAcquireSharedNanos(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span><br><span class="line">        <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0</span>L)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> deadline = System.nanoTime() + nanosTimeout;</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            nanosTimeout = deadline - System.nanoTime();</span><br><span class="line">            <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0</span>L)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                nanosTimeout &gt; spinForTimeoutThreshold)</span><br><span class="line">                LockSupport.parkNanos(<span class="keyword">this</span>, nanosTimeout);</span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>例子就不演示了，通过指定时间，准确指定可以并发请求的数量，大大减轻了控制的操作。再配合在核心方法中修改线程休眠时间来控制线程并发访问数量，最少的数量是semaphore和并发请求中的最小值（但一般情况下还是semaphore小，即最小是semaphore声明值）</strong></p>]]></content>
      
      <categories>
          
          <category> Java之并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>J.U.C之AQS—CountDownLatch</title>
      <link href="/2018/08/02/J-U-C%E4%B9%8BAQS%E2%80%94CountDownLatch/"/>
      <url>/2018/08/02/J-U-C%E4%B9%8BAQS%E2%80%94CountDownLatch/</url>
      <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>它是一个同步辅助类，通过它可以在一个线程（线程间会轮换）执行countdown() -&gt; count值减至0的期间，保证其他线程会调用await()一直阻塞等待，最后等待的线程执行resume()，所有线程再一起执行另一个实务操作。其中有一个原子性的且不会被重置的计数器以保证上述的实现。<br><a id="more"></a><br>原理图如下：<br><img src="/2018/08/02/J-U-C之AQS—CountDownLatch/CountDownLatch类.png" alt="图示"></p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>当一个程序需在另一个条件完成后才可以继续执行后续操作。<br>如：并行计算中最后的汇总操作场</p><h3 id="例子演示"><a href="#例子演示" class="headerlink" title="例子演示"></a>例子演示</h3><h4 id="情景一：指定计数次数"><a href="#情景一：指定计数次数" class="headerlink" title="情景一：指定计数次数"></a>情景一：指定计数次数</h4><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchExample1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> threadCount = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(threadCount);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> threadNum = i;</span><br><span class="line">            exec.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    test(threadNum);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.<span class="keyword">error</span>(<span class="string">"exception"</span>, e);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">//保证了方法被调用即计数执行减一</span></span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        log.info(<span class="string">"finish"</span>);</span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> threadNum)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        log.info(<span class="string">"&#123;&#125;"</span>, threadNum);</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果：</strong>（截取部分）</p><p><img src="/2018/08/02/J-U-C之AQS—CountDownLatch/countdownlatch测试.png" alt="图示"></p><p>根据结果，多线程并发期间，核心方法以乱序执行，但总数仍一定，且最后执行到测试语句“finish”。其中，countDownLatch.await()语句循环检查计数是否已经减为0，即保证了此时全部线程执行结束。</p><h4 id="情景二：指定计数时间"><a href="#情景二：指定计数时间" class="headerlink" title="情景二：指定计数时间"></a>情景二：指定计数时间</h4><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchExample2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> threadCount = <span class="number">2000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(threadCount);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> threadNum = i;</span><br><span class="line">            exec.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    test(threadNum);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.<span class="keyword">error</span>(<span class="string">"exception"</span>, e);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await(<span class="number">3</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">        log.info(<span class="string">"finish"</span>);</span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> threadNum)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        log.info(<span class="string">"&#123;&#125;"</span>, threadNum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试结果：</strong></p><p><img src="/2018/08/02/J-U-C之AQS—CountDownLatch/countdownlatch测试2.png" alt="图示"></p><p>先来看一下await()的源码：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public void await() throws InterruptedException &#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Causes <span class="keyword">the</span> current thread <span class="keyword">to</span> wait <span class="keyword">until</span> <span class="keyword">the</span> latch has counted down <span class="keyword">to</span></span><br><span class="line"> * zero, unless <span class="keyword">the</span> thread <span class="keyword">is</span> &#123;@linkplain Thread<span class="comment">#interrupt interrupted&#125;,</span></span><br><span class="line"> * <span class="keyword">or</span> <span class="keyword">the</span> specified waiting <span class="built_in">time</span> elapses.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;If <span class="keyword">the</span> current <span class="built_in">count</span> <span class="keyword">is</span> zero <span class="keyword">then</span> this method returns immediately</span><br><span class="line"> * <span class="keyword">with</span> <span class="keyword">the</span> value &#123;@code <span class="literal">true</span>&#125;.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;If <span class="keyword">the</span> current <span class="built_in">count</span> <span class="keyword">is</span> <span class="keyword">greater than</span> zero <span class="keyword">then</span> <span class="keyword">the</span> current</span><br><span class="line"> * thread becomes disabled <span class="keyword">for</span> thread scheduling purposes <span class="keyword">and</span> lies</span><br><span class="line"> * dormant <span class="keyword">until</span> one <span class="keyword">of</span> three things happen:</span><br><span class="line"> * &lt;ul&gt;</span><br><span class="line"> * &lt;li&gt;The <span class="built_in">count</span> reaches zero due <span class="keyword">to</span> invocations <span class="keyword">of</span> <span class="keyword">the</span></span><br><span class="line"> * &#123;@link <span class="comment">#countDown&#125; method; or</span></span><br><span class="line"> * &lt;li&gt;Some other thread &#123;@linkplain Thread<span class="comment">#interrupt interrupts&#125;</span></span><br><span class="line"> * <span class="keyword">the</span> current thread; <span class="keyword">or</span></span><br><span class="line"> * &lt;li&gt;The specified waiting <span class="built_in">time</span> elapses.</span><br><span class="line"> * &lt;/ul&gt;</span><br><span class="line"> */</span><br><span class="line">public <span class="built_in">boolean</span> await(long <span class="keyword">timeout</span>, TimeUnit unit)</span><br><span class="line">    throws InterruptedException &#123;</span><br><span class="line"><span class="built_in">    return</span> sync.tryAcquireSharedNanos(<span class="number">1</span>, unit.toNanos(<span class="keyword">timeout</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过<code>countDownLatch.await(3, TimeUnit.MILLISECONDS)</code>方法，指定<code>timeout</code>参数实现。其中，该参数指的是在<code>test</code>方法执行时开始计数，延时<code>timeout</code>的时间后<strong>或</strong>计数已经减为0后，继续执行后续方法，此例为<code>log.info(&quot;finish&quot;)</code>，即输出<code>finish</code>。<br>而无参的await()方法只有计数到0时才会继续执行后续方法。</p><p><strong>结果分析：</strong><br>例子中为了测试timeout，将timeout设置为1ms，而线程执行核心方法时设定休眠100ms，那么与结果是正好对应的，即finish总是第一个被输出的日志。</p><p><strong>但是，finish输出后就直接执行了exec.shutdown()即关闭线程池的操作了啊，怎么还会有线程日志输出？</strong></p><p>其实，exec.shutdown()操作：不会再接受新的线程任务，只会等待当前已经分配的线程执行完操作后再关闭，而不是在第一时间销毁所有的线程并强制关闭线程池。<strong>但是线程池还有一个立即关闭的线程池的方法 -&gt; 在第一时间销毁所有的线程并强制关闭线程池，即shutdownNow()。</strong></p><p>现在修改shutdown()为shutdownNow()，再进行测试，运行结果为：（部分截图）</p><p><img src="/2018/08/02/J-U-C之AQS—CountDownLatch/shutdownNow测试.png" alt="图示"></p><p><strong>结果分析：</strong><br>finish日志字段输出和其后200个<code>exception java.lang.InterruptedException: sleep interrupted</code>异常说明了测试的正确性。也是对应了上面await()源代码中的说明：<code>unless the thread is {@linkplain Thread#interrupt interrupted}</code>。</p><h3 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h3><p>使用CountDownLatch中，最好是计数指定配合指定超时时间使用，避免计数因为意外的情况难以到达使得系统资源空耗或业务逻辑无法继续执行情况，以提高程序的高效性，实用性。</p>]]></content>
      
      <categories>
          
          <category> Java之并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>AQS介绍</title>
      <link href="/2018/08/02/AQS%E4%BB%8B%E7%BB%8D/"/>
      <url>/2018/08/02/AQS%E4%BB%8B%E7%BB%8D/</url>
      <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>AQS是J.U.C中的一个非常重要的类。<br>J.U.C是java.util.concurrent的首字母简称。而AQS是J.U.C下locks包的一个抽象类。<br><a id="more"></a></p><hr><p><strong>废话不多说，看一下类顶注释：</strong>（其中只截取了概述部分，并直接翻译一下,纯手翻，有些机械翻译，但能看懂）<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">/ *<span class="strong">*</span></span><br><span class="line"><span class="strong"> *</span>提供实现阻塞锁和相关的框架</span><br><span class="line"> <span class="strong">*依赖的同步器（信号量，事件等）</span></span><br><span class="line"><span class="strong"> *</span>先进先出（FIFO）等待队列。该类旨在为</span><br><span class="line"> <span class="strong">*大多数依赖于单独具有原子性值去展现状态的</span></span><br><span class="line"><span class="strong"> *</span>同步器提供有用基础内容。子类</span><br><span class="line"> <span class="strong">*必须定义更改此状态的受保护方法，以及哪些方法</span></span><br><span class="line"><span class="strong"> *</span>根据被获取的对象定义该状态的含义</span><br><span class="line"> <span class="strong">*或发布。鉴于这些，该类中的其他方法都会</span></span><br><span class="line"><span class="strong"> *</span>执行所有排队和阻塞方法。子类可以维护</span><br><span class="line"> <span class="strong">*其他声明字段，但只有原子性的更新&#123;@code int&#125;值</span></span><br><span class="line"><span class="strong"> *</span>被操纵使用方法&#123;@link #getState&#125;，&#123;@ link</span><br><span class="line"> * #setState&#125;和&#123;@link #compareAndSetState&#125;因为同步机制而被跟踪。</span><br><span class="line"> <span class="strong">*</span></span><br><span class="line"><span class="strong"> *</span></span><br><span class="line"> * &lt;p&gt;子类应被定义为非公共内部帮助类</span><br><span class="line"> <span class="strong">*以用于实现他们封闭类的同步属性。</span></span><br><span class="line"><span class="strong"> *</span> 类&#123;@code AbstractQueuedSynchronizer&#125;没有实现任何</span><br><span class="line"> <span class="strong">*同步接口。相反，它定义了许多方法，例如</span></span><br><span class="line"><span class="strong"> *</span> &#123;@link #acquireInterruptibly&#125;它可以被相关锁或同步器适当地调用</span><br><span class="line"> <span class="strong">*去实现他们的public方法。</span></span><br><span class="line"><span class="strong"> *</span></span><br><span class="line"> * &lt;p&gt;此类支持其中之一或同时两者模式，包括默认的独占模式和一个共享模式。</span><br><span class="line"> <span class="strong">*当在独占模式中被获取时，</span></span><br><span class="line"><span class="strong"> *</span>通过其他线程的尝试获取是不会成功的。在共享模式中</span><br><span class="line"> <span class="strong">*多线程获取可能（但不一定）成功。这个类</span></span><br><span class="line"><span class="strong"> *</span>不会“理解”这些差异，除非在</span><br><span class="line"> <span class="strong">*方法层面，即当共享模式请求成功时，下一个</span></span><br><span class="line"><span class="strong"> *</span>等待线程（如果存在）也必须确定它是否可以</span><br><span class="line"> <span class="strong">*请求获取。在不同模式下等待的线程共享</span></span><br><span class="line"><span class="strong"> *</span>相同的FIFO队列。通常，实现子类仅支持</span><br><span class="line"> <span class="strong">*这些模式中的一种，但两者都可以在例如&#123;@link ReadWriteLock&#125;中发挥作用。</span></span><br><span class="line"><span class="strong"> *</span> 仅被独占模式或分享模式支持的子类</span><br><span class="line"> <span class="strong">*不需要定义支持未使用模式中的方法。</span></span><br><span class="line"><span class="strong"> *</span>/</span><br></pre></td></tr></table></figure></p><p><strong>看一下它都有哪些方法：</strong>（大多数见名知意）</p><p><img src="/2018/08/02/AQS介绍/AQS方法列表.png" alt="图示"></p><p><strong>再看一下它的底层实现：</strong></p><p><img src="/2018/08/02/AQS介绍/AQS中两个队列.jpg" alt="图示"></p><p><strong>分析：</strong></p><ol><li>显然是使用双向列表，也是队列的一种。</li><li>上面的Sync queue是同步队列，实际是双向列表，其中的head节点主要用于后续的调度；</li><li>下面的Condition queue不是必须的，是一个单项列表；当使用到condition时才会用到此队列（可能会有多个）。</li></ol><hr><h4 id="AQS的设计（注释中已提及，此处做总结。）"><a href="#AQS的设计（注释中已提及，此处做总结。）" class="headerlink" title="AQS的设计（注释中已提及，此处做总结。）"></a>AQS的设计（注释中已提及，此处做总结。）</h4><ol><li>使用Node实现FIFO队列，可以用于构建锁或其他同步装置的基础框架。</li><li>使用int基础数据类型表示状态（state），在AQS的reentrant锁中state表示获取锁的线程数量。</li><li>通过继承并根据需要复写其中方法来使用该提供的框架。</li><li>子类通过继承并通过实现它的acquire和release等方法管理其状态。</li><li>可以同时实现独占锁和共享锁模式。它的子类不会同时使用两套API。即使是ReentrantReadWriteLock也是通过两个内部类读锁、写锁分别实现两套API来实现。</li></ol><hr><h4 id="关键内容"><a href="#关键内容" class="headerlink" title="关键内容"></a>关键内容</h4><p>AQS内部有一个等待队列，它是”CLH”锁队列的一个变种实现；CLH指的是Craig, Landin, and Hagersten这三个人的名字首字母拼装。（我猜是他们三个共同研究出的一种队列实现方式。）好吧真是个磨人的小妖精~再看一下源码中的说明。（只翻译了一部分，剩下的大家可以选择性地看看。）<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment"><span class="markdown">/**CLH锁通常用于</span></span></span><br><span class="line"><span class="comment"><span class="markdown">      *自旋锁。 我们现不将它们用作阻塞同步器，而是</span></span></span><br><span class="line"><span class="comment"><span class="markdown">      *使用该相同的策略：通过持有一些它上个线程中的结点的控制信息。</span></span></span><br><span class="line"><span class="comment"><span class="markdown">      *每个节点中的“status”字段跟踪是否有线程</span></span></span><br><span class="line"><span class="comment"><span class="markdown">      *应该阻塞。 结点在其上个线程释放时会发出信号</span></span></span><br><span class="line"><span class="comment"><span class="markdown">      *否则队列的每个节点通过持有一个等待的线程，成为一个</span></span></span><br><span class="line"><span class="comment"><span class="markdown">      *特定通知式监视器。</span></span></span><br><span class="line"><span class="comment"><span class="markdown">      *status字段虽然不控制线程是否被</span></span></span><br><span class="line"><span class="comment"><span class="markdown">      *授予锁等。 一个线程可能会尝试去获取锁，如果他是在队列中的第一个时。</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> *但当是第一个时，并不能保证成功;</span></span></span><br><span class="line"><span class="comment"><span class="markdown">      *它只给予线程去争取锁的权利。 所以现在被释放了锁的线程</span></span></span><br><span class="line"><span class="comment"><span class="markdown">      *可能需要重新等待。</span></span></span><br><span class="line"><span class="comment"><span class="markdown">     *</span></span></span><br><span class="line"><span class="comment"><span class="markdown">     * <span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span>要排队进入CLH锁，您需要原子性地将其拼接为一个新的tail。</span></span></span><br><span class="line"><span class="comment"><span class="markdown">     *  要出队列，您只需设置head（头部）字段即可。</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">*      </span>+------+  prev +-----+       +-----+</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span>head |      | <span class="xml"><span class="tag">&lt;<span class="name">----</span> |     | &lt;<span class="attr">----</span> |     |  <span class="attr">tail</span></span></span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">*      </span>+------+       +-----+       +-----+</span></span></span><br><span class="line"><span class="comment"><span class="markdown">*</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span><span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span>Insertion into </span>a<span class="markdown"> CLH queue requires only </span>a<span class="markdown"> single atomic</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span>operation on "tail", </span>so<span class="markdown"> there is </span>a<span class="markdown"> simple atomic point of</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span>demarcation from unqueued to queued. Similarly, dequeuing</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span>involves only updating </span>the<span class="markdown"> "head". However, it takes </span>a<span class="markdown"> bit</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span></span>more<span class="markdown"> work for nodes to determine who their successors </span>are<span class="markdown">,</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span>in part to deal with possible cancellation due to timeouts</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span>and interrupts.</span></span></span><br><span class="line"><span class="comment"><span class="markdown">*</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span><span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span>The "prev" links (not used in original CLH locks), </span>are<span class="markdown"> mainly</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span>needed to handle cancellation. If </span>a<span class="markdown"> node is cancelled, its</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span>successor is (normally) relinked to </span>a<span class="markdown"> non-cancelled</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span>predecessor. For explanation of similar mechanics in </span>the<span class="markdown"> case</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span>of spin locks, see </span>the<span class="markdown"> papers by Scott and Scherer at</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span>http://www.cs.rochester.edu/u/scott/synchronization/</span></span></span><br><span class="line"><span class="comment"><span class="markdown">*</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span><span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span>We also use "next" links to implement blocking mechanics.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span>The thread id for each node is kept in its own node, </span>so<span class="markdown"> </span>a<span class="markdown"></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span>predecessor signals </span>the<span class="markdown"> next node to wake up by traversing</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span>next link to determine which thread it is.  Determination of</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span>successor must avoid races with newly queued nodes to set</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span></span>the<span class="markdown"> "next" fields of their predecessors.  This is solved</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span>when necessary by checking backwards from </span>the<span class="markdown"> atomically</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span>updated "tail" when </span>a<span class="markdown"> node's successor appears to be null.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span>(Or, said differently, </span>the<span class="markdown"> next-links </span>are<span class="markdown"> </span>an<span class="markdown"> optimization</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span></span>so<span class="markdown"> that we </span>don't<span class="markdown"> usually need </span>a<span class="markdown"> backward scan.)</span></span></span><br><span class="line"><span class="comment"><span class="markdown">*</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span><span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span>Cancellation introduces some conservatism to </span>the<span class="markdown"> basic</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span>algorithms.  Since we must poll for cancellation of other</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span>nodes, we can miss noticing whether </span>a<span class="markdown"> cancelled node is</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span>ahead or behind us. This is dealt with by always unparking</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span>successors upon cancellation, allowing them to stabilize on</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span></span>a<span class="markdown"> new predecessor, unless we can identify </span>an<span class="markdown"> uncancelled</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span>predecessor who </span>will<span class="markdown"> carry this responsibility.</span></span></span><br><span class="line"><span class="comment"><span class="markdown">*</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span><span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span>CLH queues need </span>a<span class="markdown"> dummy header node to get started. But</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span>we </span>don't<span class="markdown"> create them on construction, because it would be wasted</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span>effort if there is never contention. Instead, </span>the<span class="markdown"> node</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span>is constructed and head and tail pointers </span>are<span class="markdown"> set upon first</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span>contention.</span></span></span><br><span class="line"><span class="comment"><span class="markdown">*</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span><span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span>Threads waiting on Conditions use </span>the<span class="markdown"> same nodes, </span>but<span class="markdown"></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span>use </span>an<span class="markdown"> additional link. Conditions only need to link nodes</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span>in simple (non-concurrent) linked queues because </span>they<span class="markdown"> </span>are<span class="markdown"></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span>only accessed when exclusively held.  Upon await, </span>a<span class="markdown"> node is</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span>inserted into </span>a<span class="markdown"> condition queue.  Upon signal, </span>the<span class="markdown"> node is</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span>transferred to </span>the<span class="markdown"> main queue.  A special value of status</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span>field is used to mark which queue </span>a<span class="markdown"> node is on.</span></span></span><br><span class="line"><span class="comment"><span class="markdown">*</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span><span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span>Thanks go to Dave Dice, Mark Moir, Victor Luchangco, Bill</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span>Scherer and Michael Scott, along with members of JSR-166</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span>expert group, for helpful ideas, discussions, and critiques</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span>on </span>the<span class="markdown"> design of this class.</span></span></span><br><span class="line"><span class="comment"><span class="markdown">*/</span></span></span><br></pre></td></tr></table></figure></p><blockquote><p><strong>小结：</strong> AQS内部维护一个CLH队列来管理锁，线程会首先尝试获取锁，如果获取失败，则将就将当前线程以及等待状态等信息包成一个Node结点，加入到同步队列SyncQueue中，当当前结点为head的直接后继时才会不断尝试继续获取锁。如果失败则会阻塞自己直至自己被唤醒。当持有锁的线程释放时，队列中的后继线程才会被唤醒。</p></blockquote><hr><h4 id="AQS的同步组件简介"><a href="#AQS的同步组件简介" class="headerlink" title="AQS的同步组件简介"></a>AQS的同步组件简介</h4><blockquote><p>此处仅做组件的简单的提出，后续会有详细的手记说明。</p></blockquote><h5 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h5><p>是闭锁，通过计数来保证线程间是否需要阻塞。</p><h5 id="Semphore"><a href="#Semphore" class="headerlink" title="Semphore"></a>Semphore</h5><p>控制同一时刻并发的线程数量。</p><h5 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h5><p>同CountDownLatch相似，均可以阻塞线程。</p><h5 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h5><p>重入锁。后续手记中会详述。</p><h5 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h5><p>使用时需结合ReentrantLock。</p><h5 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h5><p>后续会有FutureTask的详细介绍……</p>]]></content>
      
      <categories>
          
          <category> Java之并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>并发容器-J.U.C之线程安全集合</title>
      <link href="/2018/08/02/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/"/>
      <url>/2018/08/02/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/</url>
      <content type="html"><![CDATA[<h3 id="copyOnWriteArrayList"><a href="#copyOnWriteArrayList" class="headerlink" title="copyOnWriteArrayList"></a>copyOnWriteArrayList</h3><blockquote><p>线程写操作时复制，当有新元素添加到copyOnWriteArrayList时，它先从原有的数组中拷贝出一份，在新开辟出的新数组中写入，写完后再将原数组指向新数组。其操作都是在锁的域中，防止在多线程中复制出多个副本出来，导致原数组指向错误。</p></blockquote><p><strong>特点：</strong></p><ol><li>由于写操作需进行复制操作，耗用内存；当元素内容过多时，该复制操作会占用非常多的内存，导致minor-GC，甚至full-GC。</li><li>虽然最终会保持一致性，但不能用于实时读的操作。</li><li>读写分离，且适合读多写少的场景。</li><li>若add或set的数据不清楚或过多，要慎用！</li><li>读时不加锁，写时加锁。</li></ol><a id="more"></a><p><strong>测试例子：</strong>（还是原来的测试框架，测试实例变量声明如下）</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> static <span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt; <span class="built_in">list</span> = <span class="literal">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure><p><strong>运行结果：</strong><br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">22<span class="selector-pseudo">:03</span><span class="selector-pseudo">:09.363</span> <span class="selector-attr">[main]</span> <span class="selector-tag">INFO</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.concurrent</span><span class="selector-class">.CopyOnWriteArrayListExample</span> <span class="selector-tag">-</span> <span class="selector-tag">size</span><span class="selector-pseudo">:5000</span></span><br></pre></td></tr></table></figure></p><p>结果验证了该类为线程安全的！</p><p>看一下它的源码：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** The lock protecting all mutators */</span></span><br><span class="line">final transient ReentrantLock <span class="keyword">lock</span> = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> boolean <span class="title">add</span>(<span class="params">E e</span>) </span>&#123;</span><br><span class="line">    final ReentrantLock <span class="keyword">lock</span> = <span class="keyword">this</span>.<span class="keyword">lock</span>;</span><br><span class="line">    <span class="keyword">lock</span>.<span class="keyword">lock</span>();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">lock</span>.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>显然是使用重入锁进行操作加锁。add方法的实现与上面的说明对应！</strong></p><h3 id="copyOnWriteArraySet"><a href="#copyOnWriteArraySet" class="headerlink" title="copyOnWriteArraySet"></a>copyOnWriteArraySet</h3><blockquote><p>对应于HashSet。</p></blockquote><p><strong>它的底层实现与copyOnWriteArrayList是一样的。特点也是一样的。当使用迭代器iterator迭代时，速度快效率高线程安全。</strong></p><h3 id="ConcurrentSkipListSet"><a href="#ConcurrentSkipListSet" class="headerlink" title="ConcurrentSkipListSet"></a>ConcurrentSkipListSet</h3><blockquote><p>对应于TreeSet。是JDK 1.6中新增的类，同样支持自然排序。在构造时可以自定义比较器。基于map集合，故而多线程并发环境下，它的类内插入、移除、访问方法都是线程安全的。但是对于批量操作，比如addAll()、removeAll()、retainAll()、containsAll并不能保证其操作的原子性。</p></blockquote><p>例子就不用演示了，跟上面的例子方法几乎完全一样，运行结果也显示是线程安全的！批量操作时就不能保证线程安全了！需额外增加锁机制。</p><h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><blockquote><p>对应于HashMap。其中需注意，key或Value不需为null。高并发环境中，表现较好。（后续会详细讲）</p></blockquote><h3 id="ConcurrentSkipListMap"><a href="#ConcurrentSkipListMap" class="headerlink" title="ConcurrentSkipListMap"></a>ConcurrentSkipListMap</h3><blockquote><p>对应于TreeMap。内部是使用SkipList即跳表的结构实现。</p></blockquote><p><strong>SkipList：</strong> 跳跃链表是一种随机化数据结构，基于并联的链表，其效率可比拟于二叉查找树(对于大多数操作需要O(log n)平均时间)，并且对并发算法友好。基本上，跳跃列表是对有序的链表增加上附加的前进链接，增加是以随机化的方式进行的，所以在列表中的查找可以快速的跳过部分列表(因此得名)。  <a href="https://blog.csdn.net/qpzkobe/article/details/80057046" target="_blank" rel="noopener">推荐阅读</a></p><p><strong>跳表性质：</strong></p><ol><li>由很多层结构组成；</li><li>每一层都是一个有序的链表；</li><li>最底层(Level 1)的链表包含所有元素；</li><li>如果一个元素出现在 Level i 的链表中，则它在 Level i 之下的链表也都会出现；</li><li>每个节点包含两个指针，一个指向同一链表中的下一个元素，一个指向下面一层的元素。<br><a href="https://www.cnblogs.com/a8457013/p/8251967.html" target="_blank" rel="noopener">推荐阅读</a></li></ol><p><strong>虽然ConcurrentSkipListMap的效率不及ConcurrentHashMap，但它也有ConcurrentHashMap不可比拟的优点：</strong></p><ol><li>ConcurrentSkipListMap中的key值是有序的。</li><li>支持更高的线程并发。其存取时间与线程数量是几乎没有关系的。即线程越多，越有利于ConcurrentSkipListMap的性能发挥。</li></ol><blockquote><p>上面介绍的几个例子就不进行例子演示了，均只是改变了变量的声明，其他内容仍然与原测试结构相同。</p></blockquote>]]></content>
      
      <categories>
          
          <category> Java之并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>同步容器</title>
      <link href="/2018/08/02/%E7%BA%BF%E5%90%8C%E6%AD%A5%E5%AE%B9%E5%99%A8/"/>
      <url>/2018/08/02/%E7%BA%BF%E5%90%8C%E6%AD%A5%E5%AE%B9%E5%99%A8/</url>
      <content type="html"><![CDATA[<blockquote><p>本节内容不仅丰富而且十分有趣实用~</p></blockquote><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><blockquote><p>同步容器大致分为两类：</p><ol><li>由<code>List</code>发展来的<code>Vector</code>、<code>Stack</code>；由<code>HashMap</code>发展来的<code>HashTable</code>（其中K,V均不能为null）</li><li><code>Collections</code>工具类提供的静态工厂方法 –&gt; 均为<code>synchronizedXXXX(List/Set/Map)</code>的模样。</li></ol></blockquote><a id="more"></a><h4 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h4><p>看个例子：(好吧，这个测试的框架都快看恶心了ORZ)<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VectorExample1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> clientTotal = <span class="number">5000</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> threadTotal = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Integer&gt; list = <span class="keyword">new</span> Vector&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(threadTotal);</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(clientTotal);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clientTotal; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> count = i;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    update(count);</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.<span class="keyword">error</span>(<span class="string">"exception"</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">        log.info(<span class="string">"size:&#123;&#125;"</span>, list.size());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;list.add(i);&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>运行结果：</strong><br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">14<span class="selector-pseudo">:10</span><span class="selector-pseudo">:04.044</span> <span class="selector-attr">[main]</span> <span class="selector-tag">INFO</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.syncContainer</span><span class="selector-class">.VectorExample1</span> <span class="selector-tag">-</span> <span class="selector-tag">size</span><span class="selector-pseudo">:5000</span></span><br></pre></td></tr></table></figure></p><p>看一下<code>Vector</code>的源码:<br><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> synchronized <span class="keyword">void</span> insertElementAt(E obj, <span class="keyword">int</span> <span class="keyword">index</span>) &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">index</span> &gt; elementCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(<span class="keyword">index</span></span><br><span class="line">                                                 + <span class="string">" &gt; "</span> + elementCount);</span><br><span class="line">    &#125;</span><br><span class="line">    ensureCapacityHelper(elementCount + <span class="number">1</span>);</span><br><span class="line">    System.arraycopy(elementData, <span class="keyword">index</span>, elementData, <span class="keyword">index</span> + <span class="number">1</span>, elementCount - <span class="keyword">index</span>);</span><br><span class="line">    elementData[<span class="keyword">index</span>] = obj;</span><br><span class="line">    elementCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其他方法同理，基本都使用synchronized进行标识。<br><strong>但是！！</strong><br><strong>同步容器不一定就是线程安全的！</strong></p><p>再看例子：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">@NotThreadSafe</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VectorExample2</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Vector&lt;Integer&gt; <span class="built_in">vector</span> = <span class="keyword">new</span> Vector&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="built_in">vector</span>.add(i);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Thread thread1 = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> run() &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">vector</span>.size(); i++) &#123;</span><br><span class="line">                        <span class="built_in">vector</span>.remove(i);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            Thread thread2 = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> run() &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">vector</span>.size(); i++) &#123;</span><br><span class="line">                        <span class="built_in">vector</span>.get(i);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            thread1.start();</span><br><span class="line">            thread2.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果：</p><p><img src="/2018/08/02/线同步容器/同步容器Vector测试.png" alt="图示"></p><p>既然Vector的remove和get方法都抛出ArrayIndexOutOfBoundsException异常，那看一下源码吧：<br><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the element at the specified position in this Vector.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param index index of the element to return</span></span><br><span class="line"><span class="comment"> * @return object at the specified index</span></span><br><span class="line"><span class="comment"> * @throws ArrayIndexOutOfBoundsException if the index is out of range</span></span><br><span class="line"><span class="comment"> *            (&#123;@code index &lt; 0 || index &gt;= size()&#125;)</span></span><br><span class="line"><span class="comment"> * @since 1.2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> synchronized E get(<span class="keyword">int</span> <span class="keyword">index</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">index</span> &gt;= elementCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(<span class="keyword">index</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> elementData(<span class="keyword">index</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> synchronized E remove(<span class="keyword">int</span> <span class="keyword">index</span>) &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">index</span> &gt;= elementCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(<span class="keyword">index</span>);</span><br><span class="line">    E oldValue = elementData(<span class="keyword">index</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> numMoved = elementCount - <span class="keyword">index</span> - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, <span class="keyword">index</span>+<span class="number">1</span>, elementData, <span class="keyword">index</span>,</span><br><span class="line">                         numMoved);</span><br><span class="line">    elementData[--elementCount] = <span class="keyword">null</span>; <span class="comment">// Let gc do its work</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>源码分析：</strong></p><ol><li><code>get</code>方法出现该异常一定是<code>remove</code>方法造成的。</li><li>数组越界情况为：<code>index &lt; 0</code> 或 <code>index &gt;= size()</code>。但既然是remove方法，那应该只能是index小于0或index不存在的情况了。</li><li><strong>同步容器不一定就能保证线程并发安全。</strong></li></ol><p><strong>例子情况分析：</strong>（常见的多线程间执行顺序的差异导致）<br>在其中的for循环中，当一个线程调用get方法时（其中其下标设为i），另一个线程恰好在前一时刻调用了remove方法（恰好其下标也是i），此时下标为i的数据已经不存在，便抛出ArrayIndexOutOfBoundsException异常。</p><p>再来看一个Vector的测试例子：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">VectorExample3</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span>(<span class="params">Vector&lt;Integer&gt; v1</span>) </span>&#123; <span class="comment">// foreach</span></span><br><span class="line">        <span class="keyword">for</span>(Integer i : v1) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i.<span class="keyword">equals</span>(<span class="number">3</span>)) &#123;</span><br><span class="line">                v1.<span class="keyword">remove</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// java.util.ConcurrentModificationException</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test2</span>(<span class="params">Vector&lt;Integer&gt; v1</span>) </span>&#123; <span class="comment">// iterator</span></span><br><span class="line">        Iterator&lt;Integer&gt; iterator = v1.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            Integer i = iterator.next();</span><br><span class="line">            <span class="keyword">if</span> (i.<span class="keyword">equals</span>(<span class="number">3</span>)) &#123;</span><br><span class="line">                v1.<span class="keyword">remove</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// success</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test3</span>(<span class="params">Vector&lt;Integer&gt; v1</span>) </span>&#123; <span class="comment">// for</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v1.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (v1.<span class="keyword">get</span>(i).<span class="keyword">equals</span>(<span class="number">3</span>)) &#123;</span><br><span class="line">                v1.<span class="keyword">remove</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">        Vector&lt;Integer&gt; vector = <span class="keyword">new</span> Vector&lt;&gt;();</span><br><span class="line">        vector.<span class="keyword">add</span>(<span class="number">1</span>);</span><br><span class="line">        vector.<span class="keyword">add</span>(<span class="number">2</span>);</span><br><span class="line">        vector.<span class="keyword">add</span>(<span class="number">3</span>);</span><br><span class="line">        test1(vector);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>运行结果：</strong></p><ol><li>main函数执行test1(vector)时，抛出java.util.ConcurrentModificationException；</li><li>main函数执行test2(vector)时，抛出java.util.ConcurrentModificationException；</li><li>main函数执行test3(vector)时，程序正常结束。</li></ol><p><strong>结果分析：</strong><br>使用迭代器iterator或foreach循环（加强版for循环）会抛出并发修改异常；但一般for语句正常结束。</p><p> 废话不多说，看源码：<br> <figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function">E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (Vector.<span class="keyword">this</span>) &#123;</span><br><span class="line">        checkForComodification();</span><br><span class="line">        <span class="keyword">int</span> i = cursor;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= elementCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        cursor = i + <span class="number">1</span>;</span><br><span class="line">        <span class="function"><span class="keyword">return</span> <span class="title">elementData</span><span class="params">(lastRet = i)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lastRet == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">    <span class="keyword">synchronized</span> (Vector.<span class="keyword">this</span>) &#123;</span><br><span class="line">        checkForComodification();</span><br><span class="line">        Vector.<span class="keyword">this</span>.remove(lastRet);</span><br><span class="line">        expectedModCount = modCount;</span><br><span class="line">    &#125;</span><br><span class="line">    cursor = lastRet;</span><br><span class="line">    lastRet = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> <span class="function"><span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>源码分析：</strong><br>由于迭代器<code>iterator</code>或<code>foreach</code>循环中的<code>remove</code>操作使得<code>modCount != expectedModCount</code>，即修改后的<code>count</code>与期望的<code>count</code>不一致，定是并发过程中<code>Vector</code>被修改；但<code>for循环</code>每次循环都会重新计算i,此时<code>Vector</code>已被更新……（好吧，我承认，我其实这里还是不太懂，<code>for</code>循环这里只是我的猜想。）<br><strong>解决方案：</strong><br>在讯循环中不要进行修改操作：</p><ol><li>先查，若有需要进行修改的对象，则做上标记</li><li>循环之后进行修改</li></ol><p><strong>当使用迭代器iterator迭代时，使用synchronized或Lock做同步措施（也可以使用并发容器copyOnWriteArrayList等代替ArrayList或Vector）</strong></p><h4 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h4><p>继承了Vector，其两者用法基本一致。只不过它是一个LIFO的数据结构。</p><h4 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h4><p>好吧，其实用的还是那套框架，换一下实例声明的名字就行了。</p><p>运行结果：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">15<span class="selector-pseudo">:05</span><span class="selector-pseudo">:24.433</span> <span class="selector-attr">[main]</span> <span class="selector-tag">INFO</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.syncContainer</span><span class="selector-class">.HashTableExample</span> <span class="selector-tag">-</span> <span class="selector-tag">size</span><span class="selector-pseudo">:5000</span></span><br></pre></td></tr></table></figure></p><p>既然是线程安全的，再看一下源码：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> synchronized V <span class="title">put</span>(<span class="params">K key, V <span class="keyword">value</span></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Make sure the value is not null</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">value</span> == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Makes sure the key is not already in the hashtable.</span></span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">    <span class="keyword">int</span> hash = key.hashCode();</span><br><span class="line">    <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">    @SuppressWarnings(<span class="string">"unchecked"</span>)</span><br><span class="line">    Entry&lt;K,V&gt; entry = (Entry&lt;K,V&gt;)tab[index];</span><br><span class="line">    <span class="keyword">for</span>(; entry != <span class="literal">null</span> ; entry = entry.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((entry.hash == hash) &amp;&amp; entry.key.<span class="keyword">equals</span>(key)) &#123;</span><br><span class="line">            V old = entry.<span class="keyword">value</span>;</span><br><span class="line">            entry.<span class="keyword">value</span> = <span class="keyword">value</span>;</span><br><span class="line">            <span class="keyword">return</span> old;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    addEntry(hash, key, <span class="keyword">value</span>, index);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>好吧，还是synchronized标识修饰方法。故HashTable是一个线程安全的同步容器。</p><h4 id="Collections工具类方法"><a href="#Collections工具类方法" class="headerlink" title="Collections工具类方法"></a>Collections工具类方法</h4><h5 id="synchronizedList"><a href="#synchronizedList" class="headerlink" title="synchronizedList"></a>synchronizedList</h5><p>例子：（还是原来的配方，还是熟悉的测试框架…不过实例声明换成Collections的方法）<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;Integer&gt; list = Collections.synchronizedList(Lists.<span class="keyword">new</span><span class="type">ArrayList</span>());</span><br></pre></td></tr></table></figure></p><p>好吧，非常不幸的告诉你，它的运行结果还是:<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">15<span class="selector-pseudo">:20</span><span class="selector-pseudo">:49.641</span> <span class="selector-attr">[main]</span> <span class="selector-tag">INFO</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.syncContainer</span><span class="selector-class">.CollectionsExample1</span> <span class="selector-tag">-</span> <span class="selector-tag">size</span><span class="selector-pseudo">:5000</span></span><br></pre></td></tr></table></figure></p><p>不管怎样，来都来了，那看一下源码：（没错，注释已经“入党”，已经自动汉化了）<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/ **</span><br><span class="line">     *返回由指定的支持的同步（线程安全）列表</span><br><span class="line">     *清单。为了保证串行访问，至关重要的是</span><br><span class="line">     * &lt;strong&gt;所有&lt;/ strong&gt;对支持列表的访问权限已完成</span><br><span class="line">     *通过返回的列表。&lt;p&gt;</span><br><span class="line">     *</span><br><span class="line">     *用户必须手动地同步返回的内容</span><br><span class="line">     *迭代时列出：</span><br><span class="line">     * &lt;pre&gt;</span><br><span class="line">     * <span class="built_in">List</span> <span class="built_in">list</span> = Collections.synchronizedList（<span class="literal">new</span> ArrayList（））;</span><br><span class="line">     * <span class="params">...</span><span class="params">...</span></span><br><span class="line">     * synchronized（<span class="built_in">list</span>）&#123;</span><br><span class="line">     * Iterator i = <span class="built_in">list</span>.iterator（）; <span class="comment">//必须在同步块中</span></span><br><span class="line">     * <span class="keyword">while</span>（i.hasNext（））</span><br><span class="line">     * foo（i.next（））;</span><br><span class="line">     *&#125;</span><br><span class="line">     * &lt;/ pre&gt;</span><br><span class="line">     *不遵循此建议可能会导致非确定性行为。</span><br><span class="line">     *</span><br><span class="line">     * &lt;p&gt;如果指定的列表是，则返回的列表将是可序列化的</span><br><span class="line">     *可序列化。</span><br><span class="line">     *</span><br><span class="line">     * @param &lt;T&gt;列表中对象的类</span><br><span class="line">     * @param列出要在同步列表中“包装”的列表。</span><br><span class="line">     * @<span class="keyword">return</span>指定列表的同步视图。</span><br><span class="line">     * /</span><br><span class="line">    <span class="keyword">public</span> static &lt;T&gt; <span class="built_in">List</span>&lt;T&gt; synchronizedList(<span class="built_in">List</span>&lt;T&gt; <span class="built_in">list</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">list</span> instanceof RandomAccess ?</span><br><span class="line">                <span class="literal">new</span> SynchronizedRandomAccessList&lt;&gt;(<span class="built_in">list</span>) :</span><br><span class="line">                <span class="literal">new</span> SynchronizedList&lt;&gt;(<span class="built_in">list</span>));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p><strong>注意到</strong>，这竟然还有SynchronizedRandomAccessList和SynchronizedList之分？<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedRandomAccessList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">SynchronizedList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">RandomAccess</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    SynchronizedRandomAccessList(<span class="keyword">List</span>&lt;E&gt; <span class="keyword">list</span>) &#123;</span><br><span class="line">        super(<span class="keyword">list</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>可知SynchronizedRandomAccessList继承SynchronizedList，并实现了RandomAccess接口。<br>那这接口是什么鬼？<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public<span class="built_in"> interface </span>RandomAccess &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>没了，他就只是个接口……</p><blockquote><p>读者：求你了，看一下注释吧，老哥~<br>我：emmmm，行~~<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">  * 标记接口被<span class="tag">&lt;<span class="name">tt</span>&gt;</span> List <span class="tag">&lt;/ <span class="attr">tt</span>&gt;</span>用来指示</span><br><span class="line">  *它们支持快速（通常是恒定时间）随机访问。</span><br><span class="line">  *此接口的首要目的是允许通用算法更改它们，</span><br><span class="line">  *当被应用于随机或顺序访问多个列表时，</span><br><span class="line">  *以提供良好性能</span><br><span class="line">*/</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>读者：泥垢了！！~~<br>我：emmmm~~~</p></blockquote><h5 id="synchronizedSet"><a href="#synchronizedSet" class="headerlink" title="synchronizedSet"></a>synchronizedSet</h5><p>只是把上面的例子的实例换成Set罢了、、</p><h5 id="synchronizedMap"><a href="#synchronizedMap" class="headerlink" title="synchronizedMap"></a>synchronizedMap</h5><p>只是把上面的例子的实例换Map罢了、、</p><blockquote><p>读者：这仨除了名字还有啥区别？尼莫不四郎肥劳资时间？（四窜口音~）<br>我：好吧，我真的不想骗大家了，这都被大家发现了~ （花泽香菜兵库北的笑~23333）</p></blockquote>]]></content>
      
      <categories>
          
          <category> Java之并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>线程不安全——Part-2</title>
      <link href="/2018/08/02/%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94part-2/"/>
      <url>/2018/08/02/%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94part-2/</url>
      <content type="html"><![CDATA[<h3 id="Collections部分"><a href="#Collections部分" class="headerlink" title="Collections部分"></a>Collections部分</h3><blockquote><p>一般情况下，我们使用ArrayList、HashSet、HashMap是在方法中定义局部变量，此时由于堆栈封闭的特性，自然不会有线程安全问题。但是，当将其定义为静态域中，且未做线程安全措施时，极有可能会导致多线程并发错误。</p></blockquote><a id="more"></a><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p><strong>由于该三个集合是Java中最常见的、最重要的集合，此处仅分析说明是非线程安全的类。其详细内容我会另起手记再做说明！！</strong></p><h4 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h4><p>弄个例子：(还是之前的框架)<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@NotThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayListExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> clientTotal = <span class="number">5000</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> threadTotal = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(threadTotal);</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(clientTotal);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clientTotal; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> count = i;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    update(count);</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.<span class="keyword">error</span>(<span class="string">"exception"</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">        log.info(<span class="string">"size:&#123;&#125;"</span>, list.size());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123; list.add(i); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>运行结果：</strong><br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">13<span class="selector-pseudo">:31</span><span class="selector-pseudo">:39.296</span> <span class="selector-attr">[main]</span> <span class="selector-tag">INFO</span> <span class="selector-tag">com</span><span class="selector-class">.mmall</span><span class="selector-class">.concurrency</span><span class="selector-class">.commonUnsafe</span><span class="selector-class">.ArrayListExample</span> <span class="selector-tag">-</span> <span class="selector-tag">size</span><span class="selector-pseudo">:4986</span></span><br></pre></td></tr></table></figure></p><p>显而易见，是非线程安全的。</p><h4 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h4><p>同理，HashSet同样进行测试，结果表明同样是非线程安全的！</p><h4 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h4><p>同理，HashMap同样进行测试，结果表明同样是非线程安全的！</p><h3 id="线程不安全的写法"><a href="#线程不安全的写法" class="headerlink" title="线程不安全的写法"></a>线程不安全的写法</h3><p><strong>先检查再执行</strong>：<br><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="comment">(aaaa)</span></span><br><span class="line">&#123;</span><br><span class="line">  bbbbbbbbb;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个较易解释，在之前说AtomicXXX时说过：<br>在多线程并发时，可能多个线程执行到<code>if</code>语句的判断，且同时符合，然后分别作出修改。即该操作的原子性不能得到保证！故当有多线程并发问题时，考虑清楚，加锁进行处理。</p>]]></content>
      
      <categories>
          
          <category> Java之并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>线程不安全——Part-1</title>
      <link href="/2018/08/02/%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94part-1/"/>
      <url>/2018/08/02/%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94part-1/</url>
      <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><blockquote><p>线程不安全类：如果一个类的对象同时被多个线程访问，若不做相应的同步或并发处理，容易出现线程不安全的现象，比如：抛出异常、逻辑处理错误等。</p></blockquote><a id="more"></a><h4 id="StringBiulder"><a href="#StringBiulder" class="headerlink" title="StringBiulder"></a>StringBiulder</h4><p>看一个例子：（借助之前的例子结构）<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@NotThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringExample1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> clientTotal = <span class="number">5000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> threadTotal = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(threadTotal);</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(clientTotal);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clientTotal ; i++) &#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    update();</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.<span class="keyword">error</span>(<span class="string">"exception"</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">        log.info(<span class="string">"size:&#123;&#125;"</span>, stringBuilder.length());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stringBuilder.append(<span class="string">"1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>结果分析：</strong></p><ol><li>多次运行，结果几乎未达5000，显然StringBuilder是非线程安全的。</li><li>通过定义stringBuilder对象，核心方法为update() -&gt; 每次拼接一个字符串，最后取其长度length。</li></ol><h4 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a>StringBuffer</h4><blockquote><p>例子代码结构跟上面一样，只需将StringBiulder换为StringBuffer，且其两者方法名相同。</p></blockquote><p><strong>运行结果：</strong><br>多次运行，结果均为5000。StringBuffer是线程安全的！</p><h5 id="查看StringBuffer源码"><a href="#查看StringBuffer源码" class="headerlink" title="查看StringBuffer源码"></a>查看StringBuffer源码</h5><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="built_in">append</span>(<span class="keyword">String</span> <span class="built_in">str</span>) &#123;</span><br><span class="line">    toStringCache = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">super</span>.<span class="built_in">append</span>(<span class="built_in">str</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">StringBuffer</span></span></span><br><span class="line"><span class="class">   <span class="keyword">extends</span> <span class="title">AbstractStringBuilder</span></span></span><br><span class="line"><span class="class">   <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">CharSequence</span></span>&#123;XXX省略&#125;</span><br></pre></td></tr></table></figure><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="function">String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (toStringCache == <span class="keyword">null</span>) &#123;</span><br><span class="line">        toStringCache = Arrays.copyOfRange(value, <span class="number">0</span>, count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(toStringCache, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>源码分析：</strong></p><ol><li>几乎所有复写的方法都有toStringCache变量。为对象方便转为String类型的字段，调用Arrays.copyOfRange(value, 0, count)，return new String(toStringCache, true)：其中该构造方法是String包私有的构造方法，以确保数值分享的效率。</li><li>StringBuffer继承自AbstractStringBuilder，并几乎重写了所有继承来的方法。调用父辈super的append方法，即AbstractStringBuilder的方法。且StringBuffer对象一经修改，toStringCache清空为null。类似String包装类的对象，避免多线程并发问题。（以后细说String包装类…）</li><li>为了线程安全，几乎所有复写的方法都用synchronized进行标识，即使效率较低。</li><li>StringBiulder性能好，但不适用于多线程。但适用于场景为方法内的局部变量操作（上篇线程封闭的手记中说到：隐式的堆栈封闭），线程安全且性能较好。</li></ol><h4 id="SimpleDateFormate"><a href="#SimpleDateFormate" class="headerlink" title="SimpleDateFormate"></a>SimpleDateFormate</h4><blockquote><p>Java提供的供日期转换的类。该例子结构仍然和上述例子相同。只需定义一个simpleDateFormat实例，核心方法换为parse（xxx:日期语句）</p></blockquote><p><strong>运行结果：</strong><br>出现异常：<code>parse exception -- java.lang.NumberFormatException: multiple points</code><br>非常简单，说明了该日期转换方法是非线程间安全的。</p><h5 id="正确写法：（通过堆栈封闭-gt-声明为核心方法内的局部变量，即每次声明一个新的对象进行调用）"><a href="#正确写法：（通过堆栈封闭-gt-声明为核心方法内的局部变量，即每次声明一个新的对象进行调用）" class="headerlink" title="正确写法：（通过堆栈封闭-&gt;声明为核心方法内的局部变量，即每次声明一个新的对象进行调用）"></a>正确写法：（通过堆栈封闭-&gt;声明为核心方法内的局部变量，即每次声明一个新的对象进行调用）</h5><blockquote><p>仍然是之前的测试结构，但还是贴出来看看吧。<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DateFormatExample2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求总数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> clientTotal = <span class="number">5000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同时并发执行的线程数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> threadTotal = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(threadTotal);</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(clientTotal);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clientTotal ; i++) &#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    update();</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.<span class="keyword">error</span>(<span class="string">"exception"</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            SimpleDateFormat simpleDateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyyMMdd"</span>);</span><br><span class="line">            simpleDateFormat.parse(<span class="string">"20180208"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.<span class="keyword">error</span>(<span class="string">"parse exception"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><p><strong>运行结果：</strong> 多次运行，不会报错！是线程安全！</p><h4 id="Joda-Time"><a href="#Joda-Time" class="headerlink" title="Joda Time"></a>Joda Time</h4><blockquote><p>该类本质上并不属于Java提供。需引入jar包。例子仍然是之前的测试结构。只不过日志输出了次数及当时日期<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//转换完后DateTime，调用toDate()转为Date对象。</span></span><br><span class="line">    <span class="built_in">log</span>.info(<span class="string">"&#123;&#125;, &#123;&#125;"</span>, i == <span class="number">4999</span> ? i+<span class="string">"--------------------------"</span> : i, DateTime.parse(<span class="string">"20180728"</span>, dateTimeFormatter).toDate());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><p><strong>运行结果：</strong><br>由于调用是多并发的，调用次序是乱序，但总数一定！<br>由于i是从0到4999，即当i = 4999时说明已运行慢5000个，即线程安全！<br><strong>图片截图中字体小了，可以点开看~</strong><br><img src="/2018/08/02/线程不安全——part-1/joda-Time测试.png" alt="图示"></p><p>（后接该手记part-2……）</p>]]></content>
      
      <categories>
          
          <category> Java之并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>线程封闭</title>
      <link href="/2018/08/02/%E7%BA%BF%E7%A8%8B%E5%B0%81%E9%97%AD/"/>
      <url>/2018/08/02/%E7%BA%BF%E7%A8%8B%E5%B0%81%E9%97%AD/</url>
      <content type="html"><![CDATA[<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>线程封闭是一种较为简单的线程并发的方法。它其实把对象封装到一个线程里，该对象只对该线程是可见的。当然也就是线程安全的了。</p><h4 id="实现线程封闭的方法"><a href="#实现线程封闭的方法" class="headerlink" title="实现线程封闭的方法"></a>实现线程封闭的方法</h4><ol><li>Ad-hoc 线程封闭：依赖程序控制实现，脆弱，是最糟糕的一种方式，不推荐！</li><li>堆栈封闭：应用广泛，依靠各线程局部变量的堆栈拷贝副本实现，无并发问题。避免使用全局变量。</li><li>数据库连接对应JDBC的Connection对象。</li><li>ThreadLocal线程封闭：实现较好，效率较高。（以后会做源码分析……）</li></ol><a id="more"></a><blockquote><ol start="2"><li>堆栈封闭:即指的是方法/类中的局部变量，默认是通过线程拷贝副本实现。</li><li>Connection对象在实现中并未对线程安全做过多的处理，JDBC的规范中也未要求Connection对象必须是线程安全的。但实际服务器的应用程序中，线程从连接池获取Connection对象，只有在使用结束后才将其返回给连接池，期间其他线程是获取不到Connection对象的。该机制显式提供了线程封闭。</li></ol></blockquote><h4 id="ThreadLocal测试例子"><a href="#ThreadLocal测试例子" class="headerlink" title="ThreadLocal测试例子"></a>ThreadLocal测试例子</h4><h5 id="RequestHolder-java"><a href="#RequestHolder-java" class="headerlink" title="RequestHolder.java"></a>RequestHolder.java</h5><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">RequestHolder</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> final <span class="keyword">static</span> ThreadLocal&lt;Long&gt; requestHolder = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span>(<span class="params">Long id</span>) </span>&#123;</span><br><span class="line">        requestHolder.<span class="keyword">set</span>(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Long <span class="title">getId</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> requestHolder.<span class="keyword">get</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">remove</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        requestHolder.<span class="keyword">remove</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法分析：</p><ol><li>该类存放需要绑定的信息。</li><li>其中add操作是在请求进入后端服务器，但还未进行实际处理时，调用该方法，写入相关信息。（通过filter：先拦截对应的URL，当前台访问该URL时，将相关信息写入ThreadLocal中；当URL实际被处理时，可直接从ThreadLocal中取出信息）。</li><li>定义移除方法，防止内存泄漏。在接口处理完之后进行处理（通过intercepter实现）。</li></ol><h5 id="HttpFilter-java"><a href="#HttpFilter-java" class="headerlink" title="HttpFilter.java"></a>HttpFilter.java</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//核心方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        HttpServletRequest request = (HttpServletRequest) servletRequest;</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">"do filter, &#123;&#125;, &#123;&#125;"</span>, Thread.currentThread().getId(), request.getServletPath());</span><br><span class="line"></span><br><span class="line">        RequestHolder.add(Thread.currentThread().getId());</span><br><span class="line">        filterChain.doFilter(servletRequest, servletResponse);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//销毁</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法分析：</p><ol><li>因为是通过http请求，ServletRequest需转换为HttpServletRequest类型。</li><li>在RequestHolder中放入URL相关信息。</li><li>最后若该filter不是想拦截住该请求，只是做相关的数据处理，还想让其他过滤器接收到，则需最后调用filterChain.doFilter(servletRequest, servletResponse)。</li></ol><h5 id="HttpInterceptor-java"><a href="#HttpInterceptor-java" class="headerlink" title="HttpInterceptor.java"></a>HttpInterceptor.java</h5><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">HttpInterceptor</span> <span class="keyword">extends</span> <span class="title">HandlerInterceptorAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在处理之前输出</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    public boolean preHandle(<span class="type">HttpServletRequest</span> request, <span class="type">HttpServletResponse</span> response, <span class="type">Object</span> handler) <span class="keyword">throws</span> <span class="type">Exception</span> &#123;</span><br><span class="line">        log.info(<span class="string">"preHandle"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在完成之后删除信息、输出日志</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    public void afterCompletion(<span class="type">HttpServletRequest</span> request, <span class="type">HttpServletResponse</span> response, <span class="type">Object</span> handler, <span class="type">Exception</span> ex) <span class="keyword">throws</span> <span class="type">Exception</span> &#123;</span><br><span class="line">        <span class="type">RequestHolder</span>.remove();</span><br><span class="line">        log.info(<span class="string">"afterCompletion"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="ThreadLocalController-java"><a href="#ThreadLocalController-java" class="headerlink" title="ThreadLocalController.java"></a>ThreadLocalController.java</h5><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Controller</span></span><br><span class="line"><span class="variable">@RequestMapping</span>(<span class="string">"/threadlocal"</span>)</span><br><span class="line">public class ThreadLocalController &#123;</span><br><span class="line"></span><br><span class="line">    <span class="variable">@RequestMapping</span>(<span class="string">"/test"</span>)</span><br><span class="line">    <span class="variable">@ResponseBody</span></span><br><span class="line">    public Long test() &#123;</span><br><span class="line">        <span class="selector-tag">return</span> <span class="selector-tag">RequestHolder</span><span class="selector-class">.getId</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="ConcurrencyApplication-java"><a href="#ConcurrencyApplication-java" class="headerlink" title="ConcurrencyApplication.java"></a>ConcurrencyApplication.java</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">true<span class="comment">//使用springboot快速进行测试</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrencyApplication</span> <span class="keyword">extends</span> <span class="title">WebMvcConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">true<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">truetrueSpringApplication.run(ConcurrencyApplication.class, args);</span><br><span class="line">true&#125;</span><br><span class="line"></span><br><span class="line">true<span class="meta">@Bean</span></span><br><span class="line">true<span class="function"><span class="keyword">public</span> FilterRegistrationBean <span class="title">httpFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">truetrueFilterRegistrationBean registrationBean = <span class="keyword">new</span> FilterRegistrationBean();</span><br><span class="line">truetrueregistrationBean.setFilter(<span class="keyword">new</span> HttpFilter());</span><br><span class="line"></span><br><span class="line">truetrueregistrationBean.addUrlPatterns(<span class="string">"/threadlocal/*"</span>);</span><br><span class="line">truetrue<span class="keyword">return</span> registrationBean;</span><br><span class="line">true&#125;</span><br><span class="line"></span><br><span class="line">true<span class="meta">@Override</span></span><br><span class="line">true<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">truetrueregistry.addInterceptor(<span class="keyword">new</span> HttpInterceptor()).addPathPatterns(<span class="string">"/**"</span>);</span><br><span class="line">true&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法分析：</p><ol><li>通过springboot创建registrationBean并指定过滤URL类型为”/threadlocal/*”。</li><li>重写addInterceptors -&gt; 添加拦截器，并指定拦截的路径类型。</li><li>ThreadLocalController.java中指定请求映射的名称和返回内容。</li></ol><p><strong>接口测试结果：(使用Postman进行接口测试)</strong></p><p><img src="/2018/08/02/线程封闭/threadlocal接口测试.png" alt="图示"></p><p><strong>日志部分截图：</strong></p><p><img src="/2018/08/02/线程封闭/threadlocal测试日志.png" alt="图示"></p><p>可以看出例子是和日志完全对应的。<br>重复一下<em>threadlocal的实现思想</em>：<strong>当一个请求进来时，通过过滤器Filter，将数据信息（这里是线程id）存储到threadlocal中，当接口被调用处理时，可以直接从中取出来；当接口处理完成，通过拦截器Interceptor的afterCompletion把当前线程中的数据信息（这里是线程id）移除，避免内存泄漏。</strong></p>]]></content>
      
      <categories>
          
          <category> Java之并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>不可变对象</title>
      <link href="/2018/08/02/%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%AF%B9%E8%B1%A1/"/>
      <url>/2018/08/02/%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%AF%B9%E8%B1%A1/</url>
      <content type="html"><![CDATA[<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>不可变对象一经安全发布，它就是不可变的。</p><h4 id="需满足的条件"><a href="#需满足的条件" class="headerlink" title="需满足的条件"></a>需满足的条件</h4><ul><li>对象创建后其状态不能被修改；</li><li>对象所有的域都是final类型；</li><li>对象是正确创建的（在对象创建期间，其this引用未逸出）；<blockquote><p><strong>其中可以采用的方式包括：</strong></p><ol><li>将类声明为final，不可被继承；</li><li>将所有的成员声明为私有的，不允许直接访问其私有成员；</li><li>对变量不向外提供set方法；</li><li>将所有成员也声明为final，只能赋值一次；</li><li>通过构造器初始化所有成员，进行深度拷贝;</li><li>在get方法中，不直接返回对象本身，而是克隆对象，并返回对象的拷贝。<a id="more"></a></li></ol></blockquote></li></ul><hr><h4 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h4><p>可以用来修饰类、方法、变量。</p><ol><li>修饰类：该类不能被继承：如Java中的String、Integer、Long等基础类型的封装类均是。</li></ol><ul><li>final类中的成员变量可根据需要设定为final。</li><li>final类中的方法均会被隐式指为final方法。</li></ul><ol start="2"><li>修饰方法：场景如下</li></ol><ul><li>锁定方法不会被继承类修改；</li><li>效率：在早期的Java实现版本中，会将final方法转为内嵌调用；但若final方法过大，反而拉低效率。</li><li><blockquote><p><strong>一个类的private方法会被隐式地指为final方法。</strong></p></blockquote></li></ul><ol start="3"><li>修饰变量：</li></ol><ul><li>若修饰基础数据类型：一旦初始化就不再更改。</li><li>若修饰引用类型：一旦初始化之后就不能再指向另一个对象。但可以修改其中的值。（好吧，这是废话…）</li></ul><p>看个例子：<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">@NotThreadSafe  <span class="comment">//非线程安全</span></span><br><span class="line"><span class="keyword">public</span> class ImmutableExample1 &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Integer a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">String</span> b = <span class="string">"2"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Map&lt;Integer, Integer&gt; <span class="built_in">map</span> = Maps.newHashMap();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="built_in">map</span>.put(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        <span class="built_in">map</span>.put(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">        <span class="built_in">map</span>.put(<span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">map</span>.put(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">        <span class="built_in">log</span>.info(<span class="string">"&#123;&#125;"</span>, <span class="built_in">map</span>.<span class="built_in">get</span>(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> test(<span class="keyword">final</span> <span class="built_in">int</span> a) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果：</p><p><img src="/2018/08/02/不可变对象/final关键字测试.png" alt="图示"></p><p><strong>结果分析：</strong><br>final修饰引用类型的Map：一旦初始化之后就不能再指向另一个对象。<br>但可以修改其中的值 -&gt; 向map中put（a,b）。</p><hr><h4 id="Collections-unmodifiableXXX方法"><a href="#Collections-unmodifiableXXX方法" class="headerlink" title="Collections.unmodifiableXXX方法"></a>Collections.unmodifiableXXX方法</h4><p>其中XXX可以是Collection、List、Set、Map等<br><strong>相应的可以通过传入对应的数据类型作为参数传入方法，即可变为不可变对象。</strong></p><p>看一个例子：<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">@ThreadSafe</span><br><span class="line"><span class="keyword">public</span> class ImmutableExample2 &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Integer, Integer&gt; <span class="built_in">map</span> = Maps.newHashMap();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="built_in">map</span>.<span class="built_in">put</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        <span class="built_in">map</span>.<span class="built_in">put</span>(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">        <span class="built_in">map</span>.<span class="built_in">put</span>(<span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">        <span class="comment">//调用unmodifiableMap方法</span></span><br><span class="line">        <span class="built_in">map</span> = Collections.unmodifiableMap(<span class="built_in">map</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line">        <span class="built_in">map</span>.<span class="built_in">put</span>(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">        log.info(<span class="string">"&#123;&#125;"</span>, <span class="built_in">map</span>.<span class="built_in">get</span>(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果：</p><p><img src="/2018/08/02/不可变对象/Collections.unmodified测试.png" alt="图示"></p><p><strong>结果分析：</strong><br>Collections.unmodifiableMap(xxx)方法根据字面意思，不允许修改。即<strong>既不允许再指向其他对象，也不能修改其中的值。</strong></p><p>再来看一下unmodifiableMap方法的源码：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Returns an unmodifiable view <span class="keyword">of</span> <span class="keyword">the</span> specified map.  This method</span><br><span class="line"> * allows modules <span class="keyword">to</span> provide users <span class="keyword">with</span> <span class="string">"read-only"</span> access <span class="keyword">to</span> internal</span><br><span class="line"> * maps.  Query operations <span class="keyword">on</span> <span class="keyword">the</span> returned map <span class="string">"read through"</span></span><br><span class="line"> * <span class="keyword">to</span> <span class="keyword">the</span> specified map, <span class="keyword">and</span> attempts <span class="keyword">to</span> modify <span class="keyword">the</span> returned</span><br><span class="line"> * map, whether direct <span class="keyword">or</span> via <span class="keyword">its</span> collection views, <span class="literal">result</span> <span class="keyword">in</span> an</span><br><span class="line"> * &lt;tt&gt;UnsupportedOperationException&lt;/tt&gt;.&lt;p&gt;</span><br><span class="line"> *</span><br><span class="line"> * The returned map will be serializable <span class="keyword">if</span> <span class="keyword">the</span> specified map</span><br><span class="line"> * <span class="keyword">is</span> serializable.</span><br><span class="line"> *</span><br><span class="line"> * @param &lt;K&gt; <span class="keyword">the</span> <span class="built_in">class</span> <span class="keyword">of</span> <span class="keyword">the</span> map keys</span><br><span class="line"> * @param &lt;V&gt; <span class="keyword">the</span> <span class="built_in">class</span> <span class="keyword">of</span> <span class="keyword">the</span> map values</span><br><span class="line"> * @param  m <span class="keyword">the</span> map <span class="keyword">for</span> which an unmodifiable view <span class="keyword">is</span> <span class="keyword">to</span> be returned.</span><br><span class="line"> * @<span class="literal">return</span> an unmodifiable view <span class="keyword">of</span> <span class="keyword">the</span> specified map.</span><br><span class="line"> */</span><br><span class="line">public static &lt;K,V&gt; Map&lt;K,V&gt; unmodifiableMap(Map&lt;? extends K, ? extends V&gt; m) &#123;</span><br><span class="line"><span class="built_in">    return</span> new UnmodifiableMap&lt;&gt;(m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注释还是非常易懂的。该类重新自定义的UnmodifiableMap，那么再看一下UnmodifiableMap的源码：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function">V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="function">V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">putAll</span><span class="params">(Map&lt;? <span class="keyword">extends</span> K, ? <span class="keyword">extends</span> V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">replaceAll</span><span class="params">(BiFunction&lt;? <span class="keyword">super</span> K, ? <span class="keyword">super</span> V, ? <span class="keyword">extends</span> V&gt; function)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="function">V <span class="title">putIfAbsent</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object key, Object value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">replace</span><span class="params">(K key, V oldValue, V newValue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="function">V <span class="title">replace</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="function">V <span class="title">computeIfAbsent</span><span class="params">(K key, Function&lt;? <span class="keyword">super</span> K, ? <span class="keyword">extends</span> V&gt; mappingFunction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>那么为什么抛出<code>UnsupportedOperationException</code>异常就一目了然了，<strong>该unmodifiableMap类自定义或重写的方法定义了直接不允许操作。</strong></p><p>再看一下<code>Collections</code>类总共提供了多少<code>unmodifiableXXX</code>方法：</p><p><img src="/2018/08/02/不可变对象/unmodifiableXXX方法种类.png" alt="图示"></p><hr><h4 id="Guava的ImmutableXXX类"><a href="#Guava的ImmutableXXX类" class="headerlink" title="Guava的ImmutableXXX类"></a>Guava的ImmutableXXX类</h4><p>相似的，其中XXX可以是<code>Collection</code>、<code>List</code>、<code>Set</code>、<code>Map</code>等<br><strong>这些类都提供了带初始化数据的声明方法，一旦初始化完成就成不可变对象了。</strong></p><p>看一个例子：<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@ThreadSafe</span><br><span class="line"><span class="keyword">public</span> class ImmutableExample3 &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> ImmutableList&lt;Integer&gt; list = ImmutableList.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> ImmutableSet <span class="built_in">set</span> = ImmutableSet.copyOf(list);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> ImmutableMap&lt;Integer, Integer&gt; <span class="built_in">map</span> = ImmutableMap.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> ImmutableMap&lt;Integer, Integer&gt; map2 = ImmutableMap.&lt;Integer, Integer&gt;builder()</span><br><span class="line">            .put(<span class="number">1</span>, <span class="number">2</span>).put(<span class="number">3</span>, <span class="number">4</span>).put(<span class="number">5</span>, <span class="number">6</span>).build();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(map2.<span class="built_in">get</span>(<span class="number">3</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果：4</p><p><strong>例子分析：</strong></p><ol><li><code>ImmutableList</code>通过<code>of(a,b,c,xxxx)</code>方法来填充数据，其中的数据为初始化的数据。</li><li><code>copyOf(xx)</code>方法直接拷贝其他集合中数据。</li><li>通过<code>builder().put(a, b)..put(x, x).(...).build()</code>不停<code>put(x,x)</code>填充数据。</li></ol><p>如果需要初始化的数据不是三个呢？<br>废话不多说，看一下<code>of()</code>的源码：<br><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;<span class="keyword">E</span>&gt; ImmutableList&lt;<span class="keyword">E</span>&gt; of(<span class="keyword">E</span> element) &#123;</span><br><span class="line">    return new SingletonImmutableList(element);</span><br><span class="line">&#125;</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">public static &lt;<span class="keyword">E</span>&gt; ImmutableList&lt;<span class="keyword">E</span>&gt; of(<span class="keyword">E</span> e1, <span class="keyword">E</span> e2, <span class="keyword">E</span> e3, <span class="keyword">E</span> e4, <span class="keyword">E</span> e5, <span class="keyword">E</span> e6, <span class="keyword">E</span> e7, <span class="keyword">E</span> e8, <span class="keyword">E</span> e9, <span class="keyword">E</span> e10, <span class="keyword">E</span> e11) &#123;</span><br><span class="line">    return construct(e1, e2, e3, e4, e5, e6, e7, e8, e9, e10, e11);</span><br><span class="line">&#125;</span><br><span class="line">@SafeVarargs</span><br><span class="line">public static &lt;<span class="keyword">E</span>&gt; ImmutableList&lt;<span class="keyword">E</span>&gt; of(<span class="keyword">E</span> e1, <span class="keyword">E</span> e2, <span class="keyword">E</span> e3, <span class="keyword">E</span> e4, <span class="keyword">E</span> e5, <span class="keyword">E</span> e6, <span class="keyword">E</span> e7, <span class="keyword">E</span> e8, <span class="keyword">E</span> e9, <span class="keyword">E</span> e10, <span class="keyword">E</span> e11, <span class="keyword">E</span> e12, <span class="keyword">E</span>... others) &#123;</span><br><span class="line">    Object[] array = new Object[12 + others.length];</span><br><span class="line">    array[0] = e1;</span><br><span class="line">    array[1] = e2;</span><br><span class="line">    array[2] = e3;</span><br><span class="line">    array[3] = e4;</span><br><span class="line">    array[4] = e5;</span><br><span class="line">    array[5] = e6;</span><br><span class="line">    array[6] = e7;</span><br><span class="line">    array[7] = e8;</span><br><span class="line">    array[8] = e9;</span><br><span class="line">    array[9] = e10;</span><br><span class="line">    array[10] = e11;</span><br><span class="line">    array[11] = e12;</span><br><span class="line">    System.arraycopy(others, 0, array, 12, others.length);</span><br><span class="line">    return construct(array);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>源码分析：</strong><br>可以看出它提供了参数从1个到11、12个的函数重载情况。再定睛一看：</p><ul><li><strong>一个注解：@SafeVarargs –&gt;安全的可变参数函数。</strong></li><li>而且参数列表里最后还有<code>E... others</code> –&gt; 指除前12参数外的参数，用一个数组表示。<h5 id="那函数里是怎么处理这个数组呢？"><a href="#那函数里是怎么处理这个数组呢？" class="headerlink" title="那函数里是怎么处理这个数组呢？"></a>那函数里是怎么处理这个数组呢？</h5>通过系统函数，将该数组安全地拷贝进来。<br>所以无论需要初始化的参数有多少都是可以处理的~ 哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈</li></ul><p><strong>其实Guava的ImmutableXXX类和Collections.unmodifiableXXX方法的实现基本是异曲同工的：</strong></p><ol><li>都是既不允许再指向其他对象，也不能修改其中的值；</li><li>否则都会抛出<code>UnsupportedOperationException</code>异常。</li></ol>]]></content>
      
      <categories>
          
          <category> Java之并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>安对象安全发布的四种策略</title>
      <link href="/2018/08/02/%E5%AE%89%E5%AF%B9%E8%B1%A1%E5%AE%89%E5%85%A8%E5%8F%91%E5%B8%83%E7%9A%84%E5%9B%9B%E7%A7%8D%E7%AD%96%E7%95%A5/"/>
      <url>/2018/08/02/%E5%AE%89%E5%AF%B9%E8%B1%A1%E5%AE%89%E5%85%A8%E5%8F%91%E5%B8%83%E7%9A%84%E5%9B%9B%E7%A7%8D%E7%AD%96%E7%95%A5/</url>
      <content type="html"><![CDATA[<blockquote><p>本节例子内容较多~</p></blockquote><h4 id="四种方法概述"><a href="#四种方法概述" class="headerlink" title="四种方法概述"></a>四种方法概述</h4><ul><li>在静态初始化函数中初始化一个函数的引用</li><li>将对象的引用保存到volatile类型域AtomicReference对象中</li><li>将对象的引用保存到某个正确构造对象的final类型域中（后续再进行补充！）</li><li>将对象的引用保存到一个由锁保存的域中<a id="more"></a><h4 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h4></li></ul><blockquote><p>通过在Spring框架中构造线程安全且只被初始化一次的不同单例(Singleton)进行演示。</p></blockquote><h5 id="懒汉模式：（单例实例在第一次使用时进行创建）"><a href="#懒汉模式：（单例实例在第一次使用时进行创建）" class="headerlink" title="懒汉模式：（单例实例在第一次使用时进行创建）"></a>懒汉模式：（单例实例在<strong>第一次使用时进行创建</strong>）</h5><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@NotThreadSafe</span><br><span class="line">public class SingletonExample1 &#123;</span><br><span class="line"></span><br><span class="line">    // 私有构造函数</span><br><span class="line">   <span class="keyword"> private</span> SingletonExample1() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 单例对象</span><br><span class="line">   <span class="keyword"> private</span><span class="keyword"> static</span> SingletonExample1<span class="built_in"> instance </span>= null;</span><br><span class="line"></span><br><span class="line">    // 静态的工厂方法</span><br><span class="line">   <span class="keyword"> public</span><span class="keyword"> static</span> SingletonExample1 getInstance() &#123;</span><br><span class="line">       <span class="built_in"> if </span>(instance == null) &#123;</span><br><span class="line">           <span class="built_in"> instance </span>=<span class="built_in"> new </span>SingletonExample1();</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="built_in"> return </span>instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>分析一下：</strong></p><ol><li>单线程时使用没问题。</li><li>多线程时，当多个线程同时判断到instance == null，那么该多个线程都会创建一个实例，即非线程安全，因此该方法无法保证实例只被初始化一次。</li></ol><hr><h5 id="饿汉模式：（单例实例在类装载时进行创建）"><a href="#饿汉模式：（单例实例在类装载时进行创建）" class="headerlink" title="饿汉模式：（单例实例在类装载时进行创建）"></a>饿汉模式：（单例实例在类装载时进行创建）</h5><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@ThreadSafe</span><br><span class="line">public class SingletonExample2 &#123;</span><br><span class="line"></span><br><span class="line">    // 私有构造函数</span><br><span class="line">   <span class="keyword"> private</span> SingletonExample2() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 单例对象</span><br><span class="line">   <span class="keyword"> private</span><span class="keyword"> static</span> SingletonExample2<span class="built_in"> instance </span>=<span class="built_in"> new </span>SingletonExample2();</span><br><span class="line"></span><br><span class="line">    // 静态的工厂方法</span><br><span class="line">   <span class="keyword"> public</span><span class="keyword"> static</span> SingletonExample2 getInstance() &#123;</span><br><span class="line">       <span class="built_in"> return </span>instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>分析一下：</strong></p><ol><li>该方式为线程安全。</li><li>不足：如果单例类的构造方法中有较多的处理逻辑，导致类加载慢，可能会引起性能问题。</li><li>由于是饿汉模式，如果只声明了该类但实际不调用该类，即造成系统资源的浪费。</li></ol><hr><h5 id="改造的懒汉模式-1：synchronized标识工厂方法"><a href="#改造的懒汉模式-1：synchronized标识工厂方法" class="headerlink" title="改造的懒汉模式-1：synchronized标识工厂方法"></a>改造的懒汉模式-1：synchronized标识工厂方法</h5><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@ThreadSafe</span><br><span class="line">@NotRecommend</span><br><span class="line">public class SingletonExample3 &#123;</span><br><span class="line"></span><br><span class="line">    // 私有构造函数</span><br><span class="line">   <span class="keyword"> private</span> SingletonExample3() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 单例对象</span><br><span class="line">   <span class="keyword"> private</span><span class="keyword"> static</span> SingletonExample3<span class="built_in"> instance </span>= null;</span><br><span class="line"></span><br><span class="line">    // 静态的工厂方法</span><br><span class="line">   <span class="keyword"> public</span><span class="keyword"> static</span> synchronized SingletonExample3 getInstance() &#123;</span><br><span class="line">       <span class="built_in"> if </span>(instance == null) &#123;</span><br><span class="line">           <span class="built_in"> instance </span>=<span class="built_in"> new </span>SingletonExample3();</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="built_in"> return </span>instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>分析一下：</strong></p><ol><li>是线程安全的。</li><li>通过给工厂方法添加synchronized关键字实现。</li><li>不推荐使用：通过阻塞线程-&gt;牺牲性能，达到线程安全目的。</li></ol><hr><h5 id="改造的懒汉模式-2：（双重同步锁单例模式）"><a href="#改造的懒汉模式-2：（双重同步锁单例模式）" class="headerlink" title="改造的懒汉模式-2：（双重同步锁单例模式）"></a>改造的懒汉模式-2：（双重同步锁单例模式）</h5><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">@NotThreadSafe</span><br><span class="line">public class SingletonExample4 &#123;</span><br><span class="line"></span><br><span class="line">    // 私有构造函数</span><br><span class="line">   <span class="keyword"> private</span> SingletonExample4() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // JVM和cpu优化，发生了指令重排</span><br><span class="line"></span><br><span class="line">    // 1、memory = allocate() 分配对象的内存空间</span><br><span class="line">    // 3、instance = memory 设置instance指向刚分配的内存</span><br><span class="line">    // 2、ctorInstance() 初始化对象</span><br><span class="line"></span><br><span class="line">    // 单例对象</span><br><span class="line">   <span class="keyword"> private</span><span class="keyword"> static</span> SingletonExample4<span class="built_in"> instance </span>= null;</span><br><span class="line"></span><br><span class="line">    // 静态的工厂方法</span><br><span class="line">   <span class="keyword"> public</span><span class="keyword"> static</span> SingletonExample4 getInstance() &#123;</span><br><span class="line">       <span class="built_in"> if </span>(instance == null) &#123; // 双重检测机制        // B</span><br><span class="line">            synchronized (SingletonExample4.class) &#123; // 同步锁</span><br><span class="line">               <span class="built_in"> if </span>(instance == null) &#123;</span><br><span class="line">                   <span class="built_in"> instance </span>=<span class="built_in"> new </span>SingletonExample4(); // A - 3</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="built_in"> return </span>instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>分析一下：</strong></p><ol><li><strong>非线程安全</strong>。</li><li>将synchronized标识下沉到方法的实现中</li><li>外层instance == null和方法实现中的synchronized标识共同保证只有一个线程进行初始化。</li><li>内层的instance == null为防止上一时刻中可能存在的线程进行了初始化。</li></ol><h5 id="非线程安全分析："><a href="#非线程安全分析：" class="headerlink" title="非线程安全分析："></a>非线程安全分析：</h5><p>当执行实例初始化instance = new SingletonExample4()时，CPU内部过程为：</p><ol><li>memory = allocate() -&gt; 分配对象的内存空间；</li><li>ctorInstance() -&gt; 初始化对象；</li><li>instance = memory -&gt; 设置instance指向刚分配的内存。</li></ol><p><strong>但是</strong>！！<br>在<code>多线程环境</code>中，由于<strong>JVM和CPU优化</strong>，会发生指令重排，CPU内部顺序为：（其中的1、2、3是指令间的原始顺序）</p><ol><li>memory = allocate() -&gt; 分配对象的内存空间；</li><li>instance = memory -&gt; 设置instance指向刚分配的内存。</li><li>ctorInstance() -&gt; 初始化对象；</li></ol><p>因此，此时的双重同步锁机制中产生了变化：</p><p>若两个线程A和B，其中线程A执行到初始化<code>instance = new SingletonExample4()</code>，此时恰好正处于指令重排的<code>instance = memory</code> ，即设置<code>instance</code>指向刚分配的内存，同时线程B恰好处于外层的<code>instance == null</code>判断，发现此时内存中该<code>instance</code>指向的内存地址不为<code>nul</code>，则会直接<code>return instance</code>，但此时的<code>instance</code>只是分配了内存还未进行初始化，即产生错误！为<strong>非线程安全</strong>！！</p><p><font color="#7FFFD4" size="6">但是！！！！！</font><br>既然是内存中实例未完全初始化，怎么解决呢？？<br>想起来之前说过的<strong>volatile关键字</strong>的用法了没？？？<br>它通过加入<strong>内存屏障</strong>，限制JVM或CPU进行指令重排！！</p><p>将该实例用volatile标识声明：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private volatile static SingletonExample5<span class="built_in"> instance </span>= <span class="literal">null</span>;</span><br></pre></td></tr></table></figure></p><p>此时，该双重同步锁单例模式就是线程安全的了！！</p><hr><h5 id="实例枚举模式："><a href="#实例枚举模式：" class="headerlink" title="实例枚举模式："></a>实例枚举模式：</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonExample7</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonExample7</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonExample7 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Singleton.INSTANCE.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//枚举类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">enum</span> Singleton &#123;</span><br><span class="line">        INSTANCE;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> SingletonExample7 singleton;</span><br><span class="line"></span><br><span class="line">        Singleton() &#123;</span><br><span class="line">            singleton = <span class="keyword">new</span> SingletonExample7();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> SingletonExample7 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> singleton;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>分析一下：</strong></p><ol><li>枚举模式是最安全的！较推荐的写法！</li><li>通过枚举类中指定一个单例<code>Singleton</code>的实例<code>INSTANCE</code>枚举实现。</li><li>其中<code>Singleton(){xxxx}</code>域，是通过JVM保证这个方法在被调用前初始化，并绝对只调用一次。</li><li>相比于懒汉模式，它的安全性更易保证；相比于饿汉模式，它是在实际调用时才进行初始化，并直接取到其值，不会有系统资源的占用浪费。</li></ol>]]></content>
      
      <categories>
          
          <category> Java之并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>安全发布对象——发布与逸出</title>
      <link href="/2018/08/02/%E5%AE%89%E5%85%A8%E5%8F%91%E5%B8%83%E5%AF%B9%E8%B1%A1%E2%80%94%E2%80%94%E5%8F%91%E5%B8%83%E4%B8%8E%E9%80%B8%E5%87%BA/"/>
      <url>/2018/08/02/%E5%AE%89%E5%85%A8%E5%8F%91%E5%B8%83%E5%AF%B9%E8%B1%A1%E2%80%94%E2%80%94%E5%8F%91%E5%B8%83%E4%B8%8E%E9%80%B8%E5%87%BA/</url>
      <content type="html"><![CDATA[<h4 id="对象发布"><a href="#对象发布" class="headerlink" title="对象发布"></a>对象发布</h4><p>使一个对象能够被其他范围之外的对象/代码所使用。</p><blockquote><p>实际日常开发中经常发布对象的例子有：</p><ol><li>通过类的非私有方法，返回对象的引用；</li><li>通过公有的静态变量发布对象</li></ol></blockquote><a id="more"></a><h4 id="对象逸出"><a href="#对象逸出" class="headerlink" title="对象逸出"></a>对象逸出</h4><p>是一种错误的对象发布。当一个对象还未构造完成就已经被其他的线程观察到。</p><h5 id="发布对象示范例子："><a href="#发布对象示范例子：" class="headerlink" title="发布对象示范例子："></a>发布对象示范例子：</h5><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@NotThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> NotSafePublish &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">String</span>[] states = &#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过类的非私有方法，返回对象的引用</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">String</span>[] getStates() &#123;</span><br><span class="line">        <span class="keyword">return</span> states;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> main(<span class="built_in">String</span>[] args) &#123;</span><br><span class="line">        NotSafePublish unsafePublish = <span class="keyword">new</span> NotSafePublish();</span><br><span class="line">        log.info(<span class="string">"&#123;&#125;"</span>, Arrays.toString(unsafePublish.getStates()));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过上面的非法发布，修改其私有变量</span></span><br><span class="line">        unsafePublish.getStates()[<span class="number">0</span>] = <span class="string">"d"</span>;</span><br><span class="line">        log.info(<span class="string">"&#123;&#125;"</span>, Arrays.toString(unsafePublish.getStates()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察结果：</p><p><img src="/2018/08/02/安全发布对象——发布与逸出/非法发布测试.png" alt="图示"></p><p>显然该发布方式是<strong>非线程安全</strong>的。</p><h5 id="对象逸出示范例子："><a href="#对象逸出示范例子：" class="headerlink" title="对象逸出示范例子："></a>对象逸出示范例子：</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Escape</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义可能会逸出的私有变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> thisCanEscape = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回一内部类的引用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Escape</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> InnerClass();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//私有内部类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span> &#123;</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">InnerClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="built_in">log</span>.info(<span class="string">"&#123;&#125;"</span>, Escape.<span class="keyword">this</span>.thisCanEscape);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//调用公有方法</span></span><br><span class="line">        <span class="keyword">new</span> Escape();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察结果：</p><p><img src="/2018/08/02/安全发布对象——发布与逸出/发布逸出.png" alt="图示"></p><p>显然内部类的成员变量被一个公有方法观察到了！</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>显然上述的方式都是错误的，不被推荐的！<br>不正确地发布对象可能会导致两种错误：</p><ol><li>发布对象所在线程以外的线程都可以看到发布对象的值（状态）。</li><li>（更严重）其他线程看到的对象的引用是最新的，但值（状态）是已过期的。</li></ol><p>若该对象是可变对象，那么它必须要被安全发布。 <em>对象未完成之前不可以将其发布。</em> 多多注意。</p><p><strong>避免方法：通过专有的start()或初始化方法统一启动。其中可以采用工厂方法结合私有构造函数，完成对象的创建和监听器的注册</strong></p>]]></content>
      
      <categories>
          
          <category> Java之并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>线程安全-有序性</title>
      <link href="/2018/08/02/%E7%BA%BF%E7%A8%8B%E5%AE%89-%E6%9C%89%E5%BA%8F%E6%80%A7/"/>
      <url>/2018/08/02/%E7%BA%BF%E7%A8%8B%E5%AE%89-%E6%9C%89%E5%BA%8F%E6%80%A7/</url>
      <content type="html"><![CDATA[<h4 id="问题导出"><a href="#问题导出" class="headerlink" title="问题导出"></a>问题导出</h4><ol><li>Java内存模型中，允许编译器和翻译器对指令进行重排序，但是重排序的过程不会影响到<strong>单线程</strong>程序的运行，却会影响到多线程并发执行的正确性。</li><li>Java中的volatile通过<code>内存屏障</code>也可以一定程度上禁止指令的重排序。</li><li>synchronized和Lock机制都是通过线程阻塞对于主内存来讲其同一时刻只有一个线程可以访问操作，保证了有序性。</li><li>Java内存模型实际存在先天的有序性：不需要通过任何手段即可保证一定的有序性，即happens-before原则。</li></ol><a id="more"></a><blockquote><p>如果两个操作的次序无法从happens-before原则中得到保证，那么该两个操作不能保证自己的有序性：即被JVM随意地进行重排序。</p></blockquote><h4 id="happens-before原则"><a href="#happens-before原则" class="headerlink" title="happens-before原则"></a>happens-before原则</h4><blockquote><p>前四条较为重要，后四条浅显易懂</p></blockquote><ol><li>程序次序规则：<strong>单线程内</strong>，按照代码顺序，书写在前面的操作先行发生与书写在后面的操作。（此时的JVM只会对非数据依赖的指令进行重排序）</li><li>锁定规则：一个unlock操作先行发生于后面对同一个锁的lock操作。</li><li><strong>volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作。</strong></li><li>传递规则：若操作A先行发生于操作B，B又先行发生于操作C，那么操作A先行发生于操作C。</li><li>线程启动规则：Thread对象的start()方法先行发生于此线程的每一个动作。</li><li>线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生。</li><li>线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行。</li><li>对象终结规则：一个对象的初始化完成先行发生于它的finalize()方法的开始。</li></ol>]]></content>
      
      <categories>
          
          <category> Java之并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>线程安全-可见性</title>
      <link href="/2018/08/02/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8-%E5%8F%AF%E8%A7%81%E6%80%A7/"/>
      <url>/2018/08/02/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8-%E5%8F%AF%E8%A7%81%E6%80%A7/</url>
      <content type="html"><![CDATA[<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>指一个线程对主内存的修改，可以及时地被其他线程观察到。</p><blockquote><p>导致共享变量在线程间不可见的原因有：</p><ol><li>多线程交叉进行。</li><li>重排序结合多线程运行。</li><li>共享变量更新后的值未及时进行工作内存与主内存的更新。</li></ol></blockquote><a id="more"></a><h4 id="可见性之synchronized关键字"><a href="#可见性之synchronized关键字" class="headerlink" title="可见性之synchronized关键字"></a>可见性之synchronized关键字</h4><p>Java内存模型对synchronized关键字有两条规定。</p><ol><li>线程解锁前必须把共享变量的最新值刷新到主内存。</li><li>线程加锁时，将清空工作内存中共享变量的值。那么工作内存需要时只能从工作内存中取值。</li></ol><p><strong>工作原理：此时的加锁和解锁用的是一个锁，即多线程之间共享synchronized一个锁。</strong></p><h4 id="可见性之volatile关键字"><a href="#可见性之volatile关键字" class="headerlink" title="可见性之volatile关键字"></a>可见性之volatile关键字</h4><p><strong>工作原理：通过加入<code>内存屏障</code>和<code>禁止重排序优化</code>来实现，即通过<code>内存屏障</code>保证了<code>禁止重排序优化</code></strong><br><code>内存屏障</code>从以下两点进行说明：</p><ol><li>对volatile变量进行写操作时，会在写操作后加入一条store屏障指令，将本地工作内存中的值刷新到主内存。</li><li>对volatile变量进行读操作时，会在读操作前加入一条load屏障指令，从主内存读取共享变量的值。<blockquote><p>即强迫从主内存中的共享变量进行交互。</p></blockquote></li></ol><p><strong>volatile写原理：</strong></p><p><img src="/2018/08/02/线程安全-可见性/volatile写.png" alt="volatile写"></p><p><strong>volatile读原理：</strong></p><p><img src="/2018/08/02/线程安全-可见性/volatile读.png" alt="volatile读"></p><p>示例代码：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@NotThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountExample4</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求总数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> clientTotal = <span class="number">5000</span>;</span><br><span class="line">    <span class="comment">// 同时并发执行的线程数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> threadTotal = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(threadTotal);</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(clientTotal);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clientTotal ; i++) &#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    add();</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.<span class="keyword">error</span>(<span class="string">"exception"</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">        log.info(<span class="string">"count:&#123;&#125;"</span>, count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="comment">// 1、count</span></span><br><span class="line">        <span class="comment">// 2、+1</span></span><br><span class="line"></span><br><span class="line">    &#125;<span class="comment">// 3、count</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>多次运行结果：仍然无法保证线程安全<br>两次测试结果如下：</p><p><img src="/2018/08/02/线程安全-可见性/volatile可见性测试-1.png" alt="图示"></p><p><img src="/2018/08/02/线程安全-可见性/volatile可见性测试-2.png" alt="图示"></p><h5 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h5><p>volatile修饰的count进行++时，分为三步进行：</p><ol><li>取出count</li><li>count+1</li><li>写入count</li></ol><p>已知在第一步的取数时，取出的都是主内存的最新值。<strong>但是写入的时候就可能发生问题。</strong> 当多个线程进行操作时，同时取出主内存中的<code>count</code>，并执行+1，然后同时写入主内存，那么导致请求总数永远比<code>clientcount</code>值小，即<strong>volatile关键字只能保证可见性，但并具有原子性，不能保证线程安全</strong>！</p><h5 id="volatile使用的场景"><a href="#volatile使用的场景" class="headerlink" title="volatile使用的场景"></a>volatile使用的场景</h5><p>场景需具备的条件：</p><ol><li>对变量的写操作不依赖与当前值</li><li>该变量没有包含在具有其他变量的不变的式子中。</li></ol><p>因此，</p><ol><li><strong><code>volatile</code>适合作为状态标记量(boolean型)</strong></li><li><strong>适用于<code>doublecheck</code>场景。</strong>（例子会在之后手记中添上……）</li></ol>]]></content>
      
      <categories>
          
          <category> Java之并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>内在锁Synchronized关键字</title>
      <link href="/2018/08/02/%E5%86%85%E5%9C%A8%E9%94%81synchronized%E5%85%B3%E9%94%AE%E5%AD%97/"/>
      <url>/2018/08/02/%E5%86%85%E5%9C%A8%E9%94%81synchronized%E5%85%B3%E9%94%AE%E5%AD%97/</url>
      <content type="html"><![CDATA[<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>Java 语言中主要的同步手段就是 synchronized 关键字，它强制实行互斥，确保执行 synchronized 块的线程的动作，能够被后来执行受相同锁保护的 synchronized 块的其他线程看到。<a id="more"></a><br>在使用得当的时候，内在锁可以让程序做到线程安全，但是在使用锁定保护短的代码路径，而且线程频繁地争用锁的时候，锁定可能成为相当繁重的操作。<a href="https://www.ibm.com/developerworks/cn/java/j-jtp04186/" target="_blank" rel="noopener">参考学习</a></p><blockquote><p>内在锁synchronized关键字的实现依赖于JVM，因此<strong>在这个关键字作用的对象的作用范围内都是同一时刻只能有一个线程进行操作。</strong></p></blockquote><p>它是一种同步锁，作用对象有四种：</p><ol><li>修饰代码块：指用大括号括起来的代码，被称为“同步代码块”，作用于调用该代码块的对象。</li><li>修饰方法：指整个方法，被称为同步方法，作用于调用该方法的对象。</li><li>修饰静态方法：指整个静态方法，由于静态方法可以被理解为类级别的对象，因此它作用于该类的所有的对象。</li><li>修饰类：指整个类，作用于该类的所有的对象。</li></ol><h4 id="引申拓展：另一种锁Lock"><a href="#引申拓展：另一种锁Lock" class="headerlink" title="引申拓展：另一种锁Lock"></a>引申拓展：另一种锁Lock</h4><p>JDK提供的基于源码的锁，依赖于特殊的CPU指令、代码实现。其代表为ReentrantLock.<br>后续将会单独做一篇手记。</p><h4 id="线程安全中原子性方式的简单对比"><a href="#线程安全中原子性方式的简单对比" class="headerlink" title="线程安全中原子性方式的简单对比"></a>线程安全中原子性方式的简单对比</h4><ol><li>synchronized：是不可中断锁，适合竞争不激烈的场景，其可读性较好。</li><li>Lock：可通过unlock进行锁的中断，在竞争激烈时仍可以保持常态，同步多样化。</li><li>Atomic包：竞争激烈时也可以保持常态，性能比Lock好，但缺点是只能通过CAS同步一个值。</li></ol>]]></content>
      
      <categories>
          
          <category> Java之并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>AtomicStampReference：CAS中的ABA问题</title>
      <link href="/2018/08/02/AtomicStampReference%EF%BC%9ACAS%E4%B8%AD%E7%9A%84ABA%E9%97%AE%E9%A2%98/"/>
      <url>/2018/08/02/AtomicStampReference%EF%BC%9ACAS%E4%B8%AD%E7%9A%84ABA%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<h4 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h4><blockquote><p>CAS算法实现一个重要前提：<strong>需要取出内存中某时刻的数据，而在下时刻比较并替换，那么在这个时间差类会导致数据的变化。</strong></p></blockquote><a id="more"></a><p>举一个例子：<br>现有一个用单向链表实现的堆栈，栈顶为A，这时线程T1已经知道A.next为B，然后希望用CAS将栈顶替换为B：进行<code>head.compareAndSet(A,B)</code>，在T1执行上面这条指令之前，线程T2介入，将A、B出栈，再pushD、C、A，而对象B此时正处于游离状态；若此时轮到线程T1执行CAS操作，检测发现栈顶仍为A，所以CAS成功，栈顶变为B，但实际上B.next为null。结果现在堆栈中只有B一个元素，C和D组成的链表不再存在于堆栈中，此时C、D平白无故被弄丢了。</p><h5 id="其实还有另外一种情况："><a href="#其实还有另外一种情况：" class="headerlink" title="其实还有另外一种情况："></a>其实还有另外一种情况：</h5><p><strong>A最开始的内存地址是X，然后失效了，有分配了B，恰好内存地址是X，这时候通过CAS操作也成功了</strong>，但是在像Java这种有GC机制的语言中，若A失效就被GC处理了，不会发生这种情况。若是在像C/C++没有GC机制的语言中是有可能出现的。</p><h5 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h5><ol><li>像各种乐观锁的实现中通常都会用版本戳version(保持递增加一规则)来对记录或对象标记，在CAS时加上对该版本戳的比较。</li><li>在Java语言中，AtomicStampedReference<e>也是使用类似的机制做解决方案。</e></li></ol><p>其核心方法为：<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Atomically sets the value of both the reference and stamp</span></span><br><span class="line"><span class="comment"> * to the given update values if the</span></span><br><span class="line"><span class="comment"> * current reference is &#123;@code ==&#125; to the expected reference</span></span><br><span class="line"><span class="comment"> * and the current stamp is equal to the expected stamp.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param expectedReference the expected value of the reference</span></span><br><span class="line"><span class="comment"> * @param newReference the new value for the reference</span></span><br><span class="line"><span class="comment"> * @param expectedStamp the expected value of the stamp</span></span><br><span class="line"><span class="comment"> * @param newStamp the new value for the stamp</span></span><br><span class="line"><span class="comment"> * @return &#123;@code true&#125; if successful</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> boolean compareAndSet(V   expectedReference,</span><br><span class="line">                             V   <span class="keyword">new</span><span class="type">Reference</span>,</span><br><span class="line">                             int expectedStamp,</span><br><span class="line">                             int <span class="keyword">new</span><span class="type">Stamp</span>) &#123;</span><br><span class="line">    Pair&lt;V&gt; current = pair;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">        expectedReference == current.reference &amp;&amp;</span><br><span class="line">        expectedStamp == current.stamp &amp;&amp;</span><br><span class="line">        ((<span class="keyword">new</span><span class="type">Reference</span> == current.reference &amp;&amp;</span><br><span class="line">          <span class="keyword">new</span><span class="type">Stamp</span> == current.stamp) ||</span><br><span class="line">         casPair(current, Pair.of(<span class="keyword">new</span><span class="type">Reference</span>, <span class="keyword">new</span><span class="type">Stamp</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中设定stamp值的原子性方法为：由于是非阻塞方法，即使两个参数对应，请求也会不合逻辑地失败。但最终当没有其他线程请求时就会成功。<a href="https://www.ibm.com/developerworks/cn/java/j-jtp04186/" target="_blank" rel="noopener">推荐阅读</a><br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Atomically sets <span class="keyword">the</span> value <span class="keyword">of</span> <span class="keyword">the</span> stamp <span class="keyword">to</span> <span class="keyword">the</span> <span class="keyword">given</span> update value</span><br><span class="line"> * <span class="keyword">if</span> <span class="keyword">the</span> current <span class="keyword">reference</span> <span class="keyword">is</span> &#123;@code ==&#125; <span class="keyword">to</span> <span class="keyword">the</span> expected</span><br><span class="line"> * <span class="keyword">reference</span>.  Any <span class="keyword">given</span> invocation <span class="keyword">of</span> this operation may fail</span><br><span class="line"> * (<span class="literal">return</span> &#123;@code <span class="literal">false</span>&#125;) spuriously, <span class="keyword">but</span> repeated invocation</span><br><span class="line"> * when <span class="keyword">the</span> current value holds <span class="keyword">the</span> expected value <span class="keyword">and</span> no other</span><br><span class="line"> * thread <span class="keyword">is</span> also attempting <span class="keyword">to</span> <span class="keyword">set</span> <span class="keyword">the</span> value will eventually</span><br><span class="line"> * succeed.</span><br><span class="line"> *</span><br><span class="line"> * @param expectedReference <span class="keyword">the</span> expected value <span class="keyword">of</span> <span class="keyword">the</span> <span class="keyword">reference</span></span><br><span class="line"> * @param newStamp <span class="keyword">the</span> new value <span class="keyword">for</span> <span class="keyword">the</span> stamp</span><br><span class="line"> * @<span class="literal">return</span> &#123;@code <span class="literal">true</span>&#125; <span class="keyword">if</span> successful</span><br><span class="line"> */</span><br><span class="line">public <span class="built_in">boolean</span> attemptStamp(V expectedReference, int newStamp) &#123;</span><br><span class="line">    Pair&lt;V&gt; current = pair;</span><br><span class="line"><span class="built_in">    return</span></span><br><span class="line">        expectedReference == current.<span class="keyword">reference</span> &amp;&amp;</span><br><span class="line">        (newStamp == current.stamp ||</span><br><span class="line">         casPair(current, Pair.<span class="keyword">of</span>(expectedReference, newStamp)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面都用到unsafe的原子性方法compareAndSwapObject(xxxx)：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> boolean casPair(Pair&lt;V&gt; cmp, Pair&lt;V&gt; <span class="keyword">val</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, pairOffset, cmp, <span class="keyword">val</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> Java之并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>线程安全之原子性--Atomic包-Part-3</title>
      <link href="/2018/08/02/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B9%8B%E5%8E%9F%E5%AD%90%E6%80%A7-Atomic%E5%8C%85-part-3/"/>
      <url>/2018/08/02/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B9%8B%E5%8E%9F%E5%AD%90%E6%80%A7-Atomic%E5%8C%85-part-3/</url>
      <content type="html"><![CDATA[<blockquote><p> AtomicReference与AtomicReferenceFiledUpdater比较分析</p></blockquote><a id="more"></a><h4 id="AtomicReference分析"><a href="#AtomicReference分析" class="headerlink" title="AtomicReference分析"></a>AtomicReference分析</h4><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">@ThreadSafe</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicExample4</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicReference&lt;Integer&gt; <span class="keyword">count</span> = <span class="keyword">new</span> AtomicReference&lt;&gt;(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</span><br><span class="line">        <span class="keyword">count</span>.compareAndSet(<span class="number">0</span>, <span class="number">2</span>); <span class="comment">// 更新为2</span></span><br><span class="line">        <span class="keyword">count</span>.compareAndSet(<span class="number">0</span>, <span class="number">1</span>); <span class="comment">// 不</span></span><br><span class="line">        <span class="keyword">count</span>.compareAndSet(<span class="number">1</span>, <span class="number">3</span>); <span class="comment">// 不</span></span><br><span class="line">        <span class="keyword">count</span>.compareAndSet(<span class="number">2</span>, <span class="number">4</span>); <span class="comment">// 更新为4</span></span><br><span class="line">        <span class="keyword">count</span>.compareAndSet(<span class="number">3</span>, <span class="number">5</span>); <span class="comment">// 不</span></span><br><span class="line">        log.info(<span class="string">"count:&#123;&#125;"</span>, <span class="keyword">count</span>.get());</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果为：</p><p><img src="/2018/08/02/线程安全之原子性-Atomic包-part-3/AtomicReference测试-1.png" alt="图示"></p><p>根据结果，可以看出其运行顺序跟我们预期是完全吻合的。</p><p>看一下AtomicReference的compareAndSet(a, b)方法源码：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="function"><span class="keyword">void</span> <span class="title">lazySet</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">    unsafe.putOrderedObject(<span class="keyword">this</span>, valueOffset, newValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Atomically sets the value to the given updated value</span></span><br><span class="line"><span class="comment"> * if the current value &#123;<span class="doctag">@code</span> ==&#125; the expected value.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> expect the expected value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> update the new value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if successful. False return indicates that</span></span><br><span class="line"><span class="comment"> * the actual value was not equal to the expected value.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="function"><span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(V expect, V update)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">return</span> unsafe.<span class="title">compareAndSwapObject</span><span class="params">(<span class="keyword">this</span>, valueOffset, expect, update)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>又是调用的unsafe.compareAndSwapObject(xxx)，再看一下：<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="built_in">boolean</span> compareAndSwapObject(<span class="keyword">Object</span> var1, <span class="keyword">long</span> var2, <span class="keyword">Object</span> var4, <span class="keyword">Object</span> var5);</span><br></pre></td></tr></table></figure></p><p>看来这个类真的是个典型的AtomicXXX类！</p><h4 id="AtomicReferenceFiledUpdater分析"><a href="#AtomicReferenceFiledUpdater分析" class="headerlink" title="AtomicReferenceFiledUpdater分析"></a>AtomicReferenceFiledUpdater分析</h4><p>写出一个小例子：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">@ThreadSafe</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicExample5</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//指明更新的类为AtomicExample5</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicIntegerFieldUpdater&lt;AtomicExample5&gt; updater =</span><br><span class="line">            <span class="comment">//newUpdater()的第一个参数为该指明的类的class，第二参数为作用的字段区域的名字filedName（该字段必须被volatile标识声明）</span></span><br><span class="line">            AtomicIntegerFieldUpdater.newUpdater(AtomicExample5.class, <span class="string">"count"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加get方法</span></span><br><span class="line">    @Getter</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">int</span> count = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        AtomicExample5 example5 = <span class="keyword">new</span> AtomicExample5();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (updater.compareAndSet(example5, <span class="number">100</span>, <span class="number">120</span>)) &#123;</span><br><span class="line">            <span class="built_in">log</span>.info(<span class="string">"update success 1, &#123;&#125;"</span>, example5.getCount());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (updater.compareAndSet(example5, <span class="number">100</span>, <span class="number">120</span>)) &#123;</span><br><span class="line">            <span class="built_in">log</span>.info(<span class="string">"update success 2, &#123;&#125;"</span>, example5.getCount());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">log</span>.info(<span class="string">"update failed, &#123;&#125;"</span>, example5.getCount());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其输出结果正如预期为：</p><p><img src="/2018/08/02/线程安全之原子性-Atomic包-part-3/AtomicReferenceFiledUpdater测试.png" alt="图示"></p><p><strong>AtomicReferenceFieldUpdater的核心为：原子性地去更新某一个类的实例中指定的某一个字段，而该字段必须使用volatile标识且不能被static标识进行声明。</strong></p><h4 id="手记小总结"><a href="#手记小总结" class="headerlink" title="手记小总结"></a>手记小总结</h4><p>AtomicReference与AtomicReferenceFieldUpdater都是用于原子性地修改更新，都是线程安全的。但是后者是通过指定类的实例中的某一个字段，且该字段必须使用volatile标识且非static标识进行声明。<br>这两个类实际中用到的都不是很多……</p>]]></content>
      
      <categories>
          
          <category> Java之并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>线程安全之原子性--Atomic包-Part-2</title>
      <link href="/2018/08/02/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B9%8B%E5%8E%9F%E5%AD%90%E6%80%A7-Atomic%E5%8C%85-part-2/"/>
      <url>/2018/08/02/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B9%8B%E5%8E%9F%E5%AD%90%E6%80%A7-Atomic%E5%8C%85-part-2/</url>
      <content type="html"><![CDATA[<h4 id="AtomicLong与AtomicInteger"><a href="#AtomicLong与AtomicInteger" class="headerlink" title="AtomicLong与AtomicInteger"></a>AtomicLong与AtomicInteger</h4><p>根据part-1中代码，其实使用<code>AtomicLong</code>代替<code>AtomicInteger</code>，而其他不用替换是完全可以的。同样也是线程安全的。</p><h3 id="AtomicLong与LongAdder"><a href="#AtomicLong与LongAdder" class="headerlink" title="AtomicLong与LongAdder"></a>AtomicLong与LongAdder</h3><p>但是重点是JDK 1.8中新增的<code>LongAdder</code>类，它与<code>AtomicLong</code>在上节的测试中有相同的效果（线程安全），只需稍微换成各自对应的方法即可。</p><a id="more"></a><p><strong>那两者的区别是什么？</strong></p><p>肯定的说，新增的该类一定或多或少比<code>AtomicLong</code>类及<code>AtomicInteger</code>类有优点的，那么是什么？<br>浅析如下：</p><h5 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h5><ol><li><p>由于AtomicLong的底层是CAS原理，即通过死循环不断地比较当前值与主内存的值，那么当线程并发量较少时其比较成功的概率是高的，但放并发量很大时，比较成功概率就会很低，越低则死循环持续的时间越久，占用的系统资源越大，系统运行的效率越低。</p></li><li><p>对于基础数据类型的long或double时,JVM会允许将64位的读操作或写操作拆分为两个32位的操作。同理，LongAdder也是采用相似的思想。</p><blockquote><p>LongAdder的实现思想为：<strong>热点数据分离</strong>：将AtomicLong的核心数据value分离为一个数组，每个线程访问时通过hash等算法预测到其中的一个数字进行计数，最终的计数结果为该数组各部分的求和。热点数据value会被分为多个部分的shell，每个shell独自维护各自的值，而当前对象的实际值为各部分shell的累加和。保证热点数据的有效分离，提高并行度。<strong>LongAdder类实际是在AtomicLong的基础上进行了优化：在低并发时不做分离，同AtomicLong是对base的直接CAS更新，但是高并发时将单点的压力分摊到各部分的shell上以提高性能。</strong></p></blockquote></li></ol><h5 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h5><p>该类将数据分类后，再次进行各部分shell的数据进行统计时，如果此时存在并发更新，可能会导致统计的数据出现误差。</p><p><strong>实际使用中，在处理高并发情况的时候要优先使用LongAdder类。当线程竞争低、全局唯一的准确是数值类似序列号生成等情况优先使用AtomicXXX类</strong></p><h4 id="知识拓展补充"><a href="#知识拓展补充" class="headerlink" title="知识拓展补充"></a>知识拓展补充</h4><p>下表为JAVA的8种基本数据类型所占位数及初始值:<br>基础数据类型 | 所占位数 | 初始值<br>-|-|-<br>byte字节型| 1字节(8bit) |    0<br>char字符型  | 2字节(16bit)    | 空格<br>short短整型 |  2字节(16bit)    | 0<br>int整型 |  4字节(32bit)    | 0<br>long长整型  | 8字节(64Bit)    | 0L<br>float单精度浮点型 |  4字节(32bit)    | 0.0f<br>double双精度浮点型  | 8字节(64bit) |    0.0d<br>boolean    | java未明确指出的大小(可能1bit、1byte、4byte)    | false</p>]]></content>
      
      <categories>
          
          <category> Java之并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>第一次并发模拟</title>
      <link href="/2018/08/02/%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%B9%B6%E5%8F%91%E6%A8%A1%E6%8B%9F/"/>
      <url>/2018/08/02/%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%B9%B6%E5%8F%91%E6%A8%A1%E6%8B%9F/</url>
      <content type="html"><![CDATA[<h4 id="关键源码"><a href="#关键源码" class="headerlink" title="关键源码"></a>关键源码</h4><blockquote><p>这是我的第一次并发模拟的演示例子，是使用SpringBoot搭建演示环境。虽然很简单，但是万丈高楼平地起，基础得打好~之后我会更加详实地补充高级内容！</p></blockquote><a id="more"></a><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//为输出方便，加log注解</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@NotThreadSafe</span>  <span class="comment">//该自定义注解只是标示其为非线程安全类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrencyTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//请求总数量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> clientTotal = <span class="number">5000</span>;</span><br><span class="line">    <span class="comment">//并发数量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> threadTotal = <span class="number">200</span>;</span><br><span class="line">    <span class="comment">//用来计数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//定义线程池</span></span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="comment">//定义信号量,参数为并发数量</span></span><br><span class="line">        <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(threadTotal);</span><br><span class="line">        <span class="comment">//参数为请求总数</span></span><br><span class="line">        <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(clientTotal);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clientTotal; i++) &#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                <span class="comment">//核心方法执行前后需获取/释放信号量</span></span><br><span class="line">                <span class="comment">//由于使用信号量可能会因执行中断而产生异常</span></span><br><span class="line">                <span class="comment">//只有当semaphore.acquire()执行完（根据目前的并发数判断该线程是否允许被执行，否则会被阻塞）有返回效果，线程才会执行其核心方法</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    add();</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="comment">//                    e.printStackTrace();</span></span><br><span class="line">                    log.<span class="keyword">error</span>(<span class="string">"中断异常InterruptedException:"</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//执行闭锁，进行请求总数减一</span></span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//调用countDownLatch.await()方法保证目前已经**减为零**。</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            countDownLatch.await();</span><br><span class="line">            <span class="comment">//闭锁执行完毕，关闭线程池</span></span><br><span class="line">            executorService.shutdown();</span><br><span class="line">            log.info(<span class="string">"计数count:&#123;&#125;"</span>,count);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="comment">//            e.printStackTrace();</span></span><br><span class="line">            log.<span class="keyword">error</span>(<span class="string">"计数产生中断异常InterruptedException:"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计数方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="第一次运行结果"><a href="#第一次运行结果" class="headerlink" title="第一次运行结果"></a>第一次运行结果</h5><p><img src="/2018/08/02/第一次并发模拟/第一次并发模拟-第一次结果.png" alt="图"></p><h5 id="第二次运行结果"><a href="#第二次运行结果" class="headerlink" title="第二次运行结果"></a>第二次运行结果</h5><p><img src="/2018/08/02/第一次并发模拟/第二次结果.png" alt="图"></p><h5 id="第三次运行结果"><a href="#第三次运行结果" class="headerlink" title="第三次运行结果"></a>第三次运行结果</h5><p><img src="/2018/08/02/第一次并发模拟/第三次结果.png" alt="图"></p><h5 id="根据三次结果，显然该类是非线程安全的类。所以其前面标注上之前定义的注解。"><a href="#根据三次结果，显然该类是非线程安全的类。所以其前面标注上之前定义的注解。" class="headerlink" title="根据三次结果，显然该类是非线程安全的类。所以其前面标注上之前定义的注解。"></a>根据三次结果，显然该类是非线程安全的类。所以其前面标注上之前定义的注解。</h5>]]></content>
      
      <categories>
          
          <category> Java之并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>并发模拟</title>
      <link href="/2018/08/02/%E5%B9%B6%E5%8F%91%E6%A8%A1%E6%8B%9F/"/>
      <url>/2018/08/02/%E5%B9%B6%E5%8F%91%E6%A8%A1%E6%8B%9F/</url>
      <content type="html"><![CDATA[<h4 id="并发模拟之工具"><a href="#并发模拟之工具" class="headerlink" title="并发模拟之工具"></a>并发模拟之工具</h4><h6 id="Postman：Http请求模拟工具。"><a href="#Postman：Http请求模拟工具。" class="headerlink" title="Postman：Http请求模拟工具。"></a>Postman：Http请求模拟工具。</h6><p>在接口测试中是一个十分给力的工具；但在并发模拟方面做得不够专业。</p><h6 id="Apache-Bench-AB-：Apache附带的工具，用以测试网站性能。"><a href="#Apache-Bench-AB-：Apache附带的工具，用以测试网站性能。" class="headerlink" title="Apache Bench (AB)：Apache附带的工具，用以测试网站性能。"></a>Apache Bench (AB)：Apache附带的工具，用以测试网站性能。</h6><p>AB小巧简单，上手容易，但是没有图形化界面，也无法做到实时监控。</p><h6 id="JMeter：Apache组织开发的压力测试工具。"><a href="#JMeter：Apache组织开发的压力测试工具。" class="headerlink" title="JMeter：Apache组织开发的压力测试工具。"></a>JMeter：Apache组织开发的压力测试工具。</h6><blockquote><p>下载安装并配置环境变量。</p></blockquote><a id="more"></a><p>配置总请求数量、线程上升期间(s)、循环次数：<br><img src="/2018/08/02/并发模拟/jmeter一.png" alt="实操+图示"><br>指定HTTP请求的基本信息：端口信息、请求方法、路径、编码方式等<br><img src="/2018/08/02/并发模拟/jmeter二.png" alt="实操+图示"><br>JMeter测试中数据统计：<br><img src="/2018/08/02/并发模拟/jmeter三.png" alt="实操+图示"><br>JMeter第一次测试失败，原因是连接异常（自己没启动SpringBoot，笑死我了……）<br><img src="/2018/08/02/并发模拟/jmeter四.png" alt="实操+图示"><br><strong>JMeter测试成功截图：</strong><br>jmeter结果树：<br><img src="/2018/08/02/并发模拟/jmeter结果树.png" alt="实操+图示"><br>jmeter结果树请求头：<br><img src="/2018/08/02/并发模拟/jmeter结果树请求头.png" alt="实操+图示"><br>jmeter结果树响应数据：<br><img src="/2018/08/02/并发模拟/jmeter结果树响应数据.png" alt="实操+图示"></p><hr><h4 id="并发模拟之代码"><a href="#并发模拟之代码" class="headerlink" title="并发模拟之代码"></a>并发模拟之代码</h4><h6 id="CountDownLatch类"><a href="#CountDownLatch类" class="headerlink" title="CountDownLatch类"></a>CountDownLatch类</h6><p>其原理图如下：</p><p><img src="/2018/08/02/并发模拟/CountDownLatch类.png" alt="图示+解释"></p><p>根据上图：其他线程每次执行结束即执行一次countDown()，已经执行结束任务的线程执行await()判断当前计数cnt是否为零，未至0则等待其他线程，只当计数cnt为0时该线程会被resumed去执行后续的操作。</p><p>该类可以通过计数来阻塞线程，主要用于线程执行完之后的其他处理：指定一个计数值，在并发环境下由线程进行减1操作，当计数值变为0之后，被await方法阻塞的线程将会唤醒，实现线程间的同步。<strong>通俗理解：已经执行完成的线程等待还未完成的线程，最后所有线程一同执行另外的任务。</strong></p><h6 id="Semphore类"><a href="#Semphore类" class="headerlink" title="Semphore类"></a>Semphore类</h6><p>Semphore从字面上理解就是信号量，学过《操作系统》课程的人应该知道，在操作系统调度任务时，根据其设定的Semphore值进行同时运行的线程数量的操作。<br>同理，此处的Semphore的含义也是如此。<strong>它主要是用来控制同时并发的线程数。</strong></p><blockquote><p><strong>该两个类通常会结合线程池ThreadPool进行并发的模拟。</strong></p></blockquote>]]></content>
      
      <categories>
          
          <category> Java之并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring的自定义注解</title>
      <link href="/2018/08/02/spring%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/"/>
      <url>/2018/08/02/spring%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/</url>
      <content type="html"><![CDATA[<h4 id="自定义的注解"><a href="#自定义的注解" class="headerlink" title="自定义的注解"></a>自定义的注解</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明注解需两个属性。此ThreadSafe只是一个**线程安全**的标识</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span><span class="comment">//给类做注解，其中target的其他值很多</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span><span class="comment">//只在源码中起作用：标识。其他值详述。</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ThreadSafe &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过value（）给其名字，并给出默认名称。</span></span><br><span class="line">    String value() <span class="keyword">default</span> <span class="string">""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="注解的作用范围"><a href="#注解的作用范围" class="headerlink" title="注解的作用范围"></a>注解的作用范围</h4><p><img src="/2018/08/02/spring的自定义注解/注解作用范围.png" alt="截图"></p><h5 id="Target源码"><a href="#Target源码" class="headerlink" title="@Target源码"></a>@Target源码</h5><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * The constants <span class="keyword">of</span> this enumerated <span class="keyword">type</span> <span class="type">provide </span>a simple classification <span class="keyword">of</span> the</span><br><span class="line"> * syntactic locations where annotations may appear <span class="keyword">in</span> a Java program. These</span><br><span class="line"> * constants are used <span class="keyword">in</span> &#123;@link Target java.lang.annotation.Target&#125;</span><br><span class="line"> * meta-annotations to specify where it <span class="keyword">is</span> legal to write annotations <span class="keyword">of</span> a</span><br><span class="line"> * given <span class="keyword">type</span>.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;The syntactic locations where annotations may appear are split into</span><br><span class="line"> * &lt;em&gt;declaration contexts&lt;/em&gt; , where annotations apply to declarations, <span class="keyword">and</span></span><br><span class="line"> * &lt;em&gt;<span class="keyword">type</span> <span class="type">contexts&lt;/em&gt; </span>, where annotations apply to types used <span class="keyword">in</span></span><br><span class="line"> * declarations <span class="keyword">and</span> expressions.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;The constants &#123;@link #ANNOTATION_TYPE&#125; , &#123;@link #CONSTRUCTOR&#125; , &#123;@link</span><br><span class="line"> * #FIELD&#125; , &#123;@link #LOCAL_VARIABLE&#125; , &#123;@link #METHOD&#125; , &#123;@link #<span class="keyword">PACKAGE</span>&#125; ,</span><br><span class="line"> * &#123;@link #PARAMETER&#125; , &#123;@link #<span class="keyword">TYPE</span>&#125; , <span class="keyword">and</span> &#123;@link #TYPE_PARAMETER&#125; correspond</span><br><span class="line"> * to the declaration contexts <span class="keyword">in</span> JLS <span class="number">9.6</span>.<span class="number">4.1</span>.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;<span class="keyword">For</span> example, an annotation whose <span class="keyword">type</span> <span class="type">is </span>meta-annotated <span class="keyword">with</span></span><br><span class="line"> * &#123;@code @Target(ElementType.FIELD)&#125; may only be written as a modifier <span class="keyword">for</span> a</span><br><span class="line"> * field declaration.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;The <span class="keyword">constant</span> &#123;@link #TYPE_USE&#125; corresponds to the <span class="number">15</span> <span class="keyword">type</span> <span class="type">contexts </span><span class="keyword">in</span> JLS</span><br><span class="line"> * <span class="number">4.11</span>, as well as to two declaration contexts: <span class="keyword">type</span> <span class="type">declarations </span>(including</span><br><span class="line"> * annotation <span class="keyword">type</span> <span class="type">declarations) </span><span class="keyword">and</span> <span class="keyword">type</span> <span class="type">parameter </span>declarations.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;<span class="keyword">For</span> example, an annotation whose <span class="keyword">type</span> <span class="type">is </span>meta-annotated <span class="keyword">with</span></span><br><span class="line"> * &#123;@code @Target(ElementType.TYPE_USE)&#125; may be written on the <span class="keyword">type</span> <span class="type">of </span>a field</span><br><span class="line"> * (<span class="keyword">or</span> within the <span class="keyword">type</span> <span class="type">of </span>the field, <span class="keyword">if</span> it <span class="keyword">is</span> a nested, parameterized, <span class="keyword">or</span> <span class="keyword">array</span></span><br><span class="line"> * <span class="keyword">type</span>), <span class="keyword">and</span> may also appear as a modifier <span class="keyword">for</span>, say, a class declaration.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;The &#123;@code TYPE_USE&#125; <span class="keyword">constant</span> includes <span class="keyword">type</span> <span class="type">declarations </span><span class="keyword">and</span> <span class="keyword">type</span></span><br><span class="line"> * parameter declarations as a convenience <span class="keyword">for</span> designers <span class="keyword">of</span> <span class="keyword">type</span> <span class="type">checkers </span>which</span><br><span class="line"> * give semantics to annotation types. <span class="keyword">For</span> example, <span class="keyword">if</span> the annotation <span class="keyword">type</span></span><br><span class="line"> * &#123;@code NonNull&#125; <span class="keyword">is</span> meta-annotated <span class="keyword">with</span></span><br><span class="line"> * &#123;@code @Target(ElementType.TYPE_USE)&#125;, <span class="keyword">then</span> &#123;@code @NonNull&#125;</span><br><span class="line"> * &#123;@code class C &#123;...&#125;&#125; could be treated by a <span class="keyword">type</span> <span class="type">checker </span>as indicating that</span><br><span class="line"> * <span class="keyword">all</span> variables <span class="keyword">of</span> class &#123;@code C&#125; are non-null, <span class="keyword">while</span> still allowing</span><br><span class="line"> * variables <span class="keyword">of</span> other classes to be non-null <span class="keyword">or</span> <span class="keyword">not</span> non-null based on whether</span><br><span class="line"> * &#123;@code @NonNull&#125; appears <span class="keyword">at</span> the variable<span class="symbol">'s</span> declaration.</span><br><span class="line"> *</span><br><span class="line"> * @author  Joshua Bloch</span><br><span class="line"> * @since <span class="number">1.5</span></span><br><span class="line"> * @jls <span class="number">9.6</span>.<span class="number">4.1</span> @Target</span><br><span class="line"> * @jls <span class="number">4.1</span> The Kinds <span class="keyword">of</span> Types <span class="keyword">and</span> Values</span><br><span class="line"> */</span><br><span class="line">public enum ElementType &#123;</span><br><span class="line">    /** Class, <span class="keyword">interface</span> (including annotation <span class="keyword">type</span>), <span class="keyword">or</span> enum declaration */</span><br><span class="line">    <span class="keyword">TYPE</span>,</span><br><span class="line"></span><br><span class="line">    /** Field declaration (includes enum constants) */</span><br><span class="line">    FIELD,</span><br><span class="line"></span><br><span class="line">    /** Method declaration */</span><br><span class="line">    METHOD,</span><br><span class="line"></span><br><span class="line">    /** Formal parameter declaration */</span><br><span class="line">    PARAMETER,</span><br><span class="line"></span><br><span class="line">    /** Constructor declaration */</span><br><span class="line">    CONSTRUCTOR,</span><br><span class="line"></span><br><span class="line">    /** Local variable declaration */</span><br><span class="line">    LOCAL_VARIABLE,</span><br><span class="line"></span><br><span class="line">    /** Annotation <span class="keyword">type</span> <span class="type">declaration </span>*/</span><br><span class="line">    ANNOTATION_TYPE,</span><br><span class="line"></span><br><span class="line">    /** <span class="keyword">Package</span> <span class="title">declaration */</span></span><br><span class="line">    <span class="keyword">PACKAGE</span>,</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * <span class="keyword">Type</span> <span class="type">parameter </span>declaration</span><br><span class="line">     *</span><br><span class="line">     * @since <span class="number">1.8</span></span><br><span class="line">     */</span><br><span class="line">    TYPE_PARAMETER,</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * <span class="keyword">Use</span> <span class="keyword">of</span> a <span class="keyword">type</span></span><br><span class="line">     *</span><br><span class="line">     * @since <span class="number">1.8</span></span><br><span class="line">     */</span><br><span class="line">    TYPE_USE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="解读源码："><a href="#解读源码：" class="headerlink" title="解读源码："></a><strong>解读源码：</strong></h6><h5 id="Retention源码"><a href="#Retention源码" class="headerlink" title="@Retention源码"></a>@Retention源码</h5><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Annotation retention policy.  The constants <span class="keyword">of</span> this enumerated type</span><br><span class="line"> * describe <span class="keyword">the</span> various policies <span class="keyword">for</span> retaining annotations.  They are used</span><br><span class="line"> * <span class="keyword">in</span> conjunction <span class="keyword">with</span> <span class="keyword">the</span> &#123;@link Retention&#125; meta-annotation type <span class="keyword">to</span> specify</span><br><span class="line"> * how long annotations are <span class="keyword">to</span> be retained.</span><br><span class="line"> *</span><br><span class="line"> * @author  Joshua Bloch</span><br><span class="line"> * @<span class="keyword">since</span> <span class="number">1.5</span></span><br><span class="line"> */</span><br><span class="line">public enum RetentionPolicy &#123;</span><br><span class="line">    /**</span><br><span class="line">     * Annotations are <span class="keyword">to</span> be discarded <span class="keyword">by</span> <span class="keyword">the</span> compiler.</span><br><span class="line">     */</span><br><span class="line">    SOURCE,</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Annotations are <span class="keyword">to</span> be recorded <span class="keyword">in</span> <span class="keyword">the</span> <span class="built_in">class</span> <span class="built_in">file</span> <span class="keyword">by</span> <span class="keyword">the</span> compiler</span><br><span class="line">     * <span class="keyword">but</span> need <span class="keyword">not</span> be retained <span class="keyword">by</span> <span class="keyword">the</span> VM <span class="keyword">at</span> <span class="built_in">run</span> <span class="built_in">time</span>.  This <span class="keyword">is</span> <span class="keyword">the</span> default</span><br><span class="line">     * behavior.</span><br><span class="line">     */</span><br><span class="line">    CLASS,</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Annotations are <span class="keyword">to</span> be recorded <span class="keyword">in</span> <span class="keyword">the</span> <span class="built_in">class</span> <span class="built_in">file</span> <span class="keyword">by</span> <span class="keyword">the</span> compiler <span class="keyword">and</span></span><br><span class="line">     * retained <span class="keyword">by</span> <span class="keyword">the</span> VM <span class="keyword">at</span> <span class="built_in">run</span> <span class="built_in">time</span>, so they may be <span class="built_in">read</span> reflectively.</span><br><span class="line">     *</span><br><span class="line">     * @see java.lang.reflect.AnnotatedElement</span><br><span class="line">     */</span><br><span class="line">    RUNTIME</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="解读源码：-1"><a href="#解读源码：-1" class="headerlink" title="解读源码："></a><strong>解读源码：</strong></h6><p>此处为坑，后续会补上！！！</p>]]></content>
      
      <categories>
          
          <category> Java之并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>线程安全之原子性--Atomic包-Part-1</title>
      <link href="/2018/08/02/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B9%8B%E5%8E%9F%E5%AD%90%E6%80%A7-Atomic%E5%8C%85-part-1/"/>
      <url>/2018/08/02/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B9%8B%E5%8E%9F%E5%AD%90%E6%80%A7-Atomic%E5%8C%85-part-1/</url>
      <content type="html"><![CDATA[<h4 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h4><h6 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h6><ul><li>原子性：提供了互斥访问，同一时刻只能有一个线程来对它进行操作；</li><li>可见性：一个线程对主内存的修改可以及时地被其他线程知道；</li><li>有序性：一个线程观察其他线程中的指令执行顺序，由于指令重排序的存在，该观察结果一般杂乱无序。<a id="more"></a><h4 id="使用AtomicInteger类"><a href="#使用AtomicInteger类" class="headerlink" title="使用AtomicInteger类"></a>使用AtomicInteger类</h4>之前当使用int时，根据结果知道，该操作是非线程安全的。<br>当使用AtomicInteger类时，并使用<code>count.incrementAndGet();</code>而不是<code>count++;</code>后，多次验证其结果为：</li></ul><p><img src="/2018/08/02/线程安全之原子性-Atomic包-part-1/使用AtomicInteger代替int测试.png" alt="图"></p><h5 id="为什么使用了count的incrementAndGet-方法后就变成线程安全的了呢？"><a href="#为什么使用了count的incrementAndGet-方法后就变成线程安全的了呢？" class="headerlink" title="为什么使用了count的incrementAndGet()方法后就变成线程安全的了呢？"></a>为什么使用了count的incrementAndGet()方法后就变成线程安全的了呢？</h5><p><strong>查看源码！</strong><br><code>count.incrementAndGet():</code><br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Atomically increments by one the current value.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the updated value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="function"><span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>其中使用到unsafe的getAndAddInt(xxx)方法！！</strong></p><p><em>那么这个方法是何方神圣？</em><br><strong>看看它的实现：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var5;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看出它使用do-while语句实现，其实不止getAndAddInt用到，其他的get(或set)AndAddxxx(Object)都是一样的实现方式。其中其判断的条件又用到unsafe类的compareAndSwapInt(xxx)方法，再点进去看看！！<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="function"><span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4, <span class="keyword">int</span> var5)</span></span>;</span><br></pre></td></tr></table></figure></p><p>就这一句没了……</p><h5 id="但是！！！"><a href="#但是！！！" class="headerlink" title="但是！！！"></a><strong>但是！！！</strong></h5><p>我看到方法类型中有一个字段<code>native</code>！！！<br>这说明该方法是JNI框架(Java Native Interface,Java本地接口)的方法。</p><p>再Google一下：</p><blockquote><p>在编程领域, JNI (Java Native Interface,Java本地接口)是一种编程框架,使得Java虚拟机中的Java程序可以调用本地应用/或库,也可以被其他程序调用。<strong>本地程序一般是用其它语言（C、C++或汇编语言等）编写的, 并且被编译为基于本机硬件和操作系统的程序。</strong><br>JNI框架允许Native方法调用Java对象，就像Java程序访问Native对象一样方便。Native方法可以创建Java对象，读取这些对象, 并调用Java对象执行某些方法。当然Native方法也可以读取由Java程序自身创建的对象,并调用这些对象的方法。</p></blockquote><blockquote><p>JNI在某些情况下可能带来很大的开销和性能损失:</p><ul><li>调用 JNI 方法是很笨重的操作, 特别是在多次重复调用的情况下.</li><li>Native 方法不会被 JVM 内联, 也不会被 JIT compiled 优化 , 因为方法已经被编译过了.</li><li>Java 数组可能会被拷贝一份,以传递给 native 方法, 执行完之后再拷贝回去. 其开销与数组的长度是线性相关的.</li><li>如果传递一个对象给方法,或者需要一个回调,那么 Native 方法可能会自己调用JVM。 访问Java对象的属性、方法和类型时, Native代码需要类似reflection的东西。签名由字符串指定,通从JVM中查询。这非常缓慢并且容易出错。</li><li>Java 中的字符串(String) 也是对象, 有 length 属性,并且是编码过的. 读取或者创建字符串都需要一次时间复杂度为 O(n) 的复制操作.</li></ul></blockquote><h5 id="再分析其函数的调用："><a href="#再分析其函数的调用：" class="headerlink" title="再分析其函数的调用："></a>再分析其函数的调用：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var5;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中var1为当前传入的对象即count，var2是当前count的值，var4即为incrementAndGet()方法的默认加数，为1，var5是调用的另一个JNI的方法得到底层当前的count值。<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="function"><span class="keyword">int</span> <span class="title">getIntVolatile</span><span class="params">(Object var1, <span class="keyword">long</span> var2)</span></span>;</span><br></pre></td></tr></table></figure></p><p><strong>Volatile关键字很熟悉，简述是保证了线程之间操作的对象的值互相透明、可见性。</strong><br>（Volatile关键字的详述又该是一个大文章了！过阵子再写！）<br>那么现在应该就懂了，<strong>用底层得到的值不断循环比较当前的值，如果两者相等就加一并再用JNI底层方法写入主内存。</strong><br>AtomicInteger类就是使用了该方法即<strong>CAS原理</strong>来保证线程安全的。（CAS原理也是一个大块头。。）<br>同理，AtomicXXX类（XXX是属于Java的Object，例如Long、Double等）都是该方法保证的！</p><h4 id="ConpareAndSet概述"><a href="#ConpareAndSet概述" class="headerlink" title="ConpareAndSet概述"></a>ConpareAndSet概述</h4><p>该方法和ConpareAndSwap有些相似，但还有不同：ConpareAndSet(a,b)更多的是用在AtomicBoolean类中（Boolean要求false与true的转换同一时间只能被一个线程调用，且false(true)只能转换为true(false)，其中的参数a,b即为只能相互转换的数，<strong>顺序为：当为a的时候更新为b</strong>）。</p>]]></content>
      
      <categories>
          
          <category> Java之并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>并发的优势与风险</title>
      <link href="/2018/08/02/%E5%B9%B6%E5%8F%91%E7%9A%84%E4%BC%98%E5%8A%BF%E4%B8%8E%E9%A3%8E%E9%99%A9/"/>
      <url>/2018/08/02/%E5%B9%B6%E5%8F%91%E7%9A%84%E4%BC%98%E5%8A%BF%E4%B8%8E%E9%A3%8E%E9%99%A9/</url>
      <content type="html"><![CDATA[<h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><h4 id="速度"><a href="#速度" class="headerlink" title="速度"></a>速度</h4><ul><li>系统可以处理多个请求，响应速度更快；</li><li>复杂的操作可以分割为多个进程同时进行。<a id="more"></a><h4 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h4></li><li>程序的设计更加简单；</li><li>设计有更多的选择。<h4 id="资源利用"><a href="#资源利用" class="headerlink" title="资源利用"></a>资源利用</h4>CPU在等待IO时候可以做其他的工作，提高硬件资源利用率<h3 id="风险"><a href="#风险" class="headerlink" title="风险"></a>风险</h3><h4 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h4>多个线程共享数据可能会产生与期望不相符的结果<h4 id="活跃性"><a href="#活跃性" class="headerlink" title="活跃性"></a>活跃性</h4>某个操作无法继续进行下去时，会产生活跃性问题。如死锁饥饿等。<h4 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h4>线程过多时会使：</li></ul><ol><li>CPU上下文切换频繁，调度时间增加，想能降低；</li><li>同步机制耗时增加；</li><li>内存容量剧增。</li></ol>]]></content>
      
      <categories>
          
          <category> Java之并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java内存模型</title>
      <link href="/2018/08/02/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
      <url>/2018/08/02/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
      <content type="html"><![CDATA[<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><blockquote><p>已知多核CPU对于代码指令的乱序执行存在跟我们预期结果不一致的问题，解决方法就是使用Java内存模型规范对多线程操作进行约束。<br>其中<strong>Java内存模型是为屏蔽掉不同操作系统，不同硬件设备的差异，使Java程序对于多线程的环境有相同的执行结果，而对Java虚拟机（JVM）与硬件设备交互协调的规范</strong></p></blockquote><a id="more"></a><h5 id="JMM规定一个线程在何时、如何对内存中其他线程修改后的共享变量的可见性，及如何在必须时同步访问共享变量。"><a href="#JMM规定一个线程在何时、如何对内存中其他线程修改后的共享变量的可见性，及如何在必须时同步访问共享变量。" class="headerlink" title="JMM规定一个线程在何时、如何对内存中其他线程修改后的共享变量的可见性，及如何在必须时同步访问共享变量。"></a>JMM规定一个线程在何时、如何对内存中其他线程修改后的共享变量的可见性，及如何在必须时同步访问共享变量。</h5><h4 id="Java内存模型（JMM）"><a href="#Java内存模型（JMM）" class="headerlink" title="Java内存模型（JMM）"></a>Java内存模型（JMM）</h4><p>JMM与硬件结构如下图：</p><p><img src="/2018/08/02/Java内存模型/JMM与硬件结构.png" alt=""></p><p>JMM内部抽象结构如下图：</p><p><img src="/2018/08/02/Java内存模型/JMM抽象结构.png" alt="此处JMM"></p><p>堆区（Heap）：是运行时数据区，并由GC（Garbage Collection）负责，可以在运行时动态分配内存大小，也不必通知编译器。<strong>缺点：由于运行时动态分配内存，故存取速度稍慢</strong></p><blockquote><p>静态成员变量跟随类的定义一起存放在堆中。堆中的对象可以被对该对象持有引用的线程访问，且其成员变量也可以被访问；<strong>当多个线程对同一对象的同一方法进行访问时，其实每个线程都有对该对象的数据的<em>私有拷贝</em>，而不会出现混乱</strong>。</p></blockquote><hr><p>栈区（Stack）：主要存放8种基本类型的变量和句柄，JMM要求调用栈的本地变量存放在本地线程栈中，但对象是存放在堆中；优点：存取速度快（相对于Heap），仅次于寄存器，其中的数据可以共享；缺点：其中的数据与其生存期是确定的，缺乏灵活性。</p><blockquote><p>本地变量（local variable）也可能是一个引用变量，指向一个变量的引用，此时引用变量是存放在线程栈（Thread Stack）中，但被引用变量仍然存放在堆Heap中。</p></blockquote><hr><h3 id="同步的八种操纵"><a href="#同步的八种操纵" class="headerlink" title="同步的八种操纵"></a>同步的八种操纵</h3><ul><li>lock（锁定）：作用于主内存的变量，把一个标示为一条线程独占状态；</li><li>unloc（解锁）：作用于主内存的变量，把一个处于锁定状态的变量释放；</li><li>read（读取）：作用于主内存的变量，把一个变量从主内存传输到编程的工作内存，供随后的load操作使用；</li><li>load（载入）：作用于主内存的变量，它把read操作从主内存得到的变量值放入工作内存的变量副本中；</li><li>use（使用）：作用于主内存的变量，把工作内存的一个变量值传递给执行引擎；</li><li>assign（赋值）：作用于主内存的变量，它把一个从执行引擎收到的值赋值给工作内存的变量；</li><li>store（存储）：作用于主内存的变量，将工作内存的一个变量的值传递给主内存中，供随后的write操作使用；</li><li>write（写入）：作用于主内存的变量，将store操作从内存中的一个变量值传送到主内存的变量中。</li></ul><h3 id="同步的规则"><a href="#同步的规则" class="headerlink" title="同步的规则"></a>同步的规则</h3><p>同步操作与规则如下图：</p><p><img src="/2018/08/02/Java内存模型/同步操作与规则.png" alt=""></p><ul><li>如果把一个变量从主内存中复制到工作内存，需要按顺序执行read和load操作；如果把变量从工作内存同步回主内存中，需要按顺序执行store和write操作。<strong>需要按照先后顺序，但不要求连续执行！</strong></li><li>不允许read和load、store和write操作之一单独出现。</li><li>不允许一个线程丢弃它的最近assign的操作，即变量在工作内存中改变了之后必须同步到主内存中。</li><li>不允许一个线程无原因地（没有发生过任何assign操作）把数据从工作内存同步到主内存中。</li><li>一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量。即对一个变量执行use或store操作之前，必须先执行assign或load操作。</li><li>一个变量在同一时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次；多次执行lock后，只有执行相同次数的unlock后，变量才会被解锁。即lock和unlock必须成对出现。</li><li>如果对一个变量执行lock操作，将会清空工作内存中此变量的值；在执行引擎使用这个变量前需要重新执行load或assign操作初始化变量的值。</li><li>如果一个变量事先没有被lock操作锁定，则不允许对它执行unlock操作；也不允许去unlock一个被其他线程锁定的变量。</li><li>对一个变量执行unlock操作之前，必须先把此变量同步到主内存中（执行store和write操作）。</li></ul>]]></content>
      
      <categories>
          
          <category> Java之并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CPU多级缓存——乱序执行优化</title>
      <link href="/2018/08/02/%E4%B9%B1%E5%BA%8F%E6%89%A7%E8%A1%8C%E4%BC%98%E5%8C%96/"/>
      <url>/2018/08/02/%E4%B9%B1%E5%BA%8F%E6%89%A7%E8%A1%8C%E4%BC%98%E5%8C%96/</url>
      <content type="html"><![CDATA[<h3 id="处理器为提高运算速度而做出违反源代码执行顺序的优化"><a href="#处理器为提高运算速度而做出违反源代码执行顺序的优化" class="headerlink" title="处理器为提高运算速度而做出违反源代码执行顺序的优化"></a>处理器为提高运算速度而做出违反源代码执行顺序的优化</h3><p>此方法在编译器的中间代码或四元式优化阶段及生成目标代码优化有过大量的使用，是主要的优化手段！<br><a id="more"></a></p><blockquote><p>关于乱序执行及代码优化中的原则，笔者会在编译器笔记中再次详细说明！</p></blockquote><p><strong>在单核CPU中是保证不会出现跟我们预期结果不一致的问题，但在多核CPU中，由于每个核心都有自己的缓存，而缓存又分多级缓存，导致即使的后层的代码也可能先执行，更不用说代码优化后的乱序执行了</strong></p>]]></content>
      
      <categories>
          
          <category> Java之并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CPU多级缓存——缓存一致性</title>
      <link href="/2018/08/02/cpu%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98/"/>
      <url>/2018/08/02/cpu%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98/</url>
      <content type="html"><![CDATA[<h4 id="CPU多级缓存演进"><a href="#CPU多级缓存演进" class="headerlink" title="CPU多级缓存演进"></a>CPU多级缓存演进</h4><a id="more"></a><p><img src="/2018/08/02/cpu多级缓存/CPU多级缓存.png" alt="CPU多级缓存"></p><h4 id="CPU中cache的意义"><a href="#CPU中cache的意义" class="headerlink" title="CPU中cache的意义"></a>CPU中cache的意义</h4><p>由于CPU的频率太快了，快到主存跟不上，这样在处理器时钟周期内，CPU常常需要等待主存，浪费资源。所以cache的出现，是为了缓解CPU和内存之间速度的不匹配问题(结构：cpu-&gt;cache-&gt;memory)</p><h5 id="CPU-cache的局部性："><a href="#CPU-cache的局部性：" class="headerlink" title="CPU cache的局部性："></a>CPU cache的局部性：</h5><ol><li>时间局部性：如果某个数据被访问，那么在不久的将来它很可能再次被访问；</li><li>空间局部性：如果某个数据被访问，那么与它相邻的数据很快也能被访问。<h3 id="缓存一致性-MESI"><a href="#缓存一致性-MESI" class="headerlink" title="缓存一致性(MESI)"></a>缓存一致性(MESI)</h3>保证多个CPU的cache之间缓存共享数据的一致性，其中MESI即其中的四种状态：Modified（被修改的）、Exclusive（独享的）、Shared（共享的）、Invalid（无效的）；<br>如下图所示：图中M、E、S、I分别指的是Modified、Exclusive、Shared、Invalid。</li></ol><p><img src="/2018/08/02/cpu多级缓存/MESI.png" alt="图示"></p><blockquote><ul><li>Modified（被修改的）:该值现存于缓存cache中，且由于被修改而与内存中的对应值不一致，且在未来会被写入内存；</li><li>Exclusive（独享的）：该缓存行中的数据与内存中的对应值是一致的，当系统调用到该数据时及转化为Shared（共享的）状态；</li><li>Shared（共享的）：该缓存行可能会被多个CPU调用，且与多个cache中数据一致，当被一个CPU修改时，其他缓存中的该数据转化为Invalid（无效的）即被作废；</li><li>Invalid（无效的）：可能是其他CPU修改了该缓存行；</li><li><strong>其中四个状态转换之间的操作为：local read、local write、remote read、remote write。其中local指的是本地缓存，remote指的是主内存</strong></li></ul></blockquote><h4 id="在典型的多核系统中，每个核都有属于自己的缓存来共享内存总线bus，每个相应的CPU会发出自己的读写请求；而缓存的目的是为了减少各CPU读写共享内存的次数。上图中：除了Invalid（无效的）状态不可本地读，其他均可满足CPU的读请求；一个写请求只有在该缓存行处于Modified（被修改的）、Exclusive（独享的）状态时才可以被执行（local-write或remote-write）；若当前状态为Shared（共享的），且被remote-write修改，则CPU须将其转化为Invalid（无效的），通过广播方式完成，此时及不允许CPU修改同一缓存行（即使修改该缓存行的不同位置的数据也是不允许）；处于Modified（被修改的）的缓存行须时刻监听试图读该缓存行（相对于内存）的操作，该操作必须将该缓存行写入内存，并将在其状态变为Shared（共享的）之前被延迟执行；一个处于Shared（共享的）状态的缓存行需要监听其他缓存使该缓存行无效或独享该缓存行的请求，若有则将转化为Invalid（无效的）状态；处于Exclusive（独享的）状态的缓存行须监听其他缓存的读缓存操作，一旦有关于该缓存行的操作，它须转化为Shared（共享的）状态；因此对于Modified（被修改的）、Exclusive（独享的）状态，其数据总是精确的，他们和缓存行的真正状态是一致的，而Shared（共享的）状态可能是非一致的；如果一个缓存将处于Shared（共享的）状态的缓存行作废，另外的缓存可能以及读取了该缓存行，但是该缓存却不会讲其升级为Exclusive（独享的）状态，是因为：其他缓存不会广播该缓存行作废的通知，同样，由于缓存并不保存该缓存行的copy的数量，因此也无法确定自己是否已经对该缓存行处于Exclusive（独享的）状态。"><a href="#在典型的多核系统中，每个核都有属于自己的缓存来共享内存总线bus，每个相应的CPU会发出自己的读写请求；而缓存的目的是为了减少各CPU读写共享内存的次数。上图中：除了Invalid（无效的）状态不可本地读，其他均可满足CPU的读请求；一个写请求只有在该缓存行处于Modified（被修改的）、Exclusive（独享的）状态时才可以被执行（local-write或remote-write）；若当前状态为Shared（共享的），且被remote-write修改，则CPU须将其转化为Invalid（无效的），通过广播方式完成，此时及不允许CPU修改同一缓存行（即使修改该缓存行的不同位置的数据也是不允许）；处于Modified（被修改的）的缓存行须时刻监听试图读该缓存行（相对于内存）的操作，该操作必须将该缓存行写入内存，并将在其状态变为Shared（共享的）之前被延迟执行；一个处于Shared（共享的）状态的缓存行需要监听其他缓存使该缓存行无效或独享该缓存行的请求，若有则将转化为Invalid（无效的）状态；处于Exclusive（独享的）状态的缓存行须监听其他缓存的读缓存操作，一旦有关于该缓存行的操作，它须转化为Shared（共享的）状态；因此对于Modified（被修改的）、Exclusive（独享的）状态，其数据总是精确的，他们和缓存行的真正状态是一致的，而Shared（共享的）状态可能是非一致的；如果一个缓存将处于Shared（共享的）状态的缓存行作废，另外的缓存可能以及读取了该缓存行，但是该缓存却不会讲其升级为Exclusive（独享的）状态，是因为：其他缓存不会广播该缓存行作废的通知，同样，由于缓存并不保存该缓存行的copy的数量，因此也无法确定自己是否已经对该缓存行处于Exclusive（独享的）状态。" class="headerlink" title="在典型的多核系统中，每个核都有属于自己的缓存来共享内存总线bus，每个相应的CPU会发出自己的读写请求；而缓存的目的是为了减少各CPU读写共享内存的次数。上图中：除了Invalid（无效的）状态不可本地读，其他均可满足CPU的读请求；一个写请求只有在该缓存行处于Modified（被修改的）、Exclusive（独享的）状态时才可以被执行（local write或remote write）；若当前状态为Shared（共享的），且被remote write修改，则CPU须将其转化为Invalid（无效的），通过广播方式完成，此时及不允许CPU修改同一缓存行（即使修改该缓存行的不同位置的数据也是不允许）；处于Modified（被修改的）的缓存行须时刻监听试图读该缓存行（相对于内存）的操作，该操作必须将该缓存行写入内存，并将在其状态变为Shared（共享的）之前被延迟执行；一个处于Shared（共享的）状态的缓存行需要监听其他缓存使该缓存行无效或独享该缓存行的请求，若有则将转化为Invalid（无效的）状态；处于Exclusive（独享的）状态的缓存行须监听其他缓存的读缓存操作，一旦有关于该缓存行的操作，它须转化为Shared（共享的）状态；因此对于Modified（被修改的）、Exclusive（独享的）状态，其数据总是精确的，他们和缓存行的真正状态是一致的，而Shared（共享的）状态可能是非一致的；如果一个缓存将处于Shared（共享的）状态的缓存行作废，另外的缓存可能以及读取了该缓存行，但是该缓存却不会讲其升级为Exclusive（独享的）状态，是因为：其他缓存不会广播该缓存行作废的通知，同样，由于缓存并不保存该缓存行的copy的数量，因此也无法确定自己是否已经对该缓存行处于Exclusive（独享的）状态。"></a><strong>在典型的多核系统中，每个核都有属于自己的缓存来共享内存总线bus，每个相应的CPU会发出自己的读写请求；而缓存的目的是为了减少各CPU读写共享内存的次数。上图中：除了Invalid（无效的）状态不可本地读，其他均可满足CPU的读请求；一个写请求只有在该缓存行处于Modified（被修改的）、Exclusive（独享的）状态时才可以被执行（local write或remote write）；若当前状态为Shared（共享的），且被remote write修改，则CPU须将其转化为Invalid（无效的），通过广播方式完成，此时及不允许CPU修改同一缓存行（即使修改该缓存行的不同位置的数据也是不允许）；处于Modified（被修改的）的缓存行须时刻监听试图读该缓存行（相对于内存）的操作，该操作必须将该缓存行写入内存，并将在其状态变为Shared（共享的）之前被延迟执行；一个处于Shared（共享的）状态的缓存行需要监听其他缓存使该缓存行无效或独享该缓存行的请求，若有则将转化为Invalid（无效的）状态；处于Exclusive（独享的）状态的缓存行须监听其他缓存的读缓存操作，一旦有关于该缓存行的操作，它须转化为Shared（共享的）状态；因此对于Modified（被修改的）、Exclusive（独享的）状态，其数据总是精确的，他们和缓存行的真正状态是一致的，而Shared（共享的）状态可能是非一致的；如果一个缓存将处于Shared（共享的）状态的缓存行作废，另外的缓存可能以及读取了该缓存行，但是该缓存却不会讲其升级为Exclusive（独享的）状态，是因为：其他缓存不会广播该缓存行作废的通知，同样，由于缓存并不保存该缓存行的copy的数量，因此也无法确定自己是否已经对该缓存行处于Exclusive（独享的）状态。</strong></h4><blockquote><p>由上来看：Exclusive（独享的）状态更像是一中投机性优化，因为若一个CPU想修改处于Shared（共享的）状态的缓存行，须调用总线bus事务将所有该缓存行的copy值转化为Invalid（无效的）状态；而修改处于Exclusive（独享的）状态的缓存行则不需使用总线事务</p></blockquote>]]></content>
      
      <categories>
          
          <category> Java之并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>并发编程与高并发解决方案概论</title>
      <link href="/2018/08/02/%E6%A6%82%E8%AE%BA%E5%A4%A7%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/08/02/%E6%A6%82%E8%AE%BA%E5%A4%A7%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h3 id="覆盖知识点"><a href="#覆盖知识点" class="headerlink" title="覆盖知识点"></a>覆盖知识点</h3><h4 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h4><h4 id="线程封闭"><a href="#线程封闭" class="headerlink" title="线程封闭"></a>线程封闭</h4><a id="more"></a><h4 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h4><h4 id="同步容器"><a href="#同步容器" class="headerlink" title="同步容器"></a>同步容器</h4><h4 id="并发容器"><a href="#并发容器" class="headerlink" title="并发容器"></a>并发容器</h4><h4 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h4><h4 id="J-U-C"><a href="#J-U-C" class="headerlink" title="J.U.C"></a>J.U.C</h4><h4 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h4><h3 id="高并发解决思路与方法"><a href="#高并发解决思路与方法" class="headerlink" title="高并发解决思路与方法"></a>高并发解决思路与方法</h3><h4 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h4><h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><h4 id="拆分"><a href="#拆分" class="headerlink" title="拆分"></a>拆分</h4><h4 id="服务降级与熔断"><a href="#服务降级与熔断" class="headerlink" title="服务降级与熔断"></a>服务降级与熔断</h4><h4 id="数据库切库"><a href="#数据库切库" class="headerlink" title="数据库切库"></a>数据库切库</h4><h4 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h4><h4 id="杂项-1"><a href="#杂项-1" class="headerlink" title="杂项"></a>杂项</h4><h3 id="总体架构"><a href="#总体架构" class="headerlink" title="总体架构"></a>总体架构</h3><ul><li>Spring Boot</li><li>Maven</li><li>JDK 8</li><li>MySQL<h3 id="基础组件"><a href="#基础组件" class="headerlink" title="基础组件"></a>基础组件</h3></li><li>Mybatis</li><li>Guava</li><li>Lombok</li><li>Redis</li><li>Kafka<h3 id="高级组件"><a href="#高级组件" class="headerlink" title="高级组件"></a>高级组件</h3></li><li>Joda-Time</li><li>Atomic包</li><li>J.U.C(java.util.concurrent)</li><li>AQS</li><li>ThreadLocal</li><li>RateLimiter</li><li>Hystrix</li><li>threadPool</li><li>shardbatis</li><li>curator</li><li>elastic-job</li><li>…</li></ul>]]></content>
      
      <categories>
          
          <category> Java之并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>（基于Java）编写编译器和解释器-第二章：初始框架-Part-1</title>
      <link href="/2018/07/18/%E7%BC%96%E8%AF%91%E5%99%A8%E7%AC%AC%E4%BA%8C%E7%AB%A0Part1/"/>
      <url>/2018/07/18/%E7%BC%96%E8%AF%91%E5%99%A8%E7%AC%AC%E4%BA%8C%E7%AB%A0Part1/</url>
      <content type="html"><![CDATA[<blockquote><p>本章将会从前一章的概念设计带你到初级的实现过程。你将先为编译器和解释器构造一个灵活的框架，接着将初级版的编译器解释器组件集成到框架中。最后编写端对端的测试用例检验这些框架和组件。<br><a id="more"></a></p></blockquote><h2 id="目标和方法"><a href="#目标和方法" class="headerlink" title="目标和方法"></a>目标和方法</h2><p>此章的设计方法首先会让你觉得过于繁琐啰嗦，的确，本章结束后将会有一大堆超过你预期数量的代码。但请记你在用早被证明的软件工程法则和优秀面向对象设计构建编译器和解释器。</p><p>如在概念设计中描述的那样，编译器和解释器将尽可能复用组件，因只有后端有所不同。在这章中，你将构建一个灵活的框架并首先放置那些已被深度简化的编译器和解释器组件。不过它们足够验证你设计的框架是否恰当即组件能很好的耦合并能协同工作。这个成功前提将会使得从公用前端到编译器解释器后端的端对端执行代码编写，还有后续的增量式组件开发变得简单。</p><p>本章的目标是：</p><ul><li>一个语言无关的框架，可支持编译器和解释器。</li><li>集成进框架前端(<strong>front end</strong>)的初级版Pascal语言相关组件。</li><li>集成进框架后端(<strong>back end</strong>)的初级版编译器和解释器组件。</li><li>通过从公共前端生成源程序清单以及从编译器或解释器后端生成消息，简单的运行端对端测试，测试相关组件。</li></ul><blockquote><p><strong>设计笔记</strong>：<br>不管任何时候开发负责程序如编译器或解释器，成功的首要步骤是：</p><ul><li>设计和实现一个合适的框架。</li><li>开发能与框架良好集成的初级组件，且这些组件也能良好集成在一起。</li><li>通过运行简单端对端代码来测试框架和组件的融合程度。</li></ul><p>早期的组件集成是关键，甚至你已经简化了初级组件<code>(没有完善的组件称之为初级组件）</code>也一样。尽可能早的测试矿建和组件以让它们更好的协作。框架和初级组件组成你后续开发的基础。开发将是增量式的进行，代码在每次增量后都能继续工作<code>（附加更多功能）</code>。你该永远基于可运行的代码去构建。</p></blockquote><h2 id="语言无关的框架组件"><a href="#语言无关的框架组件" class="headerlink" title="语言无关的框架组件"></a>语言无关的框架组件</h2><p>基于概念设计，框架包含三个包：frontend、intermediate、 backend。</p><p>框架组件是用来定义框架且语言无关的接口和类。有些是抽象类。一旦框架组件就绪，你能开发抽象类的Pascal实现<code>（组件语言无关，实现语言相关）</code>。图2-1 展示了使用UML 包和类图的框架组件。<br>下图在frontend，intermediate，backend包中的语言无关组件一起定义了一个能支持编译器和解释器后续开发的框架。</p><p><img src="/2018/07/18/编译器第二章Part1/2-1.png" alt="图2-1"></p><blockquote><p><strong>设计笔记</strong>：统一建模语言是一个工业级的展示面向对象软件架构和过程的图形化语言。各种图表(序列图，类图等）能表示程序的结构组件之间的静态关系，也能表示组件运行期的动态行为。</p></blockquote><h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h2><p>在前端包中，语言无关类Paser，Scanner，Token，Source代表框架组件。框架类强制你在忽略具体源语言的情况下，能尽力思考每个前端组件的职责，还有它们之间的交互。图2-2中的UML 类图展示了它们的关系。</p><p><img src="/2018/07/18/编译器第二章Part1/2-2.png" alt="图2-2"></p><p>Parser和Scanner是抽象类；语言相关的子类将实现它们的抽象方法。parser和scanner联系紧密，Parser有一个受保护域(<strong>protected field</strong>)scanner指向Scanner。Parser从Scanner请求token，所以它依赖Token。Scanner有一个私有域currentToken，它通过受保护域source引用Source，还将source引用传给每个自己构造的token。每个Token也能通过受保护域source拥有Source引用，在它的构造过程中，通过source读取字符。<br>下面的类图更进一步展示了四个前端框架类。它展示了域，方法和其他的前端类和接口。例如每个Token有一个用TokenType类表示的token类型，EofToken是Token的子类。</p><p><img src="/2018/07/18/编译器第二章Part1/2-3.png" alt="图2-3"></p><p>按照概念设计，parser控制翻译过程，它翻译源程序，所以Parser类有一个抽象方法parser()；语言相关的方法实现将不断的找scanner索取下一个token。Parser的currentToken()和nextToken()仅仅是scanner的代理方法而已<code>(参考代理模式，不过这儿是为了少写点代码）</code>。语言相关的getErrorCount()方法实现返回语法错误数量。</p><blockquote><p><strong>设计笔记</strong>：在UML类图中，一个未填充箭头的箭号表示一个类引用或依赖另一个类。虚线箭号<code>(比如从Parser到Token的肩头)</code>表示一个仅仅在方法调用期间<code>(比如Parser的nextToken()方法返回一个Token对象）</code>存在的引用。实线箭号且在出发端有一个空菱形意味着一个类通过在对象生命周期持续的引用，拥有(<strong>owns</strong>)或聚合(<strong>aggregates</strong>)另一个类。<code>(假设类A通过引用域ref聚合类B，那么类A的对象a1聚合类B的对象b1的这种关系在a1的生命周期一直存在，聚合相当于包含，a1负责b1的生命周期)</code>。 域名称保存标识箭头的引用<code>（例如，Parser类用它的scanner域维护对Scanner类的引用)</code>。<br>实心箭号带空箭头（如EofToken类到Token类)表示一个子类到它的父类。<br>类名称下，一个类图可选择的包含域(field)描述区域和方法描述区域。标识箭号名称的域名不在域描述区域出现(Parser有个域scanner引用类Scanner，它不在Parser的域描述区域出现，在生成代码后就会有）。在域名或者方法名前面的字符表明访问控制。</p><ul><li>+：public 公共</li><li>-：private 私有</li><li>#：protected 受保护</li><li>~：package 包权限，即此包中的其它类都可以访问。<br>跟在域名或方法名冒号后面的分别是域类型或者返回值类型。为省地方，类图通常不显示构造函数和域名的getter和setter方法。<br>抽象类名以斜体出现。抽象方法名还是斜体。</li></ul></blockquote><p>scanner从源程序中抽取token。Scanner类抽象方法extractToken()的语言相关实现将会根据具体语言从Source中读取字符，以便构造Token。Scanner的快捷方法currentChar()和nextChar()会调用Source类中的对应方法<code>(还是代理模式)</code></p><p>Token的域保存有关Token的有用信息，包括类型，文本串<code>（即字面上的字符串）</code>，值和它在源程序中的位置<code>（行号和位置【相对于行】)</code>。Token同样有Source类的快捷方法currentChar()和nextChar()。Token类型与具体语言有关。当前的Token类型是一个占位符<code>(因为一个具体类型都没有)</code>。</p><p>后面你将会根据具体语言创建语言相关的Token子类。但目前只有语言无关EofToken子类，它表示源文件终止。使用Token子类使得scanner代码更加模块化，因为不同类型Token需要不同计算方式。<code>（原文是算法，我认为谈不上算法）</code>。</p><h2 id="Parser"><a href="#Parser" class="headerlink" title="Parser"></a>Parser</h2><p>清单2-1 展示了框架抽象类Parser的关键方法。语言相关的Parser子类要实现parse()方法和getErrorCount()，分别用来表示源程序分析过程和返回语法错误。如上文提到的，Parser的currentToken()和nextToken()方法是scanner对应方法的代理。<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>: <span class="comment">/**</span></span><br><span class="line"><span class="comment"> 2:  * &lt;p&gt;语言无关的Parser，有子类完成具体语言解析&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> 3:  */</span></span><br><span class="line"> <span class="number">4</span>: <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> Parser <span class="keyword">implements</span> MessageProducer</span><br><span class="line"> <span class="number">5</span>: &#123;</span><br><span class="line"> <span class="number">6</span>:     <span class="keyword">protected</span> <span class="keyword">static</span> SymTab symTab = <span class="keyword">null</span>;                  <span class="comment">// 生成的符号表</span></span><br><span class="line"> <span class="number">7</span>:</span><br><span class="line"> <span class="number">8</span>:     <span class="keyword">protected</span> <span class="keyword">final</span> Scanner scanner;  <span class="comment">// 扫描器SCANNER，Parser找它要token</span></span><br><span class="line"> <span class="number">9</span>:     <span class="keyword">protected</span> ICode iCode;      <span class="comment">// 语法树根节点。</span></span><br><span class="line"><span class="number">10</span>:</span><br><span class="line"><span class="number">11</span>:     <span class="keyword">protected</span> Parser(Scanner scanner)</span><br><span class="line"><span class="number">12</span>:     &#123;</span><br><span class="line"><span class="number">13</span>:         <span class="keyword">this</span>.scanner = scanner;</span><br><span class="line"><span class="number">14</span>:         <span class="keyword">this</span>.iCode = <span class="keyword">null</span>;</span><br><span class="line"><span class="number">15</span>:     &#125;</span><br><span class="line"><span class="number">16</span>:     <span class="comment">/**</span></span><br><span class="line"><span class="comment">17:      * 交由子类完成具体语言相关的解析过程，这个方法调用之后将会产生符号表和中间码iCode。</span></span><br><span class="line"><span class="comment">18:      * @throws Exception</span></span><br><span class="line"><span class="comment">19:      */</span></span><br><span class="line"><span class="number">20</span>:     <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> parse()</span><br><span class="line"><span class="number">21</span>:         <span class="keyword">throws</span> Exception;</span><br><span class="line"><span class="number">22</span>:     <span class="comment">/**</span></span><br><span class="line"><span class="comment">23:      * @return 解析过程中的错误数</span></span><br><span class="line"><span class="comment">24:      */</span></span><br><span class="line"><span class="number">25</span>:     <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> getErrorCount();</span><br><span class="line"><span class="number">26</span>:</span><br><span class="line"><span class="number">27</span>:     <span class="keyword">public</span> Token currentToken()</span><br><span class="line"><span class="number">28</span>:     &#123;</span><br><span class="line"><span class="number">29</span>:         <span class="keyword">return</span> scanner.currentToken();</span><br><span class="line"><span class="number">30</span>:     &#125;</span><br><span class="line"><span class="number">31</span>:</span><br><span class="line"><span class="number">32</span>:     <span class="keyword">public</span> Token nextToken()</span><br><span class="line"><span class="number">33</span>:         <span class="keyword">throws</span> Exception</span><br><span class="line"><span class="number">34</span>:     &#123;</span><br><span class="line"><span class="number">35</span>:         <span class="keyword">return</span> scanner.nextToken();</span><br><span class="line"><span class="number">36</span>:     &#125;</span><br><span class="line"><span class="number">37</span>:     <span class="comment">//.....</span></span><br><span class="line"><span class="number">38</span>: &#125;</span><br></pre></td></tr></table></figure></p><p>因为前端只会产生一个符号表SymTab，所以符号表在Parser中以symTab域出现。</p><h4 id="Source类"><a href="#Source类" class="headerlink" title="Source类"></a>Source类</h4><p>清单2-2 展示了框架类Source的关键方法。<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">1</span>: <span class="comment">/**</span></span><br><span class="line"><span class="comment">  2:  * &lt;p&gt;此框架类的每个对象代表一个源文件&lt;/p&gt;</span></span><br><span class="line"><span class="comment">  3:  */</span></span><br><span class="line">  <span class="number">4</span>: <span class="keyword">public</span> class Source implements MessageProducer</span><br><span class="line">  <span class="number">5</span>: &#123;</span><br><span class="line">  <span class="number">6</span>:     <span class="comment">// 行结束符，注意在Windows平台上，默认行结束符是\r\n，</span></span><br><span class="line">  <span class="number">7</span>:     <span class="comment">//如果用记事本之类的写的pascal源程序，可以使用Ultraedit之类的给转成Unix格式的。</span></span><br><span class="line">  <span class="number">8</span>:     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">char</span> EOL = <span class="string">'\n'</span>;</span><br><span class="line">  <span class="number">9</span>:     <span class="comment">//文件结束标识</span></span><br><span class="line"> <span class="number">10</span>:     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">char</span> EOF = (<span class="built_in">char</span>) <span class="number">0</span>;</span><br><span class="line"> <span class="number">11</span>:     <span class="comment">//源程序reader</span></span><br><span class="line"> <span class="number">12</span>:     <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">BufferedReader</span> reader;</span><br><span class="line"> <span class="number">13</span>:     <span class="keyword">private</span> <span class="keyword">String</span> <span class="built_in">line</span>;</span><br><span class="line"> <span class="number">14</span>:     <span class="keyword">private</span> <span class="built_in">int</span> lineNum;</span><br><span class="line"> <span class="number">15</span>:     <span class="keyword">private</span> <span class="built_in">int</span> currentPos;                   <span class="comment">// 当前行相对位置，不是整个文件的offset！！</span></span><br><span class="line"> <span class="number">16</span>:     <span class="keyword">public</span> Source(<span class="keyword">BufferedReader</span> reader)</span><br><span class="line"> <span class="number">17</span>:         <span class="keyword">throws</span> IOException</span><br><span class="line"> <span class="number">18</span>:     &#123;</span><br><span class="line"> <span class="number">19</span>:         <span class="keyword">this</span>.lineNum = <span class="number">0</span>;</span><br><span class="line"> <span class="number">20</span>:         <span class="keyword">this</span>.currentPos = <span class="number">-2</span>;  <span class="comment">// 设置为-2表示文件一行都没有读，后面的判断可以根据是否等于-2读文件第一行。</span></span><br><span class="line"> <span class="number">21</span>:         <span class="keyword">this</span>.reader = reader;</span><br><span class="line"> <span class="number">22</span>:         <span class="keyword">this</span>.messageHandler = <span class="keyword">new</span> MessageHandler();</span><br><span class="line"> <span class="number">23</span>:     &#125;</span><br><span class="line"> <span class="number">24</span>:</span><br><span class="line"> <span class="number">25</span>:     <span class="comment">/**</span></span><br><span class="line"><span class="comment"> 26:      * @return 要去读的字符</span></span><br><span class="line"><span class="comment"> 27:      * @throws Exception(read过程中的异常)</span></span><br><span class="line"><span class="comment"> 28:      */</span></span><br><span class="line"> <span class="number">29</span>:     <span class="keyword">public</span> <span class="built_in">char</span> currentChar()</span><br><span class="line"> <span class="number">30</span>:         <span class="keyword">throws</span> Exception</span><br><span class="line"> <span class="number">31</span>:     &#123;</span><br><span class="line"> <span class="number">32</span>:         <span class="comment">// 第一次读?</span></span><br><span class="line"> <span class="number">33</span>:         <span class="keyword">if</span> (currentPos == <span class="number">-2</span>) &#123;</span><br><span class="line"> <span class="number">34</span>:             readLine();</span><br><span class="line"> <span class="number">35</span>:             <span class="keyword">return</span> nextChar();</span><br><span class="line"> <span class="number">36</span>:         &#125;</span><br><span class="line"> <span class="number">37</span>:</span><br><span class="line"> <span class="number">38</span>:         <span class="comment">// 文件结束?</span></span><br><span class="line"> <span class="number">39</span>:         <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">line</span> == <span class="keyword">null</span>) &#123;</span><br><span class="line"> <span class="number">40</span>:             <span class="keyword">return</span> EOF;</span><br><span class="line"> <span class="number">41</span>:         &#125;</span><br><span class="line"> <span class="number">42</span>:</span><br><span class="line"> <span class="number">43</span>:         <span class="comment">// 行结束?</span></span><br><span class="line"> <span class="number">44</span>:         <span class="keyword">else</span> <span class="keyword">if</span> ((currentPos == <span class="number">-1</span>) || (currentPos == <span class="built_in">line</span>.length())) &#123;</span><br><span class="line"> <span class="number">45</span>:             <span class="keyword">return</span> EOL;</span><br><span class="line"> <span class="number">46</span>:         &#125;</span><br><span class="line"> <span class="number">47</span>:</span><br><span class="line"> <span class="number">48</span>:         <span class="comment">// 超过一行，换一行再读</span></span><br><span class="line"> <span class="number">49</span>:         <span class="keyword">else</span> <span class="keyword">if</span> (currentPos &gt; <span class="built_in">line</span>.length()) &#123;</span><br><span class="line"> <span class="number">50</span>:             readLine();</span><br><span class="line"> <span class="number">51</span>:             <span class="keyword">return</span> nextChar();</span><br><span class="line"> <span class="number">52</span>:         &#125;</span><br><span class="line"> <span class="number">53</span>:</span><br><span class="line"> <span class="number">54</span>:         <span class="comment">// 正常读取当前行的某一列的字符</span></span><br><span class="line"> <span class="number">55</span>:         <span class="keyword">else</span> &#123;</span><br><span class="line"> <span class="number">56</span>:             <span class="keyword">return</span> <span class="built_in">line</span>.charAt(currentPos);</span><br><span class="line"> <span class="number">57</span>:         &#125;</span><br><span class="line"> <span class="number">58</span>:     &#125;</span><br><span class="line"> <span class="number">59</span>:</span><br><span class="line"> <span class="number">60</span>:     <span class="comment">/**</span></span><br><span class="line"><span class="comment"> 61:      *位置游标前进一步并返回对应的字符，记住source的位置游标&lt;b&gt;从来不后退，只有向前操作。&lt;/b&gt;</span></span><br><span class="line"><span class="comment"> 62:      * @return 下一个要读取的字符</span></span><br><span class="line"><span class="comment"> 63:      * @throws Exception</span></span><br><span class="line"><span class="comment"> 64:      */</span></span><br><span class="line"> <span class="number">65</span>:     <span class="keyword">public</span> <span class="built_in">char</span> nextChar()</span><br><span class="line"> <span class="number">66</span>:         <span class="keyword">throws</span> Exception</span><br><span class="line"> <span class="number">67</span>:     &#123;</span><br><span class="line"> <span class="number">68</span>:         ++currentPos;</span><br><span class="line"> <span class="number">69</span>:         <span class="keyword">return</span> currentChar();</span><br><span class="line"> <span class="number">70</span>:     &#125;</span><br><span class="line"> <span class="number">71</span>:</span><br><span class="line"> <span class="number">72</span>:     <span class="comment">/**</span></span><br><span class="line"><span class="comment"> 73:      * 探测下一字符，位置游标不增加，跟Stack（栈）的Peek方法一样效果。</span></span><br><span class="line"><span class="comment"> 74:      * @return 当前位置的字符</span></span><br><span class="line"><span class="comment"> 75:      * @throws Exception</span></span><br><span class="line"><span class="comment"> 76:      */</span></span><br><span class="line"> <span class="number">77</span>:     <span class="keyword">public</span> <span class="built_in">char</span> peekChar()</span><br><span class="line"> <span class="number">78</span>:         <span class="keyword">throws</span> Exception</span><br><span class="line"> <span class="number">79</span>:     &#123;</span><br><span class="line"> <span class="number">80</span>:         currentChar();</span><br><span class="line"> <span class="number">81</span>:         <span class="keyword">if</span> (<span class="built_in">line</span> == <span class="keyword">null</span>) &#123;</span><br><span class="line"> <span class="number">82</span>:             <span class="keyword">return</span> EOF;</span><br><span class="line"> <span class="number">83</span>:         &#125;</span><br><span class="line"> <span class="number">84</span>:</span><br><span class="line"> <span class="number">85</span>:         <span class="built_in">int</span> nextPos = currentPos + <span class="number">1</span>;</span><br><span class="line"> <span class="number">86</span>:         <span class="keyword">return</span> nextPos &lt; <span class="built_in">line</span>.length() ? <span class="built_in">line</span>.charAt(nextPos) : EOL;</span><br><span class="line"> <span class="number">87</span>:     &#125;</span><br><span class="line"> <span class="number">88</span>:     <span class="comment">/**</span></span><br><span class="line"><span class="comment"> 89:      * 读入一行</span></span><br><span class="line"><span class="comment"> 90:      * @throws IOException</span></span><br><span class="line"><span class="comment"> 91:      */</span></span><br><span class="line"> <span class="number">92</span>:     <span class="keyword">private</span> <span class="keyword">void</span> readLine()</span><br><span class="line"> <span class="number">93</span>:         <span class="keyword">throws</span> IOException</span><br><span class="line"> <span class="number">94</span>:     &#123;</span><br><span class="line"> <span class="number">95</span>:         <span class="built_in">line</span> = reader.readLine();</span><br><span class="line"> <span class="number">96</span>:         currentPos = <span class="number">-1</span>;</span><br><span class="line"> <span class="number">97</span>:         <span class="comment">//如果读成功，行数+1</span></span><br><span class="line"> <span class="number">98</span>:         <span class="keyword">if</span> (<span class="built_in">line</span> != <span class="keyword">null</span>) &#123;</span><br><span class="line"> <span class="number">99</span>:             ++lineNum;</span><br><span class="line"><span class="number">100</span>:         &#125;</span><br><span class="line"><span class="number">101</span>:         <span class="comment">//每成功读入一行，将当前行数和当前行文本内容以消息方式广播，方便监听器处理。</span></span><br><span class="line"><span class="number">102</span>:         <span class="keyword">if</span> (<span class="built_in">line</span> != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="number">103</span>:             sendMessage(<span class="keyword">new</span> Message(SOURCE_LINE,</span><br><span class="line"><span class="number">104</span>:                                     <span class="keyword">new</span> <span class="keyword">Object</span>[] &#123;lineNum, <span class="built_in">line</span>&#125;));</span><br><span class="line"><span class="number">105</span>:         &#125;</span><br><span class="line"><span class="number">106</span>:     &#125;</span><br><span class="line"><span class="number">107</span>:     <span class="keyword">public</span> <span class="keyword">void</span> close()</span><br><span class="line"><span class="number">108</span>:         <span class="keyword">throws</span> Exception</span><br><span class="line"><span class="number">109</span>:     &#123;</span><br><span class="line"><span class="number">110</span>:         <span class="keyword">if</span> (reader != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="number">111</span>:             <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="number">112</span>:                 reader.close();</span><br><span class="line"><span class="number">113</span>:             &#125;</span><br><span class="line"><span class="number">114</span>:             <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line"><span class="number">115</span>:                 ex.printStackTrace();</span><br><span class="line"><span class="number">116</span>:                 <span class="keyword">throw</span> ex;</span><br><span class="line"><span class="number">117</span>:             &#125;</span><br><span class="line"><span class="number">118</span>:         &#125;</span><br><span class="line"><span class="number">119</span>:     &#125;</span><br><span class="line"><span class="number">120</span>:     <span class="comment">//more ignored</span></span><br><span class="line"><span class="number">121</span>: &#125;</span><br></pre></td></tr></table></figure></p><p>构造函数的参数是一个给Source使用的BufferdReader<code>（I/O类用来按字符读取源程序文件）</code>。你将会看到通过源文件创建BufferedReader是件很Easy的事情。你也可通过其它对象如路径串创建BufferedReader。BufferedReader是一个抽象类。你肯定不想Source类操心到底源程序文本内容怎么来的<code>（找bufferedReader即可)</code>。</p><p>方法currentChar()干了大部分事情，先前的调用会让它会调用readLine()方法读取第一行，则currentChar()返回这行的第一个字符。在后续的调用中，如果当前位置在行尾，它返回特别的EOL字符；如果已经超过行尾，currentChar再次readLine()返回下一行的第一个字符。如果读到文件末尾，line会是null值，那currentChar()返回一个特殊的EOF字符。其它情况下，此方法currentChar()简单的返回当在当前行currentPos位置的字符。</p><p>方法nextChar()将当前行的currentPos位置前进一步，接着调用chrrentChar()去返回下一个字符。<code>(注意位置指针前移了)</code></p><p>假设源文件当前行包含ABCDE五个字符且currentPos是0。那么按如下顺序调用currentChar()和nextChar()，每次调用返回字符如下标：<br><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">1</span>: currentChar() ⇒ 'A'</span><br><span class="line"><span class="attribute">2</span>:  nextChar()    ⇒ 'B'</span><br><span class="line"><span class="attribute">3</span>:  nextChar()    ⇒ 'C'</span><br><span class="line"><span class="attribute">4</span>:  nextChar()    ⇒ 'D'</span><br><span class="line"><span class="attribute">5</span>:  currentChar() ⇒ 'D'</span><br><span class="line"><span class="attribute">6</span>:  currentChar() ⇒ 'D'</span><br><span class="line"><span class="attribute">7</span>:  nextChar()    ⇒ 'E'</span><br><span class="line"><span class="attribute">8</span>:  nextChar()    ⇒ EOL</span><br></pre></td></tr></table></figure></p><p>nextChar()　“吞噬”当前字符<code>（将currentPos增1使其指向下一个字符）</code>，但currentChar()不是。有时候你需要调用nextChar()吞噬当前字符，但不用它返回的字符。你将会在后面和下章看到怎么使用这两个方法。</p><p>方法peekChar() “向前探测”<code>（后续将简称前探）</code>挨着当前字符的下一个字符，此操作不吞噬当前字符。下章中此方法将会区分单个Pascal Token “3.14”和三个Token “3..14.”。注意peekChar在当前位置处于行尾或者超过行尾是，不会读下一行，它总会返回EOL字符，这不会有啥问题。</p><p>在更新域line同时，方法readLine()会把lineNum加1且设置currentPos为0。</p><h4 id="Scanner类"><a href="#Scanner类" class="headerlink" title="Scanner类"></a>Scanner类</h4><p>清单2-3 展示了框架抽象类Scanner。语言相关的子类将会实现extractMethod方法。Parser调用其nextToken() 方法，而nextToken()方法调用extractToken()去设置和返回私有域currentToken的值。快捷方法currentChar()和nextChar()来自于Source类对应的方法。<br>清单2-3 抽象类Scanner<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"> 1: /**</span><br><span class="line"> 2:  * &lt;p&gt;语言无关的scanner，产生Token&lt;/p&gt;</span><br><span class="line"> 3:  */</span><br><span class="line"> 4: public abstract class Scanner</span><br><span class="line"> 5: &#123;</span><br><span class="line"> 6:     protected Source source;</span><br><span class="line"> 7:     <span class="keyword">private</span> Token currentToken;  //当前Token</span><br><span class="line"> 8:     public Scanner(Source source)</span><br><span class="line"> 9:     &#123;</span><br><span class="line"><span class="section">10:         this.source = source;</span></span><br><span class="line"><span class="section">11:     &#125;</span></span><br><span class="line"><span class="section">12:     public Token currentToken()</span></span><br><span class="line"><span class="section">13:     &#123;</span></span><br><span class="line"><span class="section">14:         return currentToken;</span></span><br><span class="line"><span class="section">15:     &#125;</span></span><br><span class="line"><span class="section">16:</span></span><br><span class="line"><span class="section">17:     /**</span></span><br><span class="line"><span class="section">18:      * 以source中的char序列模式抽取token</span></span><br><span class="line"><span class="section">19:      * @return 下一个token</span></span><br><span class="line"><span class="section">20:      * @throws Exception</span></span><br><span class="line"><span class="section">21:      */</span></span><br><span class="line"><span class="section">22:     public Token nextToken()</span></span><br><span class="line"><span class="section">23:         throws Exception</span></span><br><span class="line"><span class="section">24:     &#123;</span></span><br><span class="line"><span class="section">25:         currentToken = extractToken();</span></span><br><span class="line"><span class="section">26:         return currentToken;</span></span><br><span class="line"><span class="section">27:     &#125;</span></span><br><span class="line"><span class="section">28:</span></span><br><span class="line"><span class="section">29:     /**</span></span><br><span class="line"><span class="section">30:      * 因为每个源语言的Token构成方式不一样，所以这个具体语言的子类去实现。</span></span><br><span class="line"><span class="section">31:      * @return 语言相关的Token</span></span><br><span class="line"><span class="section">32:      * @throws Exception</span></span><br><span class="line"><span class="section">33:      */</span></span><br><span class="line"><span class="section">34:     protected abstract Token extractToken()</span></span><br><span class="line"><span class="section">35:         throws Exception;</span></span><br><span class="line"><span class="section">36:</span></span><br><span class="line"><span class="section">37:    /**</span></span><br><span class="line"><span class="section">38:     * source的一个快捷方法，可让子类比不依赖source</span></span><br><span class="line"><span class="section">39:     * @return 要读取的字符</span></span><br><span class="line"><span class="section">40:     * @throws Exception</span></span><br><span class="line"><span class="section">41:     */</span></span><br><span class="line"><span class="section">42:     public char currentChar()</span></span><br><span class="line"><span class="section">43:         throws Exception</span></span><br><span class="line"><span class="section">44:     &#123;</span></span><br><span class="line"><span class="section">45:         return source.currentChar();</span></span><br><span class="line"><span class="section">46:     &#125;</span></span><br><span class="line"><span class="section">47:     /**</span></span><br><span class="line"><span class="section">48:      * source的一个快捷方法，可让子类比不依赖source</span></span><br><span class="line"><span class="section">49:      * @return 下一个要读取的字符</span></span><br><span class="line"><span class="section">50:      * @throws Exception</span></span><br><span class="line"><span class="section">51:      */</span></span><br><span class="line"><span class="section">52:</span></span><br><span class="line"><span class="section">53:     public char nextChar()</span></span><br><span class="line"><span class="section">54:         throws Exception</span></span><br><span class="line"><span class="section">55:     &#123;</span></span><br><span class="line"><span class="section">56:         return source.nextChar();</span></span><br><span class="line"><span class="section">57:     &#125;</span></span><br><span class="line"><span class="section">58: &#125;</span></span><br></pre></td></tr></table></figure></p><h4 id="Token类"><a href="#Token类" class="headerlink" title="Token类"></a>Token类</h4><p>代码清单2-4 展示了Token类的关键方法<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span>: <span class="comment">/**</span></span><br><span class="line"><span class="comment"> 2:  * &lt;p&gt;Scanner扫描返回的最小语法单元，也是个比不可少的框架类&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> 3:  */</span></span><br><span class="line"> <span class="number">4</span>: <span class="keyword">public</span> <span class="keyword">class</span> Token</span><br><span class="line"> <span class="number">5</span>: &#123;</span><br><span class="line"> <span class="number">6</span>:     <span class="keyword">protected</span> TokenType type;  <span class="comment">// 语言相关的Token类型</span></span><br><span class="line"> <span class="number">7</span>:     <span class="keyword">protected</span> String text;     <span class="comment">// 字面文本</span></span><br><span class="line"> <span class="number">8</span>:     <span class="keyword">protected</span> Object value;    <span class="comment">// 值，如果是一些常量，直接可以算出值来的</span></span><br><span class="line"> <span class="number">9</span>:     <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">Source</span> <span class="keyword">source</span>;   <span class="comment">// source</span></span><br><span class="line"><span class="number">10</span>:     <span class="keyword">protected</span> <span class="keyword">int</span> lineNum;     <span class="comment">// 所在行</span></span><br><span class="line"><span class="number">11</span>:     <span class="keyword">protected</span> <span class="keyword">int</span> position;    <span class="comment">// Token第一个字符所在的位置，即行中列位置</span></span><br><span class="line"><span class="number">12</span>:     <span class="keyword">public</span> Token(<span class="keyword">Source</span> <span class="keyword">source</span>)</span><br><span class="line"><span class="number">13</span>:         <span class="keyword">throws</span> Exception</span><br><span class="line"><span class="number">14</span>:     &#123;</span><br><span class="line"><span class="number">15</span>:         <span class="keyword">this</span>.<span class="keyword">source</span> = <span class="keyword">source</span>;</span><br><span class="line"><span class="number">16</span>:         <span class="keyword">this</span>.lineNum = <span class="keyword">source</span>.getLineNum();</span><br><span class="line"><span class="number">17</span>:         <span class="keyword">this</span>.position = <span class="keyword">source</span>.getPosition();</span><br><span class="line"><span class="number">18</span>:         extract();</span><br><span class="line"><span class="number">19</span>:     &#125;</span><br><span class="line"><span class="number">20</span>:</span><br><span class="line"><span class="number">21</span>:     <span class="comment">/**</span></span><br><span class="line"><span class="comment">22:      * 当前为演示框架组件，每次都返回一个字符的Token，实际不是这样的，后面章节会改。&lt;br&gt;</span></span><br><span class="line"><span class="comment">23:      * 但是吞噬原理是一样的，每当Token构成完之后，都把位置游标前移一步。</span></span><br><span class="line"><span class="comment">24:      * @throws Exception</span></span><br><span class="line"><span class="comment">25:      */</span></span><br><span class="line"><span class="number">26</span>:     <span class="keyword">protected</span> <span class="keyword">void</span> extract()</span><br><span class="line"><span class="number">27</span>:         <span class="keyword">throws</span> Exception</span><br><span class="line"><span class="number">28</span>:     &#123;</span><br><span class="line"><span class="number">29</span>:         text = Character.toString(currentChar());</span><br><span class="line"><span class="number">30</span>:         value = <span class="keyword">null</span>;</span><br><span class="line"><span class="number">31</span>:         <span class="comment">//吞噬&amp;前进</span></span><br><span class="line"><span class="number">32</span>:         nextChar();</span><br><span class="line"><span class="number">33</span>:     &#125;</span><br><span class="line"><span class="number">34</span>:</span><br><span class="line"><span class="number">35</span>:     <span class="keyword">protected</span> <span class="keyword">char</span> currentChar()</span><br><span class="line"><span class="number">36</span>:         <span class="keyword">throws</span> Exception</span><br><span class="line"><span class="number">37</span>:     &#123;</span><br><span class="line"><span class="number">38</span>:         <span class="keyword">return</span> <span class="keyword">source</span>.currentChar();</span><br><span class="line"><span class="number">39</span>:     &#125;</span><br><span class="line"><span class="number">40</span>:</span><br><span class="line"><span class="number">41</span>:     <span class="keyword">protected</span> <span class="keyword">char</span> nextChar()</span><br><span class="line"><span class="number">42</span>:         <span class="keyword">throws</span> Exception</span><br><span class="line"><span class="number">43</span>:     &#123;</span><br><span class="line"><span class="number">44</span>:         <span class="keyword">return</span> <span class="keyword">source</span>.nextChar();</span><br><span class="line"><span class="number">45</span>:     &#125;</span><br><span class="line"><span class="number">46</span>:</span><br><span class="line"><span class="number">47</span>:     <span class="keyword">protected</span> <span class="keyword">char</span> peekChar()</span><br><span class="line"><span class="number">48</span>:         <span class="keyword">throws</span> Exception</span><br><span class="line"><span class="number">49</span>:     &#123;</span><br><span class="line"><span class="number">50</span>:         <span class="keyword">return</span> <span class="keyword">source</span>.peekChar();</span><br><span class="line"><span class="number">51</span>:     &#125;</span><br><span class="line"><span class="number">52</span>: &#125;</span><br></pre></td></tr></table></figure></p><p>根据概念设计，scanner构造出token然后把它们交给parser。因为TokenType是一个接口，你能设置Token的类型<code>(域type)</code>为一个语言相关的值。下章将会演示scanner如何根据当前字符<code>（源文件中）</code>，也就是token的首字符，判定要构造的下一个Token的类型。例如，如果首字符为数字，则下一个token为number类型；如果为字母，则下一个token可以是标识符(ID)或关键字，因为你用不同Token子类来表示不同Token类型，scanner将会根据首字符调用Token子类相应的构造函数。</p><p>构造函数调用extract()方法去实际构造一个Token。方法(<strong>extract</strong>)名意味着此方法将会从source中读取字符来抽取token。Token子类根据语言相关的token类型逻辑实现extract方法。Token类提供了一个默认的单字符Token实现。除少数情况，extract()实现会吞噬token字符，而把行的当前位置到Token尾字符的下一个位置<code>（假设when i &lt; k 抽取到Token when，那么首字符为w，尾字符为n，则当前行位置会定位到 i，因为一般空格会被忽略）</code>。<br>调用extract方法之前，构造函数设置token文本所在行和首字符行中位置。比如关键字BEGIN的文本串可为”begin”<code>（Pascal大小写不敏感）</code>，如果文本begin在第11到15位置，那么首字符位置为11，在extract方法返回后，当前位置为16。<code>(15的下一个）</code></p><p>有些Token有值<code>（一般为常量Token)</code>。比如一个数字token的文本是”3.14159”则值与Pi近似。</p><p>跟Scanner类一样，Token类同样是调用source对象响应方法，实现了currentChar()和nextChar()和peekChar()。</p><p>清单2-5 展示了TokenType标记接口。语言相关的Token类型将会用到实现接口。<code>（标记接口不定义任何方法，它主要用来标识实现了此接口的类。比如所有实现了TokeType接口被认为是Token类型，这在JDK中就有，比如有名的java.io.Serializable类)</code></p><p>清单2-5：TokenType接口<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">1: package wci.frontend;</span></span><br><span class="line"><span class="section">2:</span></span><br><span class="line"><span class="section">3: /**</span></span><br><span class="line"><span class="section">4:  * &lt;p&gt;Token类型，此章没有任何具体类型实现，仅仅是个为演示框架的占位类&lt;/p&gt;</span></span><br><span class="line"><span class="section">5:  */</span></span><br><span class="line"><span class="section">6: public interface TokenType</span></span><br><span class="line"><span class="section">7: &#123;</span></span><br><span class="line"><span class="section">8: &#125;</span></span><br></pre></td></tr></table></figure></p><p>清单2-6 暂时了语言无关的EofToken子类。因为它仅仅表示文件结束，所以覆盖extract方法后啥事都没干。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span>: <span class="keyword">package</span> wci.frontend;</span><br><span class="line"> <span class="number">2</span>:</span><br><span class="line"> <span class="number">3</span>: <span class="comment">/**</span></span><br><span class="line"><span class="comment"> 4:  * &lt;p&gt;表示文件结束的特殊Token&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> 5:  */</span></span><br><span class="line"> <span class="number">6</span>: public <span class="class"><span class="keyword">class</span> <span class="title">EofToken</span> <span class="keyword">extends</span> <span class="title">Token</span></span></span><br><span class="line"><span class="class"> 7</span>: &#123;</span><br><span class="line"> <span class="number">8</span>:     public <span class="type">EofToken</span>(<span class="type">Source</span> source)</span><br><span class="line"> <span class="number">9</span>:         <span class="keyword">throws</span> <span class="type">Exception</span></span><br><span class="line"><span class="number">10</span>:     &#123;</span><br><span class="line"><span class="number">11</span>:         <span class="keyword">super</span>(source);</span><br><span class="line"><span class="number">12</span>:     &#125;</span><br><span class="line"><span class="number">13</span>:     <span class="keyword">protected</span> void extract(<span class="type">Source</span> source)</span><br><span class="line"><span class="number">14</span>:         <span class="keyword">throws</span> <span class="type">Exception</span></span><br><span class="line"><span class="number">15</span>:     &#123;</span><br><span class="line"><span class="number">16</span>:     &#125;</span><br><span class="line"><span class="number">17</span>: &#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 编译器和解释器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 编译器 </tag>
            
            <tag> 解释器 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>（基于Java）编写编译器和解释器-第一章：介绍-Part-2</title>
      <link href="/2018/07/18/%E7%BC%96%E8%AF%91%E5%99%A8%E7%AC%AC%E4%B8%80%E7%AB%A0Part2/"/>
      <url>/2018/07/18/%E7%BC%96%E8%AF%91%E5%99%A8%E7%AC%AC%E4%B8%80%E7%AB%A0Part2/</url>
      <content type="html"><![CDATA[<h2 id="为什么学习编译器编写技术？"><a href="#为什么学习编译器编写技术？" class="headerlink" title="为什么学习编译器编写技术？"></a>为什么学习编译器编写技术？</h2><p>我们都想当然的认为对编译器和解释器学习了个大概，因为你在开发中需要聚焦在编写和调试程序上，你甚至不需要思考编译器的工作机制。<a id="more"></a><br>你或许仅仅在搞错语法编译器抛出错误信息后才留意到编译器的存在。如果没有语法错误，那么编译将会生成正确的代码无疑。如果你的程序运行失常，你有可能怪罪编译器，但大多时候，你会发现错误在你的程序中。</p><p>以上情形通常会出现在你在使用某个流行编程语言<code>(比如Java或C++)</code>它的编译器、解释器和IDE都给你准备好了的时候。这先聊到这。</p><p>不过最近我们看到很多新编程语言在被开发。驱动力包括www<code>(比如HTML5）</code>和与基于web的应用相适应的新语言（典型比如PHP，纯web）。对程序员生产力的更高要求催生与具体应用领域紧密结合的新语言<code>（这个可以举很多例子，比如为系统管理员的各种Shell语言，为数据库开发的各种SQL/NO SQL语言，为电路板/DSP开发的类VHDL语言等，为工作流开发的各种BPM语言等）</code>。你可能非常期待自己有天能发明个新脚本语言表达算法或控制与你领域相关的流程。如果你要发明新语言，对应的编译器和解释器必不可少。</p><p>编译器和解释器本身很好玩，但你前面注意到了，任何一个都不是个小程序，要开发成功相关的技能，现代软件工程法则和良好的OO设计思想必不可少。除了学习编译器解释器工作机制带来的满足感外，你也要笑着面对编写它们带来的挑战。</p><h2 id="概念设计"><a href="#概念设计" class="headerlink" title="概念设计"></a>概念设计</h2><p>为接下几章做准备，让我们重温编译器和解释器的概念设计</p><blockquote><p><strong>设计笔记</strong>：程序的概念设计是它的软件架构的一个高级视图。概念设计包含程序的主要组件，它们怎么组织，相互之间的交互细节等。它不需要说明组件怎么实现，更确切的说，它可让你先确认和理解组件而无需担心最终怎么去开发它们。</p></blockquote><p>你可将编译器和解释器归为程序语言翻译器。如前面解释的那样，编译器将源程序翻译成机器语言而解释器将之翻译成系列动作(<strong>Action</strong>)。站在最高角度看翻译器，它包含一个前端(<strong>front end</strong>)和一个后端(<strong>back end</strong>)。遵从软件重用法则，你将看到Pascal编译器和Pascal解释器共享前端，但有不同的后端。</p><p>翻译器的前端读入源程序然后执行最初的翻译过程。它的主要组件有parser, scanner<code>(更学院派的说法是Lexer即词法分析器)</code>，token<code>（最小语言单位，最大词法单元)</code>和source<code>（表示源代码)</code></p><p>paser控制前端的翻译过程。它不断的从scanner读入token，根据token串<code>（就是token模式)</code>判定当前正翻译的高阶语言元素，比如算术表达式，赋值语句，过程申明等。parser检验源程序的语法是否正确。paser干的事情称之为解析(<strong>parsing</strong>)，parser分析源程序然后将之转换。<code>（转换成啥？后面会有，一般为抽象语法树之类的中间层）</code></p><p>scanner一个接一个字符读入源程序的内容，然后构造tokens即源语言的低阶元素。例如Pascal tokens包含关键字如BEGIN、END、IF、THEN和ELSE，标识符即变量、过程、函数名称<code>(identifier，又称ID)</code>以及特殊符号如= := + - *和/ 。scanner干的事情称为扫描(<strong>scanning</strong>)。scanner扫描源程序，将之分成一个个token。</p><p>下图展示了编译器和解释器前端的概念设计：</p><p><img src="/2018/07/18/编译器第一章Part2/1-2.png" alt="图1.2"></p><p>此图中，箭头表示一个组件给另外一个发送命令。parser告诉scanner要下一个token。scanner从source中获取字符然后构造新的token。token 也从source中读入字符。<code>(13章会讲到为何scanner和token组件都需要从source中读取字符)</code></p><p>编译器最终将源程序翻译成机器语言目标代码，所以后端的一个重要组件是代码生成器(目标代码生成器 code generator)。解释器执行程序，所以其后端的首要组件是执行器(<strong>executor</strong>)。</p><p>如果你想让编译器和解释器共享前端，那么它们不同的后端需要有个通用接口用来与前端打交道（也就是只需要将前端传入这个接口即可)。记住前端处理最初的翻译过程。前端生成作为公共接口中间层的中间代码(<strong>intermediate code，分析树/语法树，抽象语法树等</strong>)和符号表(<strong>symbol table</strong>)。</p><p>中间码(<strong>intermediate code</strong>)是源程序的预摘要格式<code>(pre-digested，可以理解为在源程序格式和机器语言格式中间的一个摘要格式，一般为分析树parse tree或语法树syntax tree)</code>为方便后端的更有效处理<code>（假设翻译器将塑料翻译成为瓶子，那么源程序为塑料，中间码为瓶盖，瓶身，包装纸，这样后端就能更快的装瓶子)</code>。本书中的中间码是一个驻内存表示源程序语句的树状数据结构<code>(也就是语法树，废话一堆啊)</code>。符号表包含源程序的符号信息(比如标识符)。编译器的后端处理中间码和符号表，生成源程序对应的机器语言。解释器碰到中间码和符号表就直接执行了<code>（通常是树遍历过程)</code>。</p><p>为软件重用，你可将中间码和符号表设计成语言无关的结构。换句话说，你可用同样的结构应用于不同的源语言。因此，后端同样可以语言无关，当它处理这些结构<code>（中间码和符号表）</code>是根本不需要知道具体源语言。</p><p>下图展示了一个更为复杂的编译器和解释器的概念设计。如果你万事安好，仅需前端知道源语言定义且仅需后端知道区分编译器和解释器。</p><p><img src="/2018/07/18/编译器第一章Part2/1-3.png" alt="图1.3"></p><p>第2章开始通过设计一个编译器解释器框架来充实概念设计。第3章讲的是扫描(<strong>scanning</strong>)。第4章构建第一个符号表，第五章生成最初的中间码。第6章开始编写执行器(<strong>executor</strong>)且增量式开发直到14章，其中包含符号调试器和IDE。代码生成直到在15章学了了JVM架构之后的16章才涉及。</p><h2 id="语法和语义-syntax-and-semantics"><a href="#语法和语义-syntax-and-semantics" class="headerlink" title="语法和语义(syntax and semantics)"></a>语法和语义(syntax and semantics)</h2><p>编程语言的语法是一系列规则用来断定用此语言写的语句或表达式是否正确。语言的语义传达语句和表达式的具体意思<code>（赋值谁赋给谁，循环终止条件是什么）</code>。举个例子，Pascal的语法告诉我们 i := j+k 是一个有效的赋值语句。它的语义是说将变量j 和k的当前值加起来，然后将和赋给 i。</p><p>parser基于源语言的语法和语义执行有关动作。扫描源程序抽取tokens是语法动作。查找赋值语句 := 之后的目标变量是语法动作。将标识符(<strong>identifiers</strong>) i、j、k当作变量存入符号表或日后在符号表中查找是语义动作，因为parser必须明白当前表达式和赋值的意思才知道得用到符号表。生成代表此赋值语句的中间码属于语义动作。</p><p>语法动作尽在前端发生，语义动作在前后端都有。在后端执行程序或者生成目标代码需要知道语句的具体意思，所以是语义动作一部分。中间码和符号表存储语义信息。</p><h2 id="词法，语法和语义分析"><a href="#词法，语法和语义分析" class="headerlink" title="词法，语法和语义分析"></a>词法，语法和语义分析</h2><p>词法分析是扫描(<strong>scanning</strong>)的正式说法，所以scanner也称词法分析器(<strong>lexical analyzer</strong>)。语法分析是parsing<code>(解析，parser的主要任务)</code>的正式称谓，语法分析器就是parser。语义分析主要是检查语义规则是否完整。类型检查(<strong>type checking</strong>)就是一例，它确保操作符(<strong>operator</strong>)的操作数(<strong>operand</strong>)类型保持一致。其它的语义分析操作有构造符号表和生成中间码。</p>]]></content>
      
      <categories>
          
          <category> 编译器和解释器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 编译器 </tag>
            
            <tag> 解释器 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>（基于Java）编写编译器和解释器-第一章：介绍-Part-1</title>
      <link href="/2018/07/18/%E7%BC%96%E8%AF%91%E5%99%A8%E7%AC%AC%E4%B8%80%E7%AB%A0/"/>
      <url>/2018/07/18/%E7%BC%96%E8%AF%91%E5%99%A8%E7%AC%AC%E4%B8%80%E7%AB%A0/</url>
      <content type="html"><![CDATA[<blockquote><p>本章描述了本书的目标和用到的方法并鸟瞰编译器和解释器的全貌。</p></blockquote><h2 id="目标和方法"><a href="#目标和方法" class="headerlink" title="目标和方法"></a>目标和方法</h2><p>本书讲授编译器和解释器的基本写法，目标是呈现给你怎样设计和开发它们：</p><a id="more"></a><ul><li>用Java写的编译器，编译Pascal(一个高级的面向过程的编程语言)的一个主要子集。<code>(即包含主要的语言特征，但去掉一些为写编译器方便而去掉的无关大雅的特性。)</code></li><li>用Java写的解释器且包含一个交互式的符号调试器<code>(符号调试器即基于符号表，而不是基于机器的指令集、硬件的调试功能)</code>，解释同样的Pascal语言子集。</li><li>带图形用户界面的集成开发环境(IDE)。这个IDE是你看到的功能全面的开源的Eclipse或者Borland的JBuilder等IDE的一个简化版。不过，它也包含一个源程序编辑器和一个交互界面用来设置断点，单步调试，查看和修改变量值等等其它。</li></ul><p>达成这些个极具野心的目标是个大挑战。好的技能将会帮你如何如把程序编译成为机器语言或解释执行程序。现代软件工程法则和优秀的面向对象设计思想将会给你呈现怎么通过代码实现一个编译器或解释器而最终所有组件能良好协作。编译器和解释器程序大且复杂。开发个小程序仅需要某种技能即可，然NB的程序如编译器或解释器还需要软件工程法则和面向对象设计。因此本书强调必备技能，软件工程法则和面向对象思想。</p><h2 id="什么是编译器和解释器"><a href="#什么是编译器和解释器" class="headerlink" title="什么是编译器和解释器"></a>什么是编译器和解释器</h2><p>编译器和解释器的主要目的是“翻译”由高阶(High-Level)源语言写的源程序。把源程序翻译成什么样是接下几个段落的主题。</p><p>本书中源语言为Pascal的一个大子集，换句话说，你能够编译或解释正规的Pascal程序。因为编译器和解释器是用Java写的，实现语言是Java。</p><p>Pascal编译器将Pascal源程序翻译成为低阶(Low-Level)的某具体机器的机器语言<code>（更准确的讲是CPU的机器语言)</code>。通常源程序是文本格式。如果编译器工作正常，对应的机器语言和最初的Pascal源程序殊路同归<code>（一样的行为，只不过呈现方式不一样。比如你用钥匙而偷车的直接电线打火发动汽车一样）</code>。机器语言是目标语言，编译器生成用机器语言组成目标代码。代码生成之后，编译器任务就算完成。目标代码一般写到文件里<code>（一般是二进制文件）</code>。</p><p>一个程序可包含数个源文件，而编译器为每个文件生成一个目标文件。一个名叫“链接器”(linker)的辅助程序将这些目标文件的内容连同运行时库程序合成到一个计算机能够加载和执行的目标程序<code>(如windows的PE程序)</code>中。库程序一般来自于预先编译好的目标文件。</p><p>因为机器语言不好记，编译器可生成汇编语言作为目标语言，汇编语言离机器语言只有一步之遥。通常每个汇编指令都有机器语言的指令与之对应。如果你掌握了短助记名<code>（比如ADD和MOV等）</code>汇编语言好记多了。汇编器<code>（另一个编译器）</code>将汇编语言翻译成为机器语言。</p><p>下图概括了将一个或多个源程序编译成为目标程序的过程。</p><p><img src="/2018/07/18/编译器第一章/1-1.png" alt="图1"></p><p>上图展示了将一个包含三个源文件sort1.pas、sort2.pas、sort3.pas的Pascal程序翻译成为三个相应机器语言目标文件sort1.obj、sort2.obj、sort3.obj。链接器将三个目标文件<code>（连带相关运行时库)</code> 合成为一个可执行的目标程序sort.exe。图右边展示了编译器将Pascal源文件翻译为汇编语言目标文件sort1.asm、sort2.asm、sort3.asm，接着汇编器将其转化为机器语言目标文件。最后链接器产生目标程序sort.exe。</p><h4 id="那么编译器和解释器到底有和不同？"><a href="#那么编译器和解释器到底有和不同？" class="headerlink" title="那么编译器和解释器到底有和不同？"></a>那么编译器和解释器到底有和不同？</h4><p>解释器不生成任何目标程序，相反它读进源程序就会执行。这好比你被一个Pascal程序把住手，按照它说的某种语句读进顺序去做。你可以在一张草稿纸上记下程序的变量值直到程序结束才输出每条语句的输出结果。本质上你做的正是Pascal解释器干的事情。Pascal解释器读进程序，执行程序。没有任何目标程序需要生成和加载，相反，解释器将程序翻译成为一系列用来执行程序的动作(Action)。</p><h2 id="比较编译器和解释器"><a href="#比较编译器和解释器" class="headerlink" title="比较编译器和解释器"></a>比较编译器和解释器</h2><h4 id="该如何决策何时用编译器和何时用解释器？"><a href="#该如何决策何时用编译器和何时用解释器？" class="headerlink" title="该如何决策何时用编译器和何时用解释器？"></a>该如何决策何时用编译器和何时用解释器？</h4><p>当你把一个源程序交给解释器，解释器接管检查和执行。编译器也检查但生成目标代码。运行完编译器之后还有运行链接器产生目标程序，且还需加载目标程序到内存中去执行它。如果编译器生成汇编语言代码，你还得运行汇编器。所以很显然解释器需要更少步骤。<br>解释器比编译器更常见。你可用Java写个Pascal解释器运行在基于微软Windows的PC上，苹果的MAC或某个Linux主机上，解释器能够在前面提到的平台上执行Pascal程序。而编译器必须为某个具体的机器生成代码<code>（无论直接生成或间接通过汇编器生成)</code>。所以即使你要把原来为PC写的Pascal编译器放到MAC上运行，它生成的代码仍旧是PC的，如果想让它为MAC生成代码，你可能得重写编译器的某些部分。</p><blockquote><p>接下来讨论的编译器将问题的重心放在为Java虚拟机生成代码上，因为虚拟机能够运行在很多平台上。所以为具体机器生成代码先放一边，有兴趣可以将虚拟机替换成为真实PC机上生成x86指令看看。</p></blockquote><h4 id="如果源程序中包含逻辑错误，比如除值为0的变量，直到运行时才发现，那么会发生什么情况？"><a href="#如果源程序中包含逻辑错误，比如除值为0的变量，直到运行时才发现，那么会发生什么情况？" class="headerlink" title="如果源程序中包含逻辑错误，比如除值为0的变量，直到运行时才发现，那么会发生什么情况？"></a>如果源程序中包含逻辑错误，比如除值为0的变量，直到运行时才发现，那么会发生什么情况？</h4><p>因为解释器在执行程序过程中控制一切，它能停下来告诉你出问题的行数和变量名称。它甚至能提示你在继续执行程序之前可以做哪些正确操作比如修改变量值为非零。解释器可包含一个交互式的源级<code>(source-level)</code>调试器，俗称符号调试器<code>(symbolic debugger)</code>。符号调试器意味着你可用程序中的符号，比如变量名。<br>另一方面，由编译器和链接器产生的目标程序通常自我运行<code>（由机器执行，无需第三方）</code>。源程序有关行号和变量名等信息在目标程序中不可见。当运行时抛错，程序简单中断，还可能打印一条包含出问题指令地址的消息。于是找出源程序中相关语句变量除零的问题就交给你了。</p><p>所以通常就调试来说，解释器才是正道。有些编译器在目标代码中添加一些额外的信息，这样当错我发生时，目标程序能打印出相应的问题行数和变量名等。于是你改正错误，重新编译，然后重新运行。生成额外的信息会导致程序执行的比正常要慢<code>（这也是Visual C++为什么有Run/Debug编译模式）</code>。这提示你在认为程序到达最终“产品”版本后，应关掉调试特征重新编译。</p><p>假设你已经成功调试好程序，那重点将是怎样使运行更快。因为机器能够以最快速度执行原生机器语言程序，编译程序能够比解释器快好几个量级。显然就速来来说编译器是胜者，当优化版编译器知道怎么生成具体场景的优化代码的情况下尤其确定。所以是否使用编译器或解释器取决于程序的开发和执行谁更重要。理想情况是一个带符号源级调试器的解释器用在开发过程中，一个生成机器代码的编译器在程序调试OK之后以求更快的执行速度。这些就是本书的目标，因为它编译器，解释器都教。</p><h2 id="情景变得有点模糊"><a href="#情景变得有点模糊" class="headerlink" title="情景变得有点模糊"></a>情景变得有点模糊</h2><p>编译器和解释器的差异很容易说明清楚，但是随着虚拟机的快速流行，情景变得有点模糊。</p><p>虚拟机是一个用来模拟机器<code>（计算机）</code>的程序。此程序能够运行在不同的真实计算机平台上。举个例子，Java 虚拟机(JVM)能够运行在基于微软Windows的PC上，苹果的MAC，Linux系统和其它很多平台上。<code>（比如Sparc，IBM小型机等）</code>。</p><p>虚拟机有自己的虚拟机器语言，而虚拟语言指令被真实宿主机所解释。那么如果你写了一个翻译器将Pascal源程序翻译成为被宿主机解释的虚拟机语言，这个翻译器算编译器还是解释器？</p><p>不斤斤计较了，我们本书约定如果一个翻译器将源程序转化成为机器语言，不管是真实的机器语言还是虚拟机器语言，那么这个翻译器就是编译器。翻译器没有优先生成机器语言去执行程序的就算解释器。</p><blockquote><p>声明：本文转载自博客园Bang老师，为英版原书《Writing Compilers and Interpreters 3rd Edition》译文。转载只为学习。<a href="https://www.cnblogs.com/lifesting/archive/2012/07/11/2585860.html" target="_blank" rel="noopener">博客地址</a><br>至今与Bang老师联系不上，译文阅读量极低，故为扩大该译文的影响力，笔者擅自转载。由于Bang老师只译到第十一章，但最后的九个章节笔者会自己翻译。</p></blockquote>]]></content>
      
      <categories>
          
          <category> 编译器和解释器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 编译器 </tag>
            
            <tag> 解释器 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>（基于Java）编写编译器和解释器：书的组织结构</title>
      <link href="/2018/07/09/%E7%AC%AC%E4%B8%80%E7%AB%A0%E7%BB%84%E6%88%90/"/>
      <url>/2018/07/09/%E7%AC%AC%E4%B8%80%E7%AB%A0%E7%BB%84%E6%88%90/</url>
      <content type="html"><![CDATA[<blockquote><p>该书共有19章，加上最后的名词索引表部分</p></blockquote><h3 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h3><p>该章是一个总体介绍。<br><a id="more"></a></p><h3 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h3><p>该章描述组织该编译器和解释器的总体框架。它用来设计和测试它的结构化建立端，以便于所有章节的代码都能成功地基于它建立起来。</p><h3 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h3><h3 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h3><p>第三章和第四章来对付处理一些基础的翻译任务，即第三章来扫描源程序，第四章建立一个符号表。</p><blockquote><p>接下来的章节来建立工作的Pascal解释器。为使用逐渐增加的发展方法，本书采用个个章节进行多次迭代的语法分析和解释。</p></blockquote><h3 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h3><p>该章来语法分析表达式和赋值语句。</p><h3 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h3><p>该章将第五章的部分进行解释。</p><h3 id="第七章"><a href="#第七章" class="headerlink" title="第七章"></a>第七章</h3><p>该章语法分析控制语句。</p><h3 id="第八章"><a href="#第八章" class="headerlink" title="第八章"></a>第八章</h3><p>该章来解释第七章的部分。</p><h3 id="第九章"><a href="#第九章" class="headerlink" title="第九章"></a>第九章</h3><p>该章来语法分析声明语句。</p><h3 id="第十章"><a href="#第十章" class="headerlink" title="第十章"></a>第十章</h3><p>该章来处理类型检查。</p><h3 id="第十一章"><a href="#第十一章" class="headerlink" title="第十一章"></a>第十一章</h3><p>该章来语法分析过程语句、方法部分和整个Pascal程序。</p><h3 id="第十二章"><a href="#第十二章" class="headerlink" title="第十二章"></a>第十二章</h3><p>该章完成解释器并执行整个Pascal程序。</p><blockquote><p>接下来的两章会基于工作的解释器来建立。当你是第一次读该书的话，你可以选择跳过接下来的两章节，但是一定要确定来回头好好看一下，毕竟它对你还是很有帮助的。</p></blockquote><h3 id="第十三章"><a href="#第十三章" class="headerlink" title="第十三章"></a>第十三章</h3><p>该章增加了一个交互式的源级别的debugger，通过它你可以通过在命令行敲打命令来跟它进行交流。</p><h3 id="第十四章"><a href="#第十四章" class="headerlink" title="第十四章"></a>第十四章</h3><p>该章为这个基于命令行的debugger包装了一个图形交互页面来建一个集成开发环境IDE。</p><blockquote><p>该书的最后部分通过重用早些章节的代码来形成这个编译器。</p></blockquote><h3 id="第十五章"><a href="#第十五章" class="headerlink" title="第十五章"></a>第十五章</h3><p>该章介绍了Java虚拟机（JVM）和Jasmin的构造结构，其中Jasmin是一个帮助java虚拟机生成汇编语言的工具。</p><h3 id="第十六章"><a href="#第十六章" class="headerlink" title="第十六章"></a>第十六章</h3><p>该章编译程序、赋值语句和表达式。（迭代早些章节的实现）</p><h3 id="第十七章"><a href="#第十七章" class="headerlink" title="第十七章"></a>第十七章</h3><p>该章编译过程部分、方法部分回调，和string的操作。</p><h3 id="第十八章"><a href="#第十八章" class="headerlink" title="第十八章"></a>第十八章</h3><p>该章通过编译控制语句、arrays和记录来完成这个编译器。</p><h3 id="第十九章"><a href="#第十九章" class="headerlink" title="第十九章"></a>第十九章</h3><p>该最后一章是一个对许多对于编写编译器方面但没有在其他章节中提及到简短的介绍，例如代码优化和基于表格驱动的源码扫描器和语法分析器。</p>]]></content>
      
      <categories>
          
          <category> 编译器和解释器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 编译器 </tag>
            
            <tag> 解释器 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>（基于Java）编写编译器和解释器-第一章：介绍之前</title>
      <link href="/2018/07/09/%E7%AC%AC%E4%B8%80%E7%AB%A0/"/>
      <url>/2018/07/09/%E7%AC%AC%E4%B8%80%E7%AB%A0/</url>
      <content type="html"><![CDATA[<h2 id="关于翻译《Writing-Compilers-and-Interpreters-3rd-Edition》书籍"><a href="#关于翻译《Writing-Compilers-and-Interpreters-3rd-Edition》书籍" class="headerlink" title="关于翻译《Writing Compilers and Interpreters 3rd Edition》书籍"></a>关于翻译《Writing Compilers and Interpreters 3rd Edition》书籍</h2><h3 id="翻译这本书的想法"><a href="#翻译这本书的想法" class="headerlink" title="翻译这本书的想法"></a>翻译这本书的想法</h3><blockquote><p>这学期在学完《编译原理》这门课程之后，我是深深地被编译器的实现迷住了。。。<br><a id="more"></a><br>本学期的《编译原理课程设计》中最后用C++实现了一个小编译器，但是其中很大部分是借用该书的讲解实现，而且是C++语言。在Google、百度之后，千挑万选发现了这本很有名的但是并不为多数人了解的书（大家都不是特别关心编译器的实现）。</p></blockquote><p>相对于号称编译原理界的“三大圣书”：龙书——《编译原理技术和工具》-作者:Alfred V.Aho,Ravi Sethi,Jeffrey D.Ullman 、虎书——《现代编译原理-C语言描述》-作者：Andrew W.Appel,with Jens Palsberg 、鲸书——《高级编译器设计与实现》-作者：Steven S.Muchnick<br>“三大圣书”详情请访问<a href="https://www.cnblogs.com/Amedeo/archive/2017/11/24/7881889.html" target="_blank" rel="noopener">参考链接</a></p><p>但是，这本书是基于java，而且有更加详实完善的代码讲解，该书作者也是大名鼎鼎的Ronald Mak,其前两版讲解编译器的是使用的C/C++，加上目前该书目前没有英文版，故此笔者决定擅自翻译该书。</p><blockquote><p>笔者英语水平目前较差，仅是英语六级水平，但是为了读者理解，并尽量保证翻译质量，笔者会用心做好的。</p></blockquote>]]></content>
      
      <categories>
          
          <category> 编译器和解释器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 编译器 </tag>
            
            <tag> 解释器 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>UML之类图</title>
      <link href="/2018/07/06/UML%E4%B9%8B%E7%B1%BB%E5%9B%BE/"/>
      <url>/2018/07/06/UML%E4%B9%8B%E7%B1%BB%E5%9B%BE/</url>
      <content type="html"><![CDATA[<blockquote><p>限于Git空间有限，就不往博客中插入静态图片了，但是我的微信订阅号【星球码】上是有更加完整的文章。欢迎关注~</p></blockquote><h2 id="UML介绍"><a href="#UML介绍" class="headerlink" title="UML介绍"></a>UML介绍</h2><p>统一建模语言（英语：Unified Modeling Language，缩写 UML）是非专利的第三代建模和规约语言。UML是一种开放的方法，用于说明、可视化、构建和编写一个正在开发的、面向对象的、软件密集系统的制品的开放方法。UML展现了一系列最佳工程实践，这些最佳实践在对大规模，复杂系统进行建模方面，特别是在软件架构层次已经被验证有效。（来自维基百科） UML是在（常见但不限于）数据库设计过程中，在E-R图（实体-联系图）设计后的进一步建模。</p><h3 id="UML图"><a href="#UML图" class="headerlink" title="UML图"></a>UML图</h3><p>用例图、类图（今天主角）、对象图、包图、活动图、状态图、序列图（顺序图）、协作图、构件图、部署图（配置图）</p><blockquote><p>笔者在大三第一学期修了UML课程，当时是第一次接触UML，其中的各种图形，线条搞得有些乱套，好在最后课程大作业设计中，小组连战2天最后利用StarUML软件设计出一个图书管理系统，并利用给出一些简单的GUI。</p></blockquote><h2 id="UML类图线条"><a href="#UML类图线条" class="headerlink" title="UML类图线条"></a>UML类图线条</h2><blockquote><p>说明：类图中方法或属性前会出现+、-、#，该符号分表表示其访问权限是public、private、protected。</p><p>推荐大家使用一款免费的在线制作各种流程图的工具——ProcessOn。包括各种价值链图、过程链图、常规流程图、组织结构图、原型设计等，当然也支持熟悉的UML。（一条五毛~）</p></blockquote><p>线条表示类之间的关系，以下按照类之间关系由强到弱说明，即泛化=实现&gt;组合&gt;聚合&gt;关联&gt;依赖</p><blockquote><p>泛化和实现：子类或实现下面的方法表示增加/复写/实现了哪些方法</p></blockquote><h3 id="泛化"><a href="#泛化" class="headerlink" title="泛化"></a>泛化</h3><p>泛化：实线空白箭头，箭头指向父类，表示继承</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>实现：虚线空白箭头，箭头指向接口。</p><h3 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h3><blockquote><p>通过属性的引用形成组合关系，例如属性集合的引用。</p></blockquote><p>组合：是一种部分对整体的关系，实线，箭头指向部分，实心菱形指向整体。</p><h3 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h3><blockquote><p>通过属性引用形成的聚合关系，与关联类似，需要视具体场景。</p></blockquote><p>聚合：是群体对个体的关系，空心菱形指向群体，箭头指向其构成的个体。</p><h3 id="关联"><a href="#关联" class="headerlink" title="关联"></a>关联</h3><blockquote><p>通过属性引用形成的关联关系。</p></blockquote><p>关联：表示拥有关系，即has-a关系，箭头指向拥有者；但是如果是双向关联，两个箭头可以省略，即只有一条实线。</p><h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><blockquote><p>通过方法参数的依赖关系。</p></blockquote><p>依赖：表示一种协助关系，虚线，箭头指向被依赖者。</p><h3 id="欢迎搜索关注微信订阅号：【星球码】"><a href="#欢迎搜索关注微信订阅号：【星球码】" class="headerlink" title="欢迎搜索关注微信订阅号：【星球码】"></a>欢迎搜索关注微信订阅号：【星球码】</h3><p>笔者现在的知识十分有限，文章出现错误在所难免，还请各位能够多多包涵，并不吝指出啊~</p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/07/02/hello-world/"/>
      <url>/2018/07/02/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      <categories>
          
          <category> Hexo使用 </category>
          
      </categories>
      
      
    </entry>
    
  
  
</search>
